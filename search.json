[{"title":"Golang学习","url":"/golang%E5%AD%A6%E4%B9%A0/","content":"基础入门（语法）与Java的一些异同同样把代码按包（package）分开存放\n使用外部包同样需要import来导入\njava的函数方法，不需要显式指出是一个方法，只需要写明方法名字、公有私有、传参，而Go需要用 func 关键字来声明这是一个方法。\n 函数可以返回多个值\n接收函数返回值的形式略有不同（没有java那么简洁直接）\n包、变量、函数包每个 Go 程序都是由包构成的。\n程序从 main 包开始运行。（package main)\n通过import来导入包，之后才可以使用。\n按照约定，包名与导入路径的最后一个元素一致。\n即一个包可能有复杂的路径结构，在使用一个有复杂结构的包时，可以通过路径最后一个元素来使用这个包\n导入类似 Java 的 import 导入包。\n可以编写多个导入语句，如：\nimport &quot;fmt&quot;import &quot;math&quot;\n\n也可以使用分组导入，即用小括号将多个包包括起来，作为要导入的一组包，如：\nimport (\t&quot;fmt&quot;\t&quot;math&quot;)\n\n使用分组导入是更好的导入形式\n导出名在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。\n在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。\n导出名的使用例：\nfmt.Println(math.Pi)\n\n\n\n函数函数可以没有参数或接受多个参数。\n注意类型在变量名之后。\n返回值类型也写在了参数部分的后面\nfunc add(x int, y int) int &#123;\treturn x + y&#125;\n\n当连续的两个或者多个形参都是相同类型时，可以只注明最后一个形参的类型，而省略前面那些形参的类型。\nfunc add(x, y int) int &#123;\treturn x + y&#125;\n\n\n\n多值返回函数可以返回任意数量的返回值。\nfunc swap(x, y string) (string, string) &#123;\treturn y, x&#125;\n\n接收函数返回值的形式，相较于java（C）体系的形式有点奇怪\n注意，下例的ab没有声明类型，而是直接使用\na, b := swap(&quot;hello&quot;, &quot;world&quot;)\n\n\n\n命名返回值Go 的返回值可被命名，它们会被视作定义在函数顶部的变量（即函数开头就定义的变量）。\n没有参数的 return 语句返回已命名的返回值。也就是直接返回。\n直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\nfunc split(sum int) (x, y int) &#123;\tx = sum * 4 / 9\ty = sum - x\treturn&#125;func main() &#123;\tfmt.Println(split(17))&#125;\n\n（注：上面例子中，没有精细计算结果，没有四舍五入，直接抹去了小数部分）\n变量var语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。\n就像在这个例子中看到的一样，var语句可以出现在包或函数级别。\nfunc main() &#123;\tvar i int\tfmt.Println(i, c, python, java)&#125;\n\n（整型数默认是0，bool类型默认是false）\n变量的初始化*变量声明可以包含初始值，每个变量对应一个。\n如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。（声明同时初始化，可以省略类型）\nvar i, j int = 1, 2func main() &#123;\tvar c, python, java = true, false, &quot;no!&quot;\tfmt.Println(i, j, c, python, java)&#125;\n\n（问题：如果是小数，如何知道是浮点数还是双精度？   **默认是float64**）\n短声明语句在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。\n函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。\nfunc main() &#123;\tvar i, j int = 1, 2\tk := 3\tc, python, java := true, false, &quot;no!&quot;\tfmt.Println(i, j, k, c, python, java)&#125;\n\n\n\n基本类型boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名    // 表示一个 Unicode 码点float32 float64complex64 complex128\n\n本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。\nint, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\n例子：\npackage mainimport (\t&quot;fmt&quot;\t&quot;math/cmplx&quot;)var (\tToBe   bool       = false\tMaxInt uint64     = 1&lt;&lt;64 - 1\tz      complex128 = cmplx.Sqrt(-5 + 12i))func main() &#123;\tfmt.Printf(&quot;Type: %T Value: %v\\n&quot;, ToBe, ToBe)\tfmt.Printf(&quot;Type: %T Value: %v\\n&quot;, MaxInt, MaxInt)\tfmt.Printf(&quot;Type: %T Value: %v\\n&quot;, z, z)&#125;\n\n注：**%T**是获取类型的关键字\t\t%v是获取值的关键字\t\t对象对应于字符串后的两个参数\n（这种关键字可能是专门在字符串中使用的）\n零值没有明确初始值的变量声明会被赋予它们的 零值。\n\n数值类型为 0，\n布尔类型为 false，\n字符串为 &quot;&quot;（空字符串）。\n\nfunc main() &#123;\tvar i int\tvar f float64\tvar b bool\tvar s string\tfmt.Printf(&quot;%v %v %v %q\\n&quot;, i, f, b, s)    //获取字符串是%q&#125;\n\n结果是：\n\n类型转换表达式 T(v) 将值 v 转换为类型 T。  （T就指代了各种基本数据类型）\n一些关于数值的转换：\nvar i int = 42var f float64 = float64(i)var u uint = uint(f)\n\n或者，更加简单的形式：\ni := 42f := float64(i)u := uint(f)\n\n与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。\nfunc main() &#123;\tvar x, y int = 3, 4\tvar f float64 = math.Sqrt(float64(x*x + y*y))\tvar z uint = uint(f)\tfmt.Println(x, y, z)&#125;\n\n（转换中的float64()、uint()不能省略，否则无法正确的赋值给接收的元素）\n类型推导在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出。\n当右值声明了类型时，新变量的类型与其相同：\nvar i intj := i // j 也是一个 int\n\n不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度：\ni := 42           // intf := 3.142        // float64g := 0.867 + 0.5i // complex128\n\n\n\n常量可以在函数内函数外使用。\n常量的声明与变量类似，只不过是使用 const 关键字。      不是var+const，而是只有const\n常量可以是字符、字符串、布尔值或数值。\n常量不能用 := 语法声明。\nconst Pi = 3.14func main() &#123;\tconst World = &quot;世界&quot;\tfmt.Println(&quot;Hello&quot;, World)\tfmt.Println(&quot;Happy&quot;, Pi, &quot;Day&quot;)\tconst Truth = true\tfmt.Println(&quot;Go rules?&quot;, World)&#125;\n\n\n\n数值常量数值常量是高精度的 值。\n一个未指定类型的常量由上下文来决定其类型\nBig &#x3D; 1 &lt;&lt; 100      由其值决定其类型高于64位的int\n（int 可以存放最大64位的整数，根据平台不同有时会更少。）\nconst (\t// 将 1 左移 100 位来创建一个非常大的数字\t// 即这个数的二进制是 1 后面跟着 100 个 0\tBig = 1 &lt;&lt; 100\t// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2\tSmall = Big &gt;&gt; 99)func needInt(x int) int &#123; return x*10 + 1 &#125;func needFloat(x float64) float64 &#123;\treturn x * 0.1&#125;func main() &#123;\tfmt.Println(needInt(Small))\t\t//21\tfmt.Println(needFloat(Small))   //0.2\tfmt.Println(needFloat(Big))\t\t//1.2676506002282295e+29&#125;\n\n\n\n流程控制语句for循环Go 只有一种循环结构：for 循环。\n基本的 for 循环由三部分组成，它们用分号隔开：\n\n初始化语句：在第一次迭代前执行\n条件表达式：在每次迭代前求值\n后置语句：在每次迭代的结尾执行\n\n初始化语句和后置语句是可选的。（语句可有可无，但是分号不能少了）\nfor ; sum &lt; 1000; &#123;\tsum += sum&#125;\n\n初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。\n一旦条件表达式的布尔值为 false，循环迭代就会终止。\n如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。\nfunc main() &#123;\tfor &#123;\t&#125;&#125;\n\n注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 &#123; &#125; 则是必须的。\nGo中的while此时你可以去掉分号，因为 C 的 while 在 Go 中叫做 for。\nfunc main() &#123;\tsum := 1\tfor sum &lt; 1000 &#123;\t\tsum += sum\t&#125;\tfmt.Println(sum)&#125;\n\n\n\nif语句Go 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 &#123; &#125; 则是必须的。\nfunc sqrt(x float64) string &#123;\tif x &lt; 0 &#123;\t\treturn sqrt(-x) + &quot;i&quot;\t&#125;\treturn fmt.Sprint(math.Sqrt(x))&#125;func main() &#123;\tfmt.Println(sqrt(2), sqrt(-4))//真正的输出没有逗号，而是会自动隔开&#125;\n\n\n\nif的简短语句同 for 一样， if 语句可以在**条件表达式前**执行一个简单的语句。\n该语句声明的变量作用域仅在 if 之内。\nfunc pow(x, n, lim float64) float64 &#123;\tif v := math.Pow(x, n); v &lt; lim &#123;\t\treturn v\t&#125;\treturn lim&#125;func main() &#123;\tfmt.Println(\t\tpow(3, 2, 10),\t\tpow(3, 3, 20),\t)&#125;\n\n结果是 9  20\nif和else在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。\n（在 main 的 fmt.Println 调用开始前，两次对 pow 的调用均已执行并返回其各自的结果。）\nfunc pow(x, n, lim float64) float64 &#123;\tif v := math.Pow(x, n); v &lt; lim &#123;\t\treturn v\t&#125; else &#123;\t\tfmt.Printf(&quot;%g &gt;= %g\\n&quot;, v, lim)\t&#125;\t// 这里开始就不能使用 v 了\treturn lim&#125;func main() &#123;\tfmt.Println(\t\tpow(3, 2, 10),\t\tpow(3, 3, 20),\t)&#125;\n\n\n\n循环与函数（练习）https://tour.go-zh.org/flowcontrol/8\n算是第一个Go语言代码\npackage mainimport (\t&quot;fmt&quot;\t&quot;math&quot;)func Sqrt(x float64) float64 &#123;\tz := float64(1)\ttime := 1\tfor time&lt;=10&#123;\t\tz-=(z*z-x)/(2*z)\t\tfmt.Println(z)\t\ttime++\t&#125;\treturn z&#125;func main() &#123;\tfmt.Println(Sqrt(14))\tfmt.Println(&quot;Here is the currect answer:&quot;)\tfmt.Println(math.Sqrt(14))&#125;\n\n\n\n","categories":["语言"],"tags":["GoLang"]},{"title":"Maven","url":"/maven/","content":"Maven写在前面（一些注意事项）新建maven项目的时候，需要选择maven版本，不要选择bundled Maven 3\n其次，把默认settings.xml，选择用D盘下的那个，仓库同理\nD盘，dev文件夹中的仓库，有H2J站长打包的jar包，虽然有点过时，但是可以拿来用。\n再者，XML文件中，注释形式不能用两个斜杠，否则会报错。（最好不用加注释，可以看的懂）\nXML文件中的注释，应该用HTML语言的注释格式（）\n每个项目都需要的，避免导出失败的语句\n开启资源过滤\n&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n\n\n1.什么是mavenMaven 是专门用于构建和管理Java相关项目的工具。\n主要用处：\n\n相同的项目结构\n\n有一个pom.xml 用于维护当前项目都用了哪些jar包\n所有的java代码都放在 src&#x2F;main&#x2F;java 下面\n所有的测试代码都放在src&#x2F;test&#x2F;java 下面\n\n\n统一维护jar包\n比如说有3个Java 项目，这些项目都不是maven风格。\n那么这3个项目，就会各自维护一套jar包。\n 而其中有些jar包是相同的。\n而maven风格的项目，首先把所有的jar包都放在”仓库“ 里，然后哪个项目需要用到这个jar包，只需要给出jar包的名称和版本号就行了。 这样jar包就实现了共享\n示例：\n\n\n注意：maven版本要配合jdk版本。\n2. maven仓库所谓的仓库就是用于存放项目需要的jar包的。\nmaven采用一个仓库，多个项目的方式，让多个项目共享一个仓库里的相同jar包。\n仓库的路径会在settings.xml中给出，现在在C:\\Users\\ASUS.m2\\repository这个位置（dev那个也是）\n现已更改jar下载保存路径到dev文件夹下，并一天假阿里云镜像下载链接。\n3. maven项目直接用IDEA集成maven的项目。（maven风格的Web项目同理）\n不必通过命令行窗口创建项目。\n创建：\n\n\n\n关于groupID、ArtifactID：\n​\t\t可将他们理解为坐标，一般对于groupID，要写清楚域名（com,cn,org等等），公司名，项目名。\n​\t\t对于ArtifactID，就可以简单视作项目名。\n​\t\t如果有多个项目，分出了父级子级，那么要在两个ID中声明层级——parent、（level）。\n项目创建后，IDEA还会做一些初始化工作，需要点击右下角的import changes.\n都完成之后,就会得到一个经典的maven项目,并且有一个附送的App.java类.\n4.给maven项目添加jar包：出现了需要额外jar包的类时，运行时会抛出异常。\n添加jar只需在pom.xml文件中添加相应的依赖，然后IDEA会提示需要导入新的jar包，选择导入即可。\n再次执行该类即可成功运行。\n复杂的导入（以上导入导致tomcat报错）：\nIDEA给maven导入jar包\n5.用maven建立web项目\n在新建项目界面左边选中Maven\n\n勾选Create from archetype\n\n选中 org.apache.maven.archetypes:maven-archetype-webapp\n\n填入group ID、ArtifactID(坐标)\n\n每次新建项目或者pom.xml发生改动，都会提示\n\n第一次选择“自动导入”，导入新的jar包选择“导入”\n\n新建Java源代码目录（如果框架没有给出代码目录的话）\n右键main目录-&gt; New-&gt;Directory-&gt;输入java-&gt;右键java-&gt;Mark Directory as-&gt; Sources Root这样就创建了存放java源文件的目录了\n\n添加servlet\n右键java-&gt;New-&gt;Servlet-&gt;HelloServlet\n\n修改web.xml（web项目要在web.xml中设置映射）\n添加对helloServlet的映射：\n&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n修改pom.xml，添加Servlet的jar包\n&lt;dependency&gt;     &lt;groupId&gt;javax.servlet&lt;/groupId&gt;     &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;     &lt;version&gt;3.1.0&lt;/version&gt;   &lt;/dependency&gt;\n\n配置tomcat，不多赘述，可以看tomcat笔记\n\n启动tomcat\n\n测试\n\n\n\n注：如果新建servlet时没有servlet的选项，可以去更新iml文件。\n\n\n6.父子聚合项目父子项目学习、测试\n通过 maven 可以创建父子-聚合项目。 所谓的父子项目，即有一个父项目，有多个子项目。\n这些子项目，在业务逻辑上，都归纳在这个父项目下，并且一般来说，都会有重复的jar包共享。\n所以常用的做法会把重复的 jar 包都放在父项目下进行依赖，那么子项目就无需再去依赖这些重复的 jar 包了。\n\n新建项目（父项目）（骨架用quickstart）\n\n修改pom.xml， 把原来的jar改为pom，这样才可以作为父项目。\n&lt;packaging&gt;pom&lt;/packaging&gt;\n\n增加 hutool jar 和 junit 包的依赖，用于后来子项目里观察对其的调用。\n&lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;cn.hutool&lt;/groupId&gt;      &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;      &lt;version&gt;4.3.1&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;\n\n创建子项目（骨架也要用quickstart）\n所谓的子项目，其实是maven module。\n右键点击 parentMavenProject-&gt;New-&gt;Module.（父项目的module）\n注意：group ID要和父项目相同，ArtifactID写明是子项目。\n\n测试父子依赖传递\n在 childMavenProject 下新建 TestHutool类，并运行。（上面父项目添加的依赖）\n如果可以使用hutool jar里面的类，则说明子项目可以使用父项目中的jar包。\t\n\n关于子项目中的pom.xml\n多出了一个标签，这个就是对父项目的依赖\n&lt;parent&gt;    &lt;artifactId&gt;parentMavenProject&lt;/artifactId&gt;    &lt;groupId&gt;cn.how2j&lt;/groupId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;\n\n关于父项目中的pom.xml\n多出了一个标签，表示对子项目的关联\n&lt;modules&gt;  &lt;module&gt;childMavenProject&lt;/module&gt;&lt;/modules&gt;\n\n项目结构\n文件夹中，childMavenProject 是位于 parentMavenProject下面的。\n同理，如果有childMavenProject1, childMavenProject2，也会在parentMavenProject下面。\n\n\n","categories":["框架"],"tags":["Maven"]},{"title":"Mybatis","url":"/mybatis/","content":"Mybatis1、简介1、1. 什么是Mybatis\nMyBatis 是一款优秀的持久层框架\nMyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程\nMyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。\nMyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。\n2013年11月迁移到Github .\nMybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html\nGitHub : https://github.com/mybatis/mybatis-3\n\n1、2. 持久化持久化是将程序数据在持久状态和瞬时状态间转换的机制。\n\n即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。\nJDBC就是一种持久化机制。文件IO也是一种持久化机制。\n在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。\n\n为什么需要持久化服务呢？那是由于内存本身的缺陷引起的\n\n内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。\n\n内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。\n\n\n1、3. 持久层什么是持久层？\n\n完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】\n大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。\n不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.\n与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】\n\n1、4. 为什么需要Mybatis\nMybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 .\n传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 .\nMyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) –&gt;对象关系映射\n所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别\nMyBatis的优点\n简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。\n灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。\n解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。\n提供xml标签，支持编写动态sql。\n……\n\n\n最重要的一点：使用的人多，公司需要。\n\n2、 第一个Mybatis程序2、1. 搭建环境搭建数据库\ncreate database `Mybatis`;use `Mybatis`;create TABLE `user`(`id` int(20) not null PRIMARY KEY,`name` VARCHAR(30) DEFAULT null,`pwd` VARCHAR(30) DEFAULT null)ENGINE = INNODB DEFAULT CHARSET = utf8;INSERT INTO `user`(`id`,`name`,`pwd`) VALUES(1,&#x27;linxu&#x27;,&#x27;123&#x27;),(2,&#x27;lin&#x27;,&#x27;234&#x27;),(3,&#x27;xu&#x27;,&#x27;456&#x27;)\n\n\n\n新建项目\n\n新建一个普通的maven项目\n删除src目录\n导入jar包(版本号可变)\n\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;3.8.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.4.5&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n\n2、2. 创建一个模块\n编写Mybatis的核心配置文件\n在idea面板右侧栏上有DataBase的选项，可以在那里配置数据库连接\n登陆（user：root，passw：lin1140144729——对象是本地数据库)\n在schemes中找到想要连接的数据库\n\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;lin1140144729&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n关于mapper注册：\n几种不同的注册mapper的方式\n\n编写Mybatis的工具类\npackage utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//工具类，sqlSessionFactory--&gt;sqlSessionpublic class mybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;    static&#123;        //从XML中构建SqlSessionFactory        try&#123;            //使用mybatis的第一步，获取sqlSessionFactory对象            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125;        catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。    //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。    public static SqlSession getSqlSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;\n\n2、3. 编写代码\n实体类\n需要有参、无参构造函数\nset&#x2F;get函数\ntoString函数\n\n\n\n\npackage pojo;//实体类public class user &#123;    private int id;    private String name;    private String pwd;    public user() &#123;    &#125;    public user(int id, String name, String pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPwd() &#123;        return pwd;    &#125;    public void setPwd(String pwd) &#123;        this.pwd = pwd;    &#125;    @Override    public String toString() &#123;        return &quot;user&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\nDao接口(Mapper接口类)\n\npackage dao;import pojo.user;import java.util.List;public interface userDao &#123;    List&lt;user&gt; getUserList();&#125;\n\n\n接口实现类(由于不再用JDBC式代码，改用XML文件，所以用Mapper.xml配置文件)\nnamespace十分重要，不能写错。\n\n&#x3D;&#x3D;从mybatis-config拷过来要记得改三个mapper出来。&#x3D;\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace= 绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;dao.userDao&quot;&gt;    &lt;!--查询语句，这个标签的作用等价于，写一个类，重写接口中的方法。--&gt;    &lt;!--id就是重写的方法名字，resultType就是返回类型(单个），resultMap（多个），返回类型要指明*域名*--&gt;    &lt;select id=&quot;getUserList&quot; resultType=&quot;pojo.user&quot;&gt;        select * from mybatis.user    &lt;/select&gt;&lt;/mapper&gt;\n\n\n\n2、4. 测试\n用junit测试\n测试的时候在maven自带的test文件夹下进行，需要把test的结构弄得和main一样。\n\n\n利用前面写的接口，获取mapper用mapper的函数获取对象\n尝试输出对象，正确输出则无问题，否则代码有错需要修改。\n\n2、5.  总结（自）对于一个mybatis程序，开发步骤大概如下：\n\n先写工具类（utils），建立maybatis核心——sqlSessionFactory。\n工具类的运行需要有mybatis-config.xml，所以需要在resources下配置这个文件。\n确定我们的pojo对象（编写pojo对象类）。\n写接口，用以运行业务，处理数据。\n针对接口，要有mapper.xml（需要在核心配置文件中注册mapper）\n在pom.xml（如果是maven框架的话），添加标签下的路径获取方式。\n编写测试类，测试代码是否正常运行。\n\n2、6. 注意事项（自）写定后一般不需要再修改的类：\n\npojo类、工具类\n\n可能需要修改的地方：\n\n接口类：可能需要有新的方法加入\nmapper.xml：当新的方法加入，中就要有对应的新的语句加入\n核心配置文件：可能要注册新的mapper\n测试类：可能要测试更多的数据（方法）。\n\n2、7. 可能会遇到的问题（狂）\n配置文件没有注册\n绑定接口错误\n方法名不对\n返回类型不对\nMaven导出资源问题\n\n3、 CRUD增删改查\n编写接口（在接口类中，声明新的方法）\n编写mapper（在接口类对应的mapper.xml中写入方法对应的sql语句\n测试（在测试类中测试新增的接口）\n\n3、1.  namespacenamespace中的包名要和接口的包名一样。\n3、2. select查询语句（查）\n3、3. insert添加语句（增）\n3、4. update修改语句（改）\n3、5. delete删除语句（删）\n3、6.  总结（自）\n对应功能标签下的属性：\n\n\nid 就是对应接口的方法名\nresultType —— 返回值的类型\nparameterType —— 参数的类型\n\n\nsql语句中**取参数用#{}**，大括号内填入接口中创建方法时填的参数名，如：\n接口中：\n\n\nuser getUserById(int id);\n\n​\tmapper中：\n&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;org.study.pojo.user&quot;&gt;       select * from user where id = #&#123;id&#125;    &lt;/select&gt;\n\n\n其中，增删改都需要提交事务\nsqlSession.commit();\n\n3、7.  改错\n加载resources必须用路径的方式——即使用’&#x2F;‘分割，而不是使用点。\n报错以后，要从下往上找错误。\n\n3、8. 用Map传递参数\n在接口中，定义以map作为参数的方法。\n//使用Map，根据id查询用户user getUserId2(Map&lt;String,Object&gt; map);\n\n在mapper中，创建相应的sql语句。\n\n参数类型只用注明是map，sql语句中的参数可以随便写，到时候在test中对应即可。\n\n&lt;select id=&quot;getUserId2&quot; parameterType=&quot;map&quot; resultType=&quot;org.study.pojo.user&quot;&gt;    select * from user where id = #&#123;userID&#125; and name =#&#123;username&#125;&lt;/select&gt;\n\n在test类中，新建一个map对象，在里面存入刚刚在mapper的sql语句中写的参数及其对应的值。\n@Testpublic void getUserId2()&#123;    SqlSession sqlSession = mybatisUtils.getSqlSession();       userDao mapper = sqlSession.getMapper(userDao.class);    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;userID&quot;,1);          //对应上面代码块第二行的userID    map.put(&quot;username&quot;,&quot;linxu&quot;);  //对应上面代码块第二行的username    user id2 = mapper.getUserId2(map);    System.out.println(id2);       sqlSession.close();&#125;\n\n在表的词条众多，相当复杂的情况下，使用这种方法十分有效。\n\n\n3、9. 几种传参的的区别\nMap传参：直接在sql中取出Map的key\n对象传参：直接在sql中取对象的属性即可。\n只有一个基本的数据类型做参数，可以直接在sql中取（不写parameterType也可以）\n多个参数的时候，用Map或者注解。\n\n思考（拓展）怎么实现模糊查询？\n\n在test函数里面(java代码中），加入sql通配符\n\n\nmapper中：\n注意条件不能再用等号，而是要用like\n而且不用（不能？）写传参类型\n&lt;select id=&quot;getUserLi&quot; resultType=&quot;org.study.pojo.user&quot;&gt;    select * from user where name like #&#123;xing&#125;&lt;/select&gt;\n\ntest类：\n在传参中，加入通配符 % %\nuserDao mapper = sqlSession.getMapper(userDao.class);List&lt;user&gt; id = mapper.getUserLi(&quot;%李%&quot;);\n\n\n在sql语句中拼接通配符，会引起sql注入\n使用这种方法要注意限定传入内容的条件，以免用户传入什么奇怪的东西，导致数据库数据泄露\n//Test 类中String xing = &quot;李&quot;;List&lt;user&gt; userList = mapper.getUserLi2(xing);//mapper中&lt;select id = &quot;getUserLi2&quot;&gt;\tselect * from user where name like &quot;%&quot;#&#123;xing&#125;&quot;%&quot;&lt;/select&gt;\n\n4、 配置解析1、核心配置文件\nmybatis.config.xml\nMyBatis 的配置文件包含了影响 MyBatis 行为甚深的设置（settings）和属性（properties）信息。\n\n2、 环境配置（enviroments）\nMyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中\n\n尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一\n\n每个数据库对应一个 SqlSessionFactory 实例\n\n为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可\nSqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment);SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader, environment,properties);\n\n如果忽略了环境参数，那么默认环境将会被加载\nSqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader);SqlSessionFactory factory = sqlSessionFactoryBuilder.build(reader,properties);\n\n\n配置默认的环境id：default&#x3D;”development”\n\n每个环境的id：id&#x3D;”development”\n\n事务管理器的配置（比如:type&#x3D;”JDBC”）。（默认是JDBC，还有MANAGED类型）\n\n数据源的配置（比如:type&#x3D;”POOLED”）。（默认是POOLED,还有UNPOOLED、JNDI)\n\n\n注意点：\n\n如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。\n\n3、 属性（properties)属性都是可外部配置且可动态替换的\n可以通过properties属性来引用配置文件\n既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递\n\n编写一个配置文件db.properties（不能写引号包住）\ndriver = com.mysql.cj.jdbc.Driverurl =jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8username = rootpassword = lin1140144729\n\n读取配置文件\n&lt;properties resource=&quot;db.properties&quot;/&gt;\n\n用property子属性来确定值\n&lt;properties&gt;    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;&lt;/properties&gt;\n\n注意点：配置文件的优先级高于子属性\n4、类型别名（typeAliases）\n为 Java 类型设置一个短的名字\n\n用来减少类完全限定名的冗余\n\n设置别名的方法：\n\n为每个对象类分别设置别名\n&lt;typeAliases&gt;    &lt;typealies type=&quot;org.study.pojo.user&quot; alies=&quot;user&quot;/&gt;&lt;/typeAliases&gt;\n\n读取包，然后包内的对象类的别名，会自动转为类名，首字母小写（无注解情况下）\n\n有注解时，将会使用注解设置的别名。\n&lt;typeAliases&gt;    &lt;package name=&quot;org.study.pojo&quot;&lt;/typeAliases&gt;\n\n\n许多常见Java类型的别名：\n\n\n\n\n\n\n5、设置（settings）只需了解以下三个即可\n\n\n6、其他配置\ntypeHandles（类型处理器）\nobjectFactory（对象工厂）\nplugins插件\nmybatis-generate-core\nmybatis-plus\n通用mapper\n\n\n\n7、映射器（mappers）用于注册绑定mapper文件\n方式一：【推荐使用】用resource扫描注册\n&lt;mappers&gt;    &lt;mapper resource=&quot;org/study/dao/userMapper.xml&quot;/&gt;&lt;/mappers&gt;\n\n方式二：用接口类扫描注册\n&lt;mappers&gt;    &lt;mapper class=&quot;org.study.dao.userMapper&quot;/&gt;&lt;/mappers&gt;\n\n方式三：用包扫描注册\n&lt;mappers&gt;    &lt;package name=&quot;org.study.dao&quot;/&gt;&lt;/mappers&gt;\n\n注意点：\n\n对于方式二和方式三：\n接口类和其对应的mapper文件，必须在同一个包下。\n接口类和其对应的mapper文件，必须同名。\n\n\n\n8、生命周期和作用域\n作用域和生命周期类别是至关重要的\n错误的使用会导致非常严重的并发问题\n\nSqlSessionFactoryBuilder：\n\n一旦创建了 SqlSessionFactory，就不再需要它了\n最佳作用域是方法作用域（也就是局部方法变量）\n\nSqlSessionFactory:\n\n一旦被创建就应该在应用的运行期间一直存在(表示着对一个数据库的连接)\n最佳作用域是应用作用域。（全局作用域）\n\nSqlSession：\n\n每个sqlsssion可以视作一个对于数据库的请求（事务）\n每个线程都应该有它自己的 SqlSession 实例\nSqlSession 的实例不是线程安全的，因此是不能被共享的\n最佳的作用域是请求或方法作用域（写在一个方法里。）\n用完之后要关闭\n\n其他注意点：\n\n一个bulider可以创建多个工厂。（存疑）\n一个工厂可以创建多个session。\n一个session可以创建多个mapper。\n\n5、解决属性名和字段名不一致的问题1、问题当新建pojo类时，变量名和数据库中的字段不一致时，将会无法匹配字段和变量\n解决方法:\n\n在sql语句中给字段起别名（变量名）\n用resultMap\n\n2、resultMap使用（简单）结果集映射数据库字段和对象属性\n &lt;!--结果集映射 id就是这个映射集的名字 type是这个映射集对应的数据库的表的类型--&gt;&lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;        &lt;!--column表示数据库中的列，也就是字段；而property表示对应的对象类的属性，即变量--&gt;        &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;    &lt;/resultMap&gt;        &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;userMap&quot;&gt;        select * from user where id = #&#123;id&#125;    &lt;/select&gt;\n\n\nresult Map是Mybatis中最重要最强大的元素\n\nresultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句，只需要描述他们的关系即可。\n\nresultMap最优秀的地方在于，虽然你已经对他相当了解了，但是根本就不需要显式的用到他们。\n\n\n6、 日志1、 日志工厂如果一个数据库操作，出现了异常，我们需要排错，日志就是最好地选择。\n以前：sout、debug\n现在：日志工厂。\n\n\n指定 MyBatis 所用日志的具体实现，未指定时将自动查找。\nSLF4\nLOG4J【掌握】\nLOG4J2\nJDK_LOGGING\nCOMMONS_LOGGING\nSTDOUT_LOGGING【掌握】\nNO_LOGGING\n\n在Mybatis中具体使用哪个日志实现，在设置中设定。\nSTDOUT_LOGGING 标准日志输出\n在mybatis核心配置文件中，配置我们的日志。\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;\n\n\n\n2、 LOG4J什么是LOG4J？\n\nLog4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至更多地方。\n我们可以控制每一条日志的输出格式\n通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程\n通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n\n先导入包(导入到子项目的pom里面)\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.17&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n\nlog4j.properties\nlog4j.rootLogger=DEBUG,console,file#set console outlog4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#set file outlog4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/lanyo.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#log out levellog4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG\n\n配置log4j的实现\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt;\n\n运行测试类，看看日志输出效果\n\n\n简单使用（例子）：\n\n导入包到测试类中\nimport org.apache.log4j.Logger;//一定得是apache的包\n\n创建一个logger对象（日志对象），参数为当前类的类名\nLogger logger = Logger.getLogger(userDaoTest.class); //类变量\n\n日志级别(不止下面三个，还有更多，需要用的话再自学)\nlogger.info(&quot;info:进入了log4j的info&quot;);  //可以等价于soutlogger.debug(&quot;info:进入了log4j的debug&quot;);logger.error(&quot;info:进入了log4j的error&quot;);\n\n7、分页为什么要分页？\n\n减少数据的处理量\n\n1、使用limit分页（sql语法）select * from user limit startIndex, pageSize;&lt;&lt;!下标的计算方式类似数组从零开始，size表示每页的大小&gt;&gt;select * from user limit n;   //表示从第一个到第n个\n\n\n\n2、使用mybatis分页\n接口文件，新增接口方法\n//分页查询List&lt;user&gt; getUserByLimit(Map&lt;String,Integer&gt; map);\n\nmapper文件，新增sql\n&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;userMap&quot;&gt;    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;/select&gt;\n\n在测试类传入参数，进行测试。\n@Testpublic void getUserByLimitTest()&#123;    SqlSession sqlSession = mybatisUtils.getSqlSession();    userMapper mapper = sqlSession.getMapper(userMapper.class);    HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();    map.put(&quot;startIndex&quot;,4);//起始下标    map.put(&quot;pageSize&quot;,2);//每一页的大小    List&lt;user&gt; list = mapper.getUserByLimit(map);    for (user user : list) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n3、使用RowBounds分页不依靠sql实现分页，而是直接用Java代码实现分页。\n\n接口类\n//分页查询-RowBoundsList&lt;user&gt; getUserByRow();\n\nmapper.xml\n&lt;select id=&quot;getUserByRow&quot; resultMap=&quot;userMap&quot;&gt;    select * from user&lt;/select&gt;\n\n测试\n@Testpublic void getUserByRowTest()&#123;    SqlSession sqlSession = mybatisUtils.getSqlSession();    //两个参数，offset表示开始下标，limit表示每一页的大小    RowBounds rowBounds = new RowBounds(4, 2);    List&lt;user&gt; list = sqlSession.selectList(&quot;org.study.dao.userMapper.getUserByRow&quot;, null, rowBounds);    for (user user : list) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n4、分页插件pageHelper，了解即可，以后工作可能要用。\n8、 使用注解开发1、 接口实现注解\n@Select(&quot;select * from user&quot;)List&lt;user&gt; getUserTest();\n\n2、在核心配置文件中注册\n&lt;mappers&gt;    &lt;mapper class=&quot;org.study.dao.userMapper&quot;/&gt;&lt;/mappers&gt;\n\n3、 测试\n@Testpublic void annoTest()&#123;    SqlSession sqlSession = mybatisUtils.getSqlSession();    userMapper mapper = sqlSession.getMapper(userMapper.class);    List&lt;user&gt; list = mapper.getUserTest();    for (user user : list) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n\n\n本质：**反射机制**实现\n底层：动态**代理**！\n2、CRUD在工具类中配置自动提交事务——AutoCommit，只需要写入一个参数true即可。\n1、 查询整个表\n@Select(&quot;select * from user&quot;)List&lt;user&gt; getUserTest();\n\nList&lt;user&gt; list = mapper.getUserTest();for (user user : list) &#123;    System.out.println(user);&#125;\n\n\n\n2、根据id查询表\n@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)user selectUser(@Param(&quot;id&quot;) int n);\n\nuser user = mapper.selectUser(1);System.out.println(user);\n\n\n\n3、向表中插入数据\n@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)void insertUser(user user);\n\nmapper.insertUser(new user(6,&quot;lhj&quot;,&quot;789&quot;));user user = mapper.selectUser(6);System.out.println(user);\n\n\n\n4、修改表中数据\n@Update(&quot;update user set name = #&#123;name&#125; where id = #&#123;id&#125;&quot;)void updateUser(@Param(&quot;id&quot;) int id,@Param(&quot;name&quot;) String name);\n\nmapper.updateUser(6,&quot;lihongjun&quot;);user user = mapper.selectUser(6);System.out.println(user);\n\n\n\n5、删除表中数据\n@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)void deleteUSer(@Param(&quot;id&quot;) int n);\n\nmapper.deleteUSer(6);\n\n【注意】记得在核心配置文件中注册mapper\n3、 @param()注解\n基本类型的参数或者String类型的，需要加上这个注解\n引用类型不需要加（参数是自定义类的对象不用加，也不会加）\n如果只有一个基本类型的参数的话，可以忽略，但是建议大家都加上\n在SQL中引用的就是我们这里@param（“”）中设定的属性名\n\n9、 Lombok是一个能够减少代码冗余的偷懒插件，可以自动生成部分代码使用步骤：\n\n先在idea中下载该插件（idea已经自带）\n\n导入jar包 \n&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.16.18&lt;/version&gt;&lt;/dependency&gt;\n\n使用（这三个注解就得到了当初的一堆方法）\n@Data@AllArgsConstructor@NoArgsConstructorpublic class user &#123;    private int id;    private String name;    private String password;&#125;\n\n虽然可以偷懒，省去一定（不多）时间，但是也会影响这门语言对开发者的印象。\n但是idea都自带了，不用白不用。\n10、多对一处理\n多对一，关联\n一对多，集合\n\n1、引入新的sqlCREATE TABLE `teacher` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1,&quot;林老师&quot;);CREATE TABLE `student` (  `id` INT(10) NOT NULL,  `name` VARCHAR(30) DEFAULT NULL,  `tid` INT(10) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `fktid` (`tid`),  CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (1, &quot;小明&quot;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (2, &quot;小红&quot;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (3, &quot;小张&quot;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (4, &quot;小李&quot;, 1); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (5, &quot;小王&quot;, 1);\n\n\n\n2、测试环境搭建\n新建实体类Teacher、Student\n新建Mapper接口\n新建Mapper.xml文件\n在核心配置文件中注册Mapper\n测试是否能够成功查询\n\n如何查询输出分别在两个表中的数据？\n3、按照查询嵌套处理类似sql中的子查询\n下面的写法有点问题，子查询的结果不太对\n&lt;select id=&quot;getStudent&quot; resultMap=&quot;stuAndTea&quot;&gt;    select * from student&lt;/select&gt;&lt;resultMap id=&quot;stuAndTea&quot; type=&quot;student&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;id&quot;/&gt;\t&lt;!--column等于id？--&gt;    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot; column=&quot;tid&quot; select=&quot;getTeach&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeach&quot; resultType=&quot;teacher&quot;&gt;    select name from teacher where id = #&#123;id&#125;&lt;/select&gt;\n\n\n\n4、按照结果嵌套查询&lt;!--按照结果嵌套查询--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;stuAndTea2&quot;&gt;    select s.id sid,s.name sname,t.name tname    from student s,teacher t    where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;stuAndTea2&quot; type=&quot;student&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;/association&gt;&lt;/resultMap&gt;\n\n\n\n11、一对多处理1、 环境更新@Datapublic class Student &#123;    private int id;    private String name;    private int tid;&#125;\n\n@Datapublic class Teacher &#123;    private int id;    private String name;    //该老师负责的学生    private List&lt;Student&gt; students;&#125;\n\n2、 针对结果嵌套查询【重sql，轻映射】\n&lt;!--按照结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;teacherMap&quot;&gt;    select s.id sid,s.name sname,t.id tid,t.name tname    from student s, teacher t    where s.tid = t.id and t.id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt;    &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;!--下面不能用javaType，而是要用oftype，表示集合里的泛型的类型--&gt;    &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;    &lt;/collection&gt;&lt;/resultMap&gt;\n\n3、 针对查询嵌套查询【重映射，轻sql】\n&lt;!--按照查询嵌套查询--&gt;&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;teacherMap2&quot;&gt;    select * from teacher where id=#&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;teacherMap2&quot; type=&quot;teacher&quot;&gt;    &lt;!--要说明JavaType是ArrayList，并且说明oftype是student--&gt;    &lt;!--column是一对多的外键，要填入一的主键的列名--&gt;    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;student&quot; select=&quot;getStudent&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudent&quot; resultType=&quot;student&quot;&gt;    select * from student where tid = #&#123;tid&#125;&lt;/select&gt;\n\n\n\n4、 小结\n关联——association\t【多对一】\n集合——collection\t【一对多】\njavaType &amp; ofType\njavaType 用来指定实体类中的属性的类型\nofType 用来指定映射到List或者集合中的pojo类型，泛型中的约束类型。\n\n\n\n5、 注意点\n保证SQL的可读性\n注意一对多和多对一中的属性名和字段的问题。\n如果难以排除错误，可以使用Log4j日志。\n\n12、动态SQL什么是动态SQL？\n动态SQL指的是根据不同的查询条件，生成不同的sq语句。\n\nMybatis提供了可以被用在任意SQL映射语句中的强大的动态SQL语言得以省略拼接sql的繁杂工作。\n\n动态SQL元素和JSTL或基于类似XML的文本处理器相似。在Mybatis之前的版本中，有很多元素需要花时间了解。Mybatis3大大精简了元素种类，现在只需学习原阿里一般的元素便可。\n\nMybatis采用功能强大的基于OGNL的表达式来淘汰其他大部分元素。\n\n&#96;&#96;&#96;\n\nif\nchoose(when,otherwise)\ntrim(where,set)\nforeach### 1、搭建环境```sqlCREATE TABLE `blog`(`id` VARCHAR(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` VARCHAR(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` VARCHAR(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` DATETIME NOT NULL COMMENT &#x27;创建时间&#x27;,`views` INT(30) NOT NULL COMMENT &#x27;浏览量&#x27;)ENGINE=INNODB DEFAULT CHARSET=utf8\n\n\n\n创建一个基础工程\n\n导包\n\n编写配置文件\n【注意】\n只有用class方式导入mapper才能允许接口使用注解方式实现sql（仅限于简单的sql）。\n用resources方式导入mapper的话，sql必须写在xml配置中。\n\n编写实体类\n@Datapublic class blog &#123;    private String id;    private String title;    private String author;    private Date createTime;    private int views;&#125;\n\n编写Mapper以及Mapper.xml\n\n\n&lt;mapper namespace=&quot;org.study.dao.blogMapper&quot;&gt;    &lt;insert id=&quot;addBlog&quot; parameterType=&quot;org.study.pojo.blog&quot;&gt;        insert into blog(id,title,author,create_time,views)        values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;)    &lt;/insert&gt;&lt;/mapper&gt;\n\n\n\n2、IF语句&lt;select id=&quot;getBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog where 1=1    &lt;if test=&quot;title != null&quot;&gt;        and title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/select&gt;\n\n【注意】：基础的sql语句的where不能少，因为IF的拼接，是接在sql语句最后，如果没有where，那么拼接也就没有了意义。\n但是1&#x3D;1的存在是很不合时宜的，所以我们可以引入标签，将动态sql语句写在这个标签下，那么绝大多数情况下，mybatis会自动帮我们得出正确的where子句。\n3、choose语句搭配when、otherwise使用，相当于java的switch语句\n&lt;select id=&quot;getBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;choose&gt;            &lt;when test=&quot;title != null&quot;&gt;                title = #&#123;title&#125;            &lt;/when&gt;            &lt;when test=&quot;author != null&quot;&gt;                author = #&#123;author&#125;            &lt;/when&gt;            &lt;otherwise&gt;                views = #&#123;views&#125;/*凑字数语句，无意义，无测试*/            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;\n\n\n\n4、where标签自动拼接where子句。\n【注意】记得在拼接子句前面加上 and\n&lt;select id=&quot;getBlog&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;if test=&quot;title != null&quot;&gt;            and title = #&#123;title&#125;        &lt;/if&gt;        &lt;if test=&quot;author != null&quot;&gt;            and author = #&#123;author&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n\n\n5、set标签自动拼接set子句。\n【注意】记得在拼接子句后面加上逗号\n&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;    update blog    &lt;set&gt;        &lt;if test=&quot;title !=null&quot;&gt;            title = #&#123;title&#125;,        &lt;/if&gt;        &lt;if test=&quot;author != null&quot;&gt;            author = #&#123;author&#125;,        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;&lt;/update&gt;\n\n\n其实，where和set都可以划分到trim语句中，由trim标签实现这个两个标签的功能。\n\n6、SQL片段有的时候，我们可以将一些sql代码抽取出来，方便复用。\n\n使用SQL标签抽取公共部分\n&lt;sql id=&quot;judge_Title_Author&quot;&gt;    &lt;if test=&quot;title !=null&quot;&gt;        title = #&#123;title&#125;,    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        author = #&#123;author&#125;,    &lt;/if&gt;&lt;/sql&gt;\n\n在需要使用的地方使用引入即可。\n&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;    update blog    &lt;set&gt;        &lt;include refid=&quot;judge_Title_Author&quot;&gt;&lt;/include&gt;    &lt;/set&gt;    where id = #&#123;id&#125;&lt;/update&gt;\n\n注意事项：\n\n最好基于单表定义SQL片段（简单sql语句）\n不要存在where标签、set同理\n最好只有简单的if判断语句\n\n\n\n7、foreach用法：指定一个集合，表明集合项（item）、开始符（open）、结束符（close)、分隔符（separator）\n然后foreach会将集合中的元素，挨个读取，并且拼接成一个子句。\n允许在where、set等会出现多个元素并列的sql字段中出现。\n&lt;select id=&quot;queryBlogForEach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from blog    &lt;where&gt;        &lt;foreach collection=&quot;ids&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;or&quot; item=&quot;id&quot;&gt;            id = #&#123;id&#125;   //#取参是取的list中的item（别名id），赋值给要拼接的id。        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n如何传参？\n针对接口给定每次需要的map，map中包含要交给foreach的集合。\nHashMap map = new HashMap();List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();ids.add(1);ids.add(3);map.put(&quot;ids&quot;,ids);List&lt;blog&gt; blogs = mapper.queryBlogForEach(map);\n\n动态sql说白了还是在拼接sql，只不过是在sql语句中加入了逻辑语句\n8、模糊查询*bind标签\n用bind标签定义模糊查询的内容，在查询语句中拼接。\n&lt;select id = &quot;模糊查询&quot; paramterType = &quot;_int&quot; resultType = &quot;pojo&quot;&gt;\t&lt;bind id = &quot;_bindName&quot; value = &quot;%&quot; + paramter.getName() + &quot;%&quot;/&gt;    select * from table where name like #&#123;_bindName&#125;&lt;/select&gt;\n\n\n\n9、存储过程调用(procedure)*在sql增删改查标签加上statement属性\n存储过程在mysql中写定，然后在mapper中调用，这种形式保证了数据的安全性。\nmapper的调用形式：\n&lt;insert id = &quot;savePojoProcudure&quot; paramterType = &quot;pojo&quot; statement = &quot;CALLABLE&quot;&gt;    &lt;!--用call调用procedure--&gt;\t&#123;call _procedureName pojo(#&#123;shuxin1,mode in),#&#123;shuxing2,mode in&#125;,#&#123;shuxing3,mode in&#125;&#125;&lt;/insert&gt;\n\nmode的in、out表示是存入还是取出。\n13、事务管理事务：原子性的逻辑执行单元，由一步或者多步操作主城，要么都执行，要么全都不执行。\n","categories":["框架"],"tags":["mybatis"]},{"title":"Redis","url":"/redis/","content":"\n\nNoSQL引入从开发项目的角度看，技术可以分为三类：\n\n解决功能性问题：java、jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN\n解决功能性问题：Struts、Spring、SpringMVC、HIbernate、Mybatis\n解决性能问题：NoSQL、JAVA线程、Hadoop、Nginx、MQ、ElasticSearch\n\nredis就是一种典型的NoSQL技术\n项目的访问量增大以后，有两个问题需要解决：\n\nCPU及内存的压力\n数据库的IO压力\n\n采用集群&#x2F;分布式架构可以有效解决单体项目的问题，但是也会产生新的问题：\n比如Session，由于多服务器的存在，session如何存放才能让所有服务器都认识他就是一个问题\n可以采用：①存放在客户端cookie  （安全性无法保证）\n​\t\t\t\t\t②session复制   （数据冗余、空间浪费） \n​\t\t\t\t\t③使用NoSQL数据库存放用户信息（数据完全在内存中，不需要IO，速度也很快）\n当数据库中数据量很大时，为了优化性能，就可能用到**分库分表**的方法，但是这么做就会破坏一定的业务逻辑。\n  NoSQL数据库打破了传统数据库以业务逻辑为依据的存储模式。而针对不同数据结构类型改为以性能为最优先的存储方式\nNoSQL数据库可以直接作为缓存使用，可以提高读写速度，减少IO操作\n定义：NoSQL是Not only sql，泛指非关系型数据库。NoSQL不依赖业务逻辑方式存储，而以简单的Key-value方式进行存储。因此大大增加了数据库的扩展能力。\n\n不遵循SQL标准\n不支持ACID（事务的四大特性——原子性、一致性、隔离性、持久性，并不是不支持事务）\n远超于SQL的性能。\n\n适用的场景：\n\n对数据高并发的读写\n\n海量数据的读写\n\n对数据高可扩展性的\n\n\n不适用的场景：\n\n需要事务支持\n\n基于sql的结构化查询存储，处理复杂的关系，需要**即席查询**\n\n（用不着sql的和用了sql也不行的情况下，就考虑用NoSQL\n\n\n常见的NoSQL数据库：\nMemcache：\n\n很早就出现的NoSQL数据库\n数据都在内存中，一般不持久化（关机就没了）\n支持简单的key-value，支持类型单一\n一般作为缓存数据库辅助持久化数据库\n\nredis：\n\n几乎覆盖了memcache所有功能\n数据在内存中，支持持久化\n支持多种数据结构的存储\n一般作为缓存数据库辅助持久化数据库\n\nMongoDB：\n\n高性能、开源、模式自由的文档型数据库（类似JSON）\n\n数据都在内存中，如果内存不足，会把数据存放到硬盘中\n\nkey-value模式，对value提供了丰富的查询功能\n\n支持二进制数据以及大型对象\n\n\n行式数据库：将一行数据作为一个元素，方便查询，但是不方便统计\n列式数据库：将数据的属性作为数据结构进行存储，方便统计，但是不方便查询\nRedis特性：\n开源的key-value存储系统\nvalue支持：string   list   set   zset    hash\n操作都是原子性的（不论单个多个）\n支持各种不同方式的排序\n数据缓存在内存中\n会周期性的把更新的数据写入磁盘\n实现了主从同步\n\n场景：\n\n可以配合关系型数据库做高速缓存\n多样的数据结构存储数据\n\n优势\n性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。\n\n丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n\n原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n\n丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。\n\n\nRedis与其他key-value存储有什么不同？\nRedis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\nRedis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n\n安装github上有windows的迁移版本，但是没有最新的Redis6。可以参照这篇笔记来安装。\n目前本机上已经装配了**Redis 5.0.14**。\n一些注意事项：\n\n安装路径在D盘\n可以通过文件夹路径前面加上cmd进入命令行\n在使用redis客户端之前需要先启动服务器端——redis-server.exe（服务器端）\n同理，客户端是——redis-cli.exe。\n\n配置可以通过编写redis,windows.conf文件来修改配置或者通过命令：CONFIG set\nredis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;   ——实例redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE ——语法 简而言之就是 set 属性名  值\n\n\n\n常用参数：参数说明\n\nport\t端口号（默认6379）\n\nbind    主机号\n\ntimeout：   客户端闲置多久后关闭连接（设置为0则永不关闭）\n\nloglevel：日志级别，默认为notice，可选：debug、verbose、notice、warning\n\nlogfile：日志记录方式，默认stdout（标准输出），如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 &#x2F;dev&#x2F;null\n\ndatabases：设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id\n\ndbfilename：指定本地数据库文件名，默认值为 dump.rdb\n\nrequirepass：设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH  命令提供密码，默认关闭\n\nmaxclients：设置同一时间最大客户端连接数，默认无限制。Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息\n\n太多了要用再自己看\n\n\n在配置密码时，要把密码配的复杂一点，在公网访问 redis,  因为 redis 的处理速度非常快，所以如果你的密码比较简单，很容易就会通过暴力破解破解出密码\n守护进程守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。\n守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。\n从终端开始的进程会随着终端被关闭而被关闭，所以守护进程不能依附于终端。\n配置外网可访问由于 redis 采用的安全策略，默认会只准许本地访问。所以要开放所有端口号\n修改 redis 的配置文件，将所有 bind 信息全部屏蔽。\n# bind 192.168.1.100 10.0.0.1 # bind 192.168.1.8 # bind 127.0.0.1\n\n修改完成后，需要重新启动 redis 服务。\n修改 Linux 的防火墙(iptables)，开启你的 redis 服务端口，默认是 6379。\n详情\n（那既然是windows移植版本，就暂且不考虑这部分内容）\nRedis数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。\nstringstring 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。\nstring 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。\nstring 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。\n可以使用SET和GET命令来写入和读取键值对\nredis 127.0.0.1:6379&gt; SET runoob &quot;菜鸟教程&quot;\n\n可以通过**DEL key命令**，删除指定的键值对\nHashRedis hash 是一个键值(key&#x3D;&gt;value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\nredis 127.0.0.1:6379&gt; HMSET runoob field1 &quot;Hello&quot; field2 &quot;World&quot;&quot;OK&quot;redis 127.0.0.1:6379&gt; HGET runoob field1&quot;Hello&quot;redis 127.0.0.1:6379&gt; HGET runoob field2&quot;World&quot;\n\nHMSET命令来创建Hash，HGET来读取Hash\n每个 hash 可以存储 232 -1 键值对（40多亿）。\nListRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n添加元素使用命令：lpush，默认会将元素添加到头部，然后读取的时候也是先从头部开始读取。（有点像栈）\n\n相应的，从尾部开始添加元素用rpush\n添加元素会得到返回值，对应的是列表的**长度**\n\n读取元素：lrange，需要指定起始位置和结束位置（从0开始，也就是从左边开始）\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\nSet（集合）Redis 的 Set 是 string 类型（非键值对）的无序集合。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 **O(1)**。\n添加元素：\n\n使用sadd命令，可以一次性添加多个元素，会返回这次成功添加的元素的个数\n元素的顺序确实偏向于无序存储。\n不会向集合中添加重复的元素。（添加失败）\n\n集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。\n常用命令：\n\n\n\n命令\n说明\n\n\n\nsadd\n向set中添加元素\n\n\nscard\n返回set的大小\n\n\n\nzset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素（非键值对）的集合,且不允许重复的成员。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\nzset的成员是唯一的,但分数(score)却可以重复。\n添加元素：\n\nzadd命令\n\n在添加时需要给定元素的score，可以借此更改元素的score\n\n不允许有重复元素，但可以有重复分数\n\n通过zrangebyscore来查看所有数据\n\n\n应用场景\n\n\n类型\n简介\n特性\n场景\n\n\n\nString(字符串)\n二进制安全\n可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M\n—\n\n\nHash(字典)\n键值对集合,即编程语言中的Map类型\n适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)\n存储、读取、修改用户属性\n\n\nList(列表)\n链表(双向链表)\n增删快,提供了操作某一段元素的API\n1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列\n\n\nSet(集合)\n哈希表实现,元素不重复\n1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作\n1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐\n\n\nSorted Set(有序集合)\n将Set中的元素增加一个权重参数score,元素按score有序排列\n数据插入集合时,已经进行天然排序\n1、排行榜 2、带权重的消息队\n\n\n注意：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。\nRedis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。\n每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：\nredis&gt; SELECT 1OKredis [1] &gt; GET foo(nil)\n\n然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的Redis实例存储数据。由于Redis非常轻量级，一个空Redis实例占用的内存只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。\nredis命令测试是否正常连接到数据库：\n127.0.0.1:6379&gt; pingPONG\n\n\n\n远程连接：（服务器端命令行？）\n$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG\n\n\n\n基本数据类型键KeyRedis 键命令用于管理 redis 的键。\n基本语法：redis 127.0.0.1:6379&gt; COMMAND KEY_NAME\n与键相关基本命令：\n\ndel key——该命令用于在 key 存在时删除 key。\ndump key——序列化给定 key ，并返回被序列化的值。\nexist key——检查给定 key 是否存在。\nEXPIRE key seconds——为给定 key 设置过期时间，以秒计。\nEXPIREAT key timestamp——EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。\nPEXPIRE key milliseconds——设置 key 的过期时间以毫秒计。\nMOVE key db—— 将当前数据库的 key 移动到给定的数据库 db 当中\nPERSIST key——移除 key 的过期时间，key 将持久保持。\nRANDOMKEY—— 从当前数据库中随机返回一个 key 。\nRENAME key newkey——修改 key 的名称\nTYPE key ——返回 key 所储存的值的类型。\n\n好多命令都和过期时间有关，详见\n字符串string\n SET key value 设置指定 key 的值。\nGET key获取指定 key 的值。\n GETRANGE key start end 返回 key 中字符串值的子字符\nGETSET key value将给定 key 的值设为 value ，并返回 key 的旧值(old value)。\nMGET [key1 key2..] 获取所有(一个或多个)给定 key 的值。\n SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。\nSETNX key value只有在 key 不存在时设置 key 的值。\n STRLEN key 返回 key 所储存的字符串值的长度。\nMSET [key value key value …]同时设置一个或多个 key-value 对。\nMSETNX [key value key value …] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。\n INCR key 将 key 中储存的数字值增一。\nINCRBY key increment将 key 所储存的值加上给定的增量值（increment） 。\n INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。\n DECR key 将 key 中储存的数字值减一。\n DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。\nAPPEND key value如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。\n\n部分未列出详见\n哈希Hash对于hash，可以把key理解为map的名字\n把filed理解为map中键值对的键，value响应的就是键值对的值。\n\nhmset key 设置键     hget key 获得响应键的值\nHDEL key field1 [field2] 删除一个或多个哈希表字段\n HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。\n HGET key field 获取存储在哈希表中指定字段的值。\nHGETALL key获取在哈希表中指定 key 的所有字段和值\n HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。\n HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。\n HKEYS key 获取所有哈希表中的字段（不包括值）\nHLEN key获取哈希表中字段的数量\nHMGET key [field1 field2] 获取所有给定字段的值\nHMSET key [field1 value1 field2 value2 ]同时将多个 field-value (域-值)对设置（添加）到哈希表 key 中。\n HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。\n HSETNX key field value 只有在字段 field 不存在时，设置（添加）哈希表字段的值。\nHVALS key获取哈希表中所有值。\n[HSCAN key cursor MATCH pattern] [COUNT count]迭代哈希表中的键值对。\n\n列表list\nBLPOP key1[key2 ] timeout移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\n[BRPOP key1 key2 ] timeout移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\nBRPOPLPUSH source destination timeout从列表中弹出一个值，将弹出的元素左插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\nLINDEX key index通过索引获取列表中的元素\n\nLINSERT key BEFORE|AFTER pivot value在列表的元素前或者后插入元素\n\n LLEN key 获取列表长度\n\n LPOP key 移出并获取列表的第一个元素\n\n[ LPUSH key value1 value2] 将一个或多个值（左）插入到列表头部\n\nLPUSHX key value将一个值插入到已存在的列表头部（？）\n\n LRANGE key start stop 获取列表指定范围内的元素\n\n LREM key count value 移除列表元素（count？？？）\n\n LSET key index value 通过索引设置列表元素的值\n\nLTRIM key start stop对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。\n\n RPOP key 移除列表的最后一个元素，返回值为移除的元素。\n\nRPOPLPUSH source destination移除列表的最后一个元素，并将该元素添加到另一个列表并返回\n\n[ RPUSH key value1 value2] 在列表中（右）添加一个或多个值\n\n RPUSHX key value 为已存在的列表添加值\n\n\n集合Set\n[ SADD key member1 member2] 向集合添加一个或多个成员\nSCARD key获取集合的成员数\n[ SDIFF key1 key2] 返回第一个集合与其他集合之间的差异。\n[SDIFFSTORE destination key1 key2]返回给定所有集合的差集并存储在 destination 中\n[SINTER key1 key2]返回给定所有集合的交集\n[SINTERSTORE destination key1 key2]返回给定所有集合的交集并存储在 destination 中\n SISMEMBER key member 判断 member 元素是否是集合 key 的成员\n SMEMBERS key 返回集合中的所有成员\n SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合\n SPOP key 移除并返回集合中的一个随机元素\n[SRANDMEMBER key count]返回集合中一个或多个随机数(count???)\n[SREM key member1 member2]移除集合中一个或多个成员\n[ SUNION key1 key2] 返回所有给定集合的并集\n[ SUNIONSTORE destination key1 key2] 所有给定集合的并集存储在 destination 集合中\n[ SSCAN key cursor MATCH pattern] [COUNT count] 迭代集合中的元素\n\n有序集合zset\n[ ZADD key score1 member1 score2 member2] 向有序集合添加一个或多个成员，或更新已存在成员的分数\n\n ZCARD key 获取有序集合的成员数\n\nZCOUNT key min max计算在有序集合中指定区间分数的成员数\n\nZINCRBY key increment member有序集合中对指定成员的分数加上增量 increment\n\n[ZINTERSTORE destination numkeys key key …]计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中\n\nZLEXCOUNT key min max在有序集合中计算指定字典区间内成员数量（？）\n\n[ ZRANGE key start stop WITHSCORES] 通过索引区间返回有序集合指定区间内的成员\n\n[ZRANGEBYLEX key min max LIMIT offset count]通过字典区间返回有序集合的成员\n\n[ZRANGEBYSCORE key min max WITHSCORES] [LIMIT]通过分数返回有序集合指定区间内的成员\n\nZRANK key member返回有序集合中指定成员的索引\n\n[ZREM key member member …]移除有序集合中的一个或多个成员\n\nZREMRANGEBYLEX key min max移除有序集合中给定的字典区间的所有成员\n\nZREMRANGEBYRANK key start stop移除有序集合中给定的排名区间的所有成员\n\nZREMRANGEBYSCORE key min max移除有序集合中给定的分数区间的所有成员\n\n[ZREVRANGE key start stop WITHSCORES]返回有序集中指定区间内的成员，通过索引，分数从高到低\n\n[ZREVRANGEBYSCORE key max min WITHSCORES]返回有序集中指定分数区间内的成员，分数从高到低排序\n\nZREVRANK key member返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\n\nZSCORE key member返回有序集中，成员的分数值\n\n[ ZUNIONSTORE destination numkeys key key …] \n计算给定的一个或多个有序集的并集，并存储在新的 key 中\n\n[ZSCAN key cursor MATCH pattern] [COUNT count]迭代有序集合中的元素（包括元素成员和元素分值）\n\n\n注意：\n在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： \n添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 \n但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) \n其他的range操作复杂度一般为O(log(n))\n当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)\nHyperLogLogRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n什么是基数?比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。（distinct元素个数）\n常用命令\n[PFADD key element element …]添加指定元素到 HyperLogLog 中。\n[PFCOUNT key key …]返回给定 HyperLogLog 的基数估算值。（统计基数）\n[PFMERGE destkey sourcekey sourcekey …]将多个 HyperLogLog 合并为一个 HyperLogLog\n\n发布订阅Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。\nRedis 客户端可以订阅任意数量的频道。\n订阅者和频道的关系：\n\n当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\n\n实例：\n开启一个client，（创建并）连接到一个频道：\n\n\n再开启一个client，（连接并）向频道发送信息\n\n\n在第一个client中接收到消息\n\n\n\n常用命令\n[PSUBSCRIBE pattern pattern …]订阅一个或多个符合给定模式的频道。\n[PUBSUB subcommand argument [argument …]]查看订阅与发布系统状态。\nPUBLISH channel message将信息发送到指定的频道。\n[PUNSUBSCRIBE pattern [pattern …]]退订所有给定模式的频道。\n[SUBSCRIBE channel channel …]订阅给定的一个或多个频道的信息。\n[UNSUBSCRIBE channel [channel …]]指退订给定的频道。\n\n事务Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：\n\n批量操作在发送 EXEC 命令前被放入队列缓存。\n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。\n在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n\n一个事务从开始到执行会经历以下三个阶段：\n\n开始事务。\n命令入队。\n执行事务。\n\n示例\n以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令。\n单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。\n事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。（允许失败）\nRedis 官方文档对此给出的解释是：\n\nRedis 操作失败的原因只可能是语法错误或者错误的数据库类型操作，这些都是在开发层面能发现的问题不会进入到生产环境，因此不需要回滚。\nRedis 内部设计推崇简单和高性能，因此不需要回滚能力。\n\n常用命令\nDISCARD取消事务，放弃执行事务块内的所有命令。（使用位置同exec）\nEXEC执行所有事务块内的命令。\nMULTI标记一个事务块的开始。\n UNWATCH 取消 WATCH 命令对所有 key 的监视。\n[WATCH key key …]监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n\n脚本Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。\neval的基本语法：\nEVAL script **numkeys** key [key ...] arg [arg ...]\n\n\n\n示例\n注意：是keys和argv\n常用命令\n[EVAL script numkeys key key …] arg [arg …]执行 Lua 脚本。\n[EVALSHA sha1 numkeys key key …] arg [arg …]执行 Lua 脚本。\n[SCRIPT EXISTS script script …]查看指定的脚本是否已经被保存在缓存当中。\n SCRIPT FLUSH 从脚本缓存中移除所有脚本。\n SCRIPT KILL 杀死当前正在运行的 Lua 脚本。\nSCRIPT LOAD script将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。\n\n连接Redis 连接命令主要是用于连接 redis 服务。\n常用命令：\n\n AUTH password 验证密码是否正确\nECHO message打印字符串\nPING查看服务是否运行\nQUIT关闭当前连接\nSELECT index切换到指定的数据库\n\n服务器Redis 服务器命令主要是用于管理 redis 服务。\n常用命令：\n BGREWRITEAOF 异步执行一个 AOF（AppendOnly File） 文件重写操作\nBGSAVE在后台异步保存当前数据库的数据到磁盘\n[CLIENT KILL ip:port] [ID client-id]关闭客户端连接\n CLIENT LIST 获取连接到服务器的客户端连接列表\n CLIENT GETNAME 获取连接的名称\nCLIENT PAUSE timeout在指定时间内终止运行来自客户端的命令\nCLIENT SETNAME connection-name设置当前连接的名称\nCLUSTER SLOTS获取集群节点的映射数组\n COMMAND 获取 Redis 命令详情数组\nCOMMAND COUNT获取 Redis 命令总数\n COMMAND GETKEYS 获取给定命令的所有键\n TIME 返回当前服务器时间\n[COMMAND INFO command-name command-name …]获取指定 Redis 命令描述的数组\nCONFIG GET parameter获取指定配置参数的值\nCONFIG REWRITE对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写\n CONFIG SET parameter value 修改 redis 配置参数，无需重启\n CONFIG RESETSTAT 重置 INFO 命令中的某些统计数据\n DBSIZE 返回当前数据库的 key 的数量\nDEBUG OBJECT key获取 key 的调试信息\nDEBUG SEGFAULT让 Redis 服务崩溃？\n FLUSHALL 删除所有数据库的所有key\nFLUSHDB删除当前数据库的所有key\n[ INFO section] 获取 Redis 服务器的各种信息和统计数值\nLASTSAVE返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示\n MONITOR 实时打印出 Redis 服务器接收到的命令，调试用\nROLE返回主从实例所属的角色\n SAVE 同步保存数据到硬盘\n[SHUTDOWN NOSAVE] [SAVE]异步保存数据到硬盘，并关闭服务器\nSLAVEOF host port将当前服务器转变为指定服务器的从属服务器(slave server)\n[SLOWLOG subcommand argument]管理 redis 的慢日志\nSYNC用于复制功能(replication)的内部命令\n\nGEORedis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。\nRedis GEO 操作方法有：\n\ngeoadd：添加地理位置的坐标。\ngeopos：获取地理位置的坐标。\ngeodist：计算两个位置之间的距离。\ngeoradius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。\ngeoradiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。\ngeohash：返回一个或多个位置对象的 geohash 值。\n\ngeoaddgeoadd 用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。\ngeoadd 语法格式如下：\nGEOADD key longitude latitude member [longitude latitude member ...]\n\n示例：\nredis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;(integer) 2redis&gt; GEODIST Sicily Palermo Catania&quot;166274.1516&quot;redis&gt; GEORADIUS Sicily 15 37 100 km1) &quot;Catania&quot;redis&gt; GEORADIUS Sicily 15 37 200 km1) &quot;Palermo&quot;2) &quot;Catania&quot;redis&gt;\n\n\n\ngeoposgeopos 用于从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。\ngeopos 语法格式如下：\nGEOPOS key member [member ...]\n\n示例：\nredis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;(integer) 2redis&gt; GEOPOS Sicily Palermo Catania NonExisting1) 1) &quot;13.36138933897018433&quot;   2) &quot;38.11555639549629859&quot;2) 1) &quot;15.08726745843887329&quot;   2) &quot;37.50266842333162032&quot;3) (nil)redis&gt;\n\n\n\ngeodistgeodist 用于返回两个给定位置之间的距离。\ngeodist 语法格式如下：\nGEODIST key member1 member2 [m|km|ft|mi]\n\nmember1 member2 为两个地理位置。\n最后一个参数是距离单位：\n\nm ：米，默认单位。\nkm ：千米。\nmi ：英里。\nft ：英尺。\n\n示例:\nredis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;(integer) 2redis&gt; GEODIST Sicily Palermo Catania&quot;166274.1516&quot;redis&gt; GEODIST Sicily Palermo Catania km&quot;166.2742&quot;redis&gt; GEODIST Sicily Palermo Catania mi&quot;103.3182&quot;redis&gt; GEODIST Sicily Foo Bar(nil)redis&gt;\n\n\n\ngeoradius、georadiusbymembergeoradius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。\ngeoradiusbymember 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是由给定的位置元素决定的， 而不是使用经度和纬度来决定中心点。\ngeoradius 与 georadiusbymember 语法格式如下：\nGEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]\n\n\nWITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。\nWITHCOORD: 将位置元素的经度和纬度也一并返回。\nWITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。\nCOUNT 限定返回的记录数。\nASC: 查找结果根据距离从近到远排序。\nDESC: 查找结果根据从远到近排序。\n\ngeoradius示例：\nredis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;(integer) 2redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST1) 1) &quot;Palermo&quot;   2) &quot;190.4424&quot;2) 1) &quot;Catania&quot;   2) &quot;56.4413&quot;redis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD1) 1) &quot;Palermo&quot;   2) 1) &quot;13.36138933897018433&quot;      2) &quot;38.11555639549629859&quot;2) 1) &quot;Catania&quot;   2) 1) &quot;15.08726745843887329&quot;      2) &quot;37.50266842333162032&quot;redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD1) 1) &quot;Palermo&quot;   2) &quot;190.4424&quot;   3) 1) &quot;13.36138933897018433&quot;      2) &quot;38.11555639549629859&quot;2) 1) &quot;Catania&quot;   2) &quot;56.4413&quot;   3) 1) &quot;15.08726745843887329&quot;      2) &quot;37.50266842333162032&quot;redis&gt;\n\n\n\ngeoradiusbymember示例\nredis&gt; GEOADD Sicily 13.583333 37.316667 &quot;Agrigento&quot;(integer) 1redis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;(integer) 2redis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km1) &quot;Agrigento&quot;2) &quot;Palermo&quot;redis&gt;\n\n\n\ngeohash\nRedis GEO 使用 geohash 来保存地理位置的坐标。\n\ngeohash 用于获取一个或多个位置元素的 geohash 值。\n\ngeohash 语法格式如下：\n\n\nGEOHASH key member [member ...]\n\n\n\n示例：\nredis&gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;(integer) 2redis&gt; GEOHASH Sicily Palermo Catania1) &quot;sqc8b49rny0&quot;2) &quot;sqdtr74hyu0&quot;redis&gt;\n\n\n\nStreamRedis Stream 是 Redis 5.0 版本新增加的数据结构。\nRedis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。简单来说发布订阅 (pub&#x2F;sub) 可以分发消息，但无法记录历史消息。\n而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。\nRedis Stream 的结构如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容：\n\n每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。\n上图解析：\n\nConsumer Group ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。\nlast_delivered_id ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。\npending_ids ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。\n\n消息队列相关命令：\nXADD - 添加消息到末尾\nXTRIM - 对流进行修剪，限制长度\nXDEL - 删除消息\nXLEN - 获取流包含的元素数量，即消息长度\nXRANGE - 获取消息列表，会自动过滤已经删除的消息\nXREVRANGE - 反向获取消息列表，ID 从大到小\nXREAD - 以阻塞或非阻塞方式获取消息列表\n\n消费者组相关命令：\nXGROUP CREATE - 创建消费者组\nXREADGROUP GROUP - 读取消费者组中的消息\nXACK - 将消息标记为”已处理”\nXGROUP SETID - 为消费者组设置新的最后递送消息ID\nXGROUP DELCONSUMER - 删除消费者\nXGROUP DESTROY - 删除消费者组\nXPENDING - 显示待处理消息的相关信息\nXCLAIM - 转移消息的归属权\nXINFO - 查看流和消费者组的相关信息；\nXINFO GROUPS - 打印消费者组的信息；\nXINFO STREAM - 打印流信息\n\nXADD使用 XADD 向队列添加消息，如果指定的队列不存在，则创建一个队列，XADD 语法格式：\nXADD key ID field value [field value ...]\n\n\nkey ：队列名称，如果不存在就创建\nID ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。\nfield value ： 记录。\n\n示例：\nredis&gt; XADD mystream * name Sara surname OConnor&quot;1601372323627-0&quot;redis&gt; XADD mystream * field1 value1 field2 value2 field3 value3&quot;1601372323627-1&quot;redis&gt; XLEN mystream(integer) 2redis&gt; XRANGE mystream - +1) 1) &quot;1601372323627-0&quot;   2) 1) &quot;name&quot;      2) &quot;Sara&quot;      3) &quot;surname&quot;      4) &quot;OConnor&quot;2) 1) &quot;1601372323627-1&quot;   2) 1) &quot;field1&quot;      2) &quot;value1&quot;      3) &quot;field2&quot;      4) &quot;value2&quot;      5) &quot;field3&quot;      6) &quot;value3&quot;redis&gt;\n\n\n\nXTRIM使用 XTRIM 对流进行修剪，限制长度， 语法格式：\nXTRIM key MAXLEN [~] count\n\n\nkey ：队列名称\nMAXLEN ：长度\ncount ：数量\n\n示例：\n127.0.0.1:6379&gt; XADD mystream * field1 A field2 B field3 C field4 D&quot;1601372434568-0&quot;127.0.0.1:6379&gt; XTRIM mystream MAXLEN 2(integer) 0127.0.0.1:6379&gt; XRANGE mystream - +1) 1) &quot;1601372434568-0&quot;   2) 1) &quot;field1&quot;      2) &quot;A&quot;      3) &quot;field2&quot;      4) &quot;B&quot;      5) &quot;field3&quot;      6) &quot;C&quot;      7) &quot;field4&quot;      8) &quot;D&quot;127.0.0.1:6379&gt;\n\n\n\nXDEL使用 XDEL 删除消息，语法格式：\nXDEL key ID [ID ...]\n\n\nkey：队列名称\nID ：消息 ID\n\n示例：\n&gt; XADD mystream * a 11538561698944-0&gt; XADD mystream * b 21538561700640-0&gt; XADD mystream * c 31538561701744-0&gt; XDEL mystream 1538561700640-0(integer) 1127.0.0.1:6379&gt; XRANGE mystream - +1) 1) 1538561698944-0   2) 1) &quot;a&quot;      2) &quot;1&quot;2) 1) 1538561701744-0   2) 1) &quot;c&quot;      2) &quot;3&quot;\n\n\n\nXLEN使用 XLEN 获取流包含的元素数量，即消息长度，语法格式：\nXLEN key\n\n\nkey：队列名称\n\n示例：\nredis&gt; XADD mystream * item 1&quot;1601372563177-0&quot;redis&gt; XADD mystream * item 2&quot;1601372563178-0&quot;redis&gt; XADD mystream * item 3&quot;1601372563178-1&quot;redis&gt; XLEN mystream(integer) 3redis&gt;\n\n\n\nXRANGE使用 XRANGE 获取消息列表，会自动过滤已经删除的消息 ，语法格式：\nXRANGE key start end [COUNT count]\n\n\nkey ：队列名\nstart ：开始值， - 表示最小值\nend ：结束值， + 表示最大值\ncount ：数量\n\n示例：\nredis&gt; XADD writers * name Virginia surname Woolf&quot;1601372577811-0&quot;redis&gt; XADD writers * name Jane surname Austen&quot;1601372577811-1&quot;redis&gt; XADD writers * name Toni surname Morrison&quot;1601372577811-2&quot;redis&gt; XADD writers * name Agatha surname Christie&quot;1601372577812-0&quot;redis&gt; XADD writers * name Ngozi surname Adichie&quot;1601372577812-1&quot;redis&gt; XLEN writers(integer) 5redis&gt; XRANGE writers - + COUNT 21) 1) &quot;1601372577811-0&quot;   2) 1) &quot;name&quot;      2) &quot;Virginia&quot;      3) &quot;surname&quot;      4) &quot;Woolf&quot;2) 1) &quot;1601372577811-1&quot;   2) 1) &quot;name&quot;      2) &quot;Jane&quot;      3) &quot;surname&quot;      4) &quot;Austen&quot;redis&gt;\n\n\n\nXREVRANGE使用 XREVRANGE 获取消息列表，会自动过滤已经删除的消息 ，语法格式：\nXREVRANGE key end start [COUNT count]\n\n\nkey ：队列名\nend ：结束值， + 表示最大值\nstart ：开始值， - 表示最小值\ncount ：数量\n\n示例：\nredis&gt; XADD writers * name Virginia surname Woolf&quot;1601372731458-0&quot;redis&gt; XADD writers * name Jane surname Austen&quot;1601372731459-0&quot;redis&gt; XADD writers * name Toni surname Morrison&quot;1601372731459-1&quot;redis&gt; XADD writers * name Agatha surname Christie&quot;1601372731459-2&quot;redis&gt; XADD writers * name Ngozi surname Adichie&quot;1601372731459-3&quot;redis&gt; XLEN writers(integer) 5redis&gt; XREVRANGE writers + - COUNT 11) 1) &quot;1601372731459-3&quot;   2) 1) &quot;name&quot;      2) &quot;Ngozi&quot;      3) &quot;surname&quot;      4) &quot;Adichie&quot;redis&gt;\n\n\n\nXREAD使用 XREAD 以阻塞或非阻塞方式获取消息列表 ，语法格式：\nXREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]\n\n\ncount ：数量\nmilliseconds ：可选，阻塞毫秒数，没有设置就是非阻塞模式\nkey ：队列名\nid ：消息 ID\n\n示例：\n# 从 Stream 头部读取两条消息&gt; XREAD COUNT 2 STREAMS mystream writers 0-0 0-01) 1) &quot;mystream&quot;   2) 1) 1) 1526984818136-0         2) 1) &quot;duration&quot;            2) &quot;1532&quot;            3) &quot;event-id&quot;            4) &quot;5&quot;            5) &quot;user-id&quot;            6) &quot;7782813&quot;      2) 1) 1526999352406-0         2) 1) &quot;duration&quot;            2) &quot;812&quot;            3) &quot;event-id&quot;            4) &quot;9&quot;            5) &quot;user-id&quot;            6) &quot;388234&quot;2) 1) &quot;writers&quot;   2) 1) 1) 1526985676425-0         2) 1) &quot;name&quot;            2) &quot;Virginia&quot;            3) &quot;surname&quot;            4) &quot;Woolf&quot;      2) 1) 1526985685298-0         2) 1) &quot;name&quot;            2) &quot;Jane&quot;            3) &quot;surname&quot;            4) &quot;Austen&quot;\n\n\n\nXGROUP CREATE**使用 XGROUP CREATE 创建消费者组，语法格式：\nXGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]\n\n\nkey ：队列名称，如果不存在就创建\ngroupname ：组名。\n$ ： 表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。\n\n从头开始消费:\nXGROUP CREATE mystream consumer-group-name 0-0  \n\n从尾部开始消费:\nXGROUP CREATE mystream consumer-group-name $\n\n\n\nXREADGROUP GROUP**使用 XREADGROUP GROUP 读取消费组中的消息，语法格式：\nXREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]\n\n\ngroup ：消费组名\nconsumer ：消费者名。\ncount ： 读取数量。\nmilliseconds ： 阻塞毫秒数。\nkey ： 队列名。\nID ： 消息 ID。\n\nXREADGROUP GROUP consumer-group-name consumer-name COUNT 1 STREAMS mystream &gt;\n\n\n\nredis高级教程数据备份与恢复Redis SAVE 命令用于创建当前数据库的备份。\n该命令将在 redis 安装目录中创建dump.rdb文件。\n创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。\n如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，如下所示：\nredis 127.0.0.1:6379&gt; CONFIG GET dir1) &quot;dir&quot;2) &quot;/usr/local/redis/bin&quot;\n\n\n\n安全我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。\n设置密码：config set requirepass “**********”\n设置密码后客户端会要求登录才能操作数据库\n登录：AUTH “password”\n性能测试Redis 性能测试是通过同时执行多个命令实现的。\nredis-benchmark [option] [option value]\n\n注意：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令。\n有点麻烦，没有测试，详见\n客户端连接Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：\n\n首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。\n然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法\n然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送\n\n在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。\nmaxclients 的默认值是 10000，你也可以在redis-server –maxclients 100000 中对这个值进行修改。\n在服务启动时设置最大连接数为 100000：redis-server –maxclients 100000\n\n管道技术Redis是一种基于客户端-服务端模型以及请求&#x2F;响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：\n\n客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。\n服务端处理命令，并将结果返回给客户端。\n\nRedis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。\n管道技术最显著的优势是提高了 redis 服务的性能。\n详见\n分区分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。\n优势：\n\n通过利用多台计算机内存的和值，允许我们构造更大的数据库。\n通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。\n\n不足：\nredis的一些特性在分区方面表现的不是很好：\n\n涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。\n涉及多个key的redis事务不能使用。\n当使用分区时，数据处理较为复杂，比如你需要处理多个rdb&#x2F;aof文件，并且从多个实例和主机备份持久化文件。\n增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。\n\nRedis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。\n范围分区最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。\n比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。\n这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。\n哈希分表另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：\n\n用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。\n对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 &#x3D; 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。\n\nJava使用redis需要安装redis服务、Java的redis驱动（jar包）\n连接服务：\nJedis jedis = new Jedis(&quot;localhost&quot;);\n\n密码：\njedis.auth(&quot;password&quot;); \n\n设置字符串数据：\njedis.set(&quot;key&quot;, &quot;value&quot;);\n\n获取字符串数据：\njedis.get(&quot;key&quot;);\n\n\n\nRedis Java List(列表) 实例import java.util.List;import redis.clients.jedis.Jedis; public class RedisListJava &#123;    public static void main(String[] args) &#123;        //连接本地的 Redis 服务        Jedis jedis = new Jedis(&quot;localhost&quot;);        System.out.println(&quot;连接成功&quot;);        //存储数据到列表中        jedis.lpush(&quot;site-list&quot;, &quot;Runoob&quot;);        jedis.lpush(&quot;site-list&quot;, &quot;Google&quot;);        jedis.lpush(&quot;site-list&quot;, &quot;Taobao&quot;);        // 获取存储的数据并输出        List&lt;String&gt; list = jedis.lrange(&quot;site-list&quot;, 0 ,2);        for(int i=0; i&lt;list.size(); i++) &#123;            System.out.println(&quot;列表项为: &quot;+list.get(i));        &#125;    &#125;&#125;\n\n\n\nRedis Java Keys 实例import java.util.Iterator;import java.util.Set;import redis.clients.jedis.Jedis; public class RedisKeyJava &#123;    public static void main(String[] args) &#123;        //连接本地的 Redis 服务        Jedis jedis = new Jedis(&quot;localhost&quot;);        System.out.println(&quot;连接成功&quot;);         // 获取数据并输出        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);         Iterator&lt;String&gt; it=keys.iterator() ;           while(it.hasNext())&#123;               String key = it.next();               System.out.println(key);           &#125;    &#125;&#125;\n\n\n\n小总结在java中使用redis，通过jedis对象即可。\n调用的函数就相当于在client中的命令。\n显然在使用redis的时候，需要像使用mysql一样，在配置文件中配置相关的属性。\n","categories":["数据库"],"tags":["Redis"]},{"title":"Spring","url":"/spring/","content":"一、spring1、 简介\nspring ： 给行业带来了春天\n理念：使现有的技术更加容易使用，整合了现有的技术框架。\nSSH——Structs+Spring+Hibernate\nSSM——SpringMVC+Spring+Mybatis\n官网\n下载\nGithub\n\n2、优点\nspring是一个开源的免费框架（容器）\nspring是一个轻量级的、非入侵式的框架。\n控制反转（IOC）、面向切面编程（AOP）\n支持事务的处理，对框架整合的支持。\n\n总结一句话：*Spring就是一个轻量级的控制反转（IOC）和面向切面编程的框架*。\n3、组成​\t七大模块：\n\n4、拓展\nSpring boot \n\n一个快速开发的手脚架（精简了Spring中原有的繁杂配置）\n基于SpringBoot可以快速地开发单个微服务（理解为完整的功能模块）\n约定大于配置（遵循既定的规则填入东西即可）\n\n\nSpring Cloud\n\nSpring Cloud是基于Spring Boot实现的。\n\n建议路线：Spring     SpringMVC     Spring Boot     Spring Cloud\n\n\n5、IOC理论推导之前：\n程序的控制权在程序员手上，由程序员写的代码决定会有什么功能实现。\n\n接口层：\npublic interface userDao &#123;    void getUser();&#125;\n\n接口实现层\npublic class userDaoImpl implements userDao&#123;    @Override    public void getUser() &#123;        System.out.println(&quot;默认返回一个对象&quot;);    &#125;&#125;\n\n服务的接口层\npublic interface userService &#123;    void getUser();&#125;\n\n服务的实现层\npublic class userServiceImpl implements userService&#123;\t//得现有对应的代码才能实现用户的需求    private userDao userDao = new userDaoImpl();    @Override    public void getUser() &#123;        //服务层调用接口层来执行代码        userDao.getUser();    &#125;&#125;\n\n之后（控制权转移给用户）：\n\n给业务层添加一个set方法，让业务层能够接收参数，再通过这个参数相应地调用方法。\npublic void setUserDao(org.study.dao.userDao userDao) &#123;    this.userDao = userDao;&#125;\n\n在使用时，通过传递不同的参数，就可以调用不同的方法，得到想要的结果。\n（省略了几个其他的接口实现类，以下代码放在测试类中）\nuserService userService = new userServiceImpl();userService.setUserDao(new mysqlDaoImpl());userService.getUser();\n\n这种思想，从本质上解决了问题，我不用再去管理对象的创建了，系统的耦合性会大大降低，可以更加专注在业务的实现上。而且这只是IOC的原型。\n6、深入控制反转所谓控制反转，可以理解为：获得依赖对象的方式反转了。\n采用XML配置Bean的时候，Bean的定义和实现是分离的，而采用注解的方式可以把两者合为一体，Bean的定义直接以注解的形式定义在实现类中，，从而达到了零配置的目的。\n控制反转是一种通过XML或者注解，并通过第三方去生产或者获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入(Depende injection, DI).\n7、使用xml配置数据\n新建beans.xml，用容器来管理数据\n\n在原有的dao层、业务层基础上，对每个接口，都写为bean，交给spring管理。\n&lt;bean id=&quot;mysqlDaoImpl&quot; class=&quot;org.study.dao.mysqlDaoImpl&quot;/&gt;&lt;bean id=&quot;oracleDaoImpl&quot; class=&quot;org.study.dao.oracleDaoImpl&quot;/&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;org.study.services.userServiceImpl&quot;&gt;    &lt;property name=&quot;userDao&quot; ref=&quot;mysqlDaoImpl&quot;/&gt;&lt;/bean&gt;\n\n这样在需要用的时候，不用再通过new的方式获得对象\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);userServiceImpl userServiceImpl = (org.study.services.userServiceImpl) context.getBean(&quot;userServiceImpl&quot;);userServiceImpl.getUser();\n\n用上bean以后，对象由Spring来创建、管理、装配。\n\n\n8、IOC容器创建对象\n默认使用无参构造函数创建对象。\n\n也有用有参构造函数的方法。\n\n通过参数下标（参数过多时，可能搞错下标，有一定风险）\n&lt;bean id=&quot;user&quot; class=&quot;org.study.pojo.user&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;lanyo-index&quot;/&gt;&lt;/bean&gt;\n\n通过参数类型（当参数同类型时，不适用，局限性较大）\n&lt;bean id=&quot;user&quot; class=&quot;org.study.pojo.user&quot;&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;lanyo-type&quot;/&gt;&lt;/bean&gt;\n\n通过参数名（最推荐方法，因为参数不会重名）\n&lt;bean id=&quot;user&quot; class=&quot;org.study.pojo.user&quot;&gt;    &lt;constructor-arg name = &quot;name&quot; value=&quot;lanyo-name&quot;/&gt;&lt;/bean&gt;\n\n\n\n总结：在配置文件加载（得到context）的时候，容器中管理的（所有）对象就已经初始化了，因此可以在后面要用的时候直接调用。\n9、spring配置1、别名——alias通过alias标签，直接对bean一对一取别名。\n&lt;alias name=&quot;user&quot; alias=&quot;u&quot;/&gt;\n\n\n\n2、Bean的配置\nid——bean的唯一标识符（名字）\nclass——bean对应的对象的包名+类名\nname——可以给这个bean取（多个）别名，比alias牛逼。\nproperty——对应对象的属性\nvalue——对应的值\nconstruct-arg——构造函数的参数\n\n&lt;bean id=&quot;user&quot; class=&quot;org.study.pojo.user&quot; name=&quot;user2,USER&quot;&gt;    &lt;constructor-arg name = &quot;name&quot; value=&quot;lanyo-name&quot;/&gt;&lt;/bean&gt;\n\n\n\n3、Import一般用于团队开发，可以将多个配置文件，导入到一个总的配置文件。\n不同开发人员注册了不同的bean，可以将他们写出来的beans.xml合并到一个ApplicationContext.xml中，使用他们的bean中的对象。\n&lt;import resource=&quot;beansOne.xml&quot;/&gt;\n\n【注意】时，用总的context，取import其他的（子）bean。\n10、依赖注入10.1、构造器注入就是上面讲的，在bean中配置值。\n10.2、Set方式注入【重点】\n依赖注入：Set注入\n\n依赖——bean对象的创建，依赖于spring容器\n注入——bean对象中的所有属性，由spring容器来注入\n\n\n搭建一个稍微复杂的环境用于测试和学习。\n\n多种复杂类型（引用对象）\npublic class address &#123;    String dizhi;    public String getDizhi() &#123;        return dizhi;    &#125;    public void setDizhi(String dizhi) &#123;        this.dizhi = dizhi;    &#125;&#125;\n\n测试对象\npublic class student &#123;    private String name;    private String[] books;    private List&lt;String&gt; hobbies;    Map&lt;String,String&gt; card;    Set&lt;String&gt; games;    private String wife;    private Properties info;    private address address;    &#125;\n\nApplicationContext.xml\n&lt;bean id=&quot;student&quot; class=&quot;org.study.pojo.student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;lanyo&quot;/&gt;&lt;/bean&gt;\n\n测试类\n@Testpublic void StudentTest()&#123;    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;);    student student = (org.study.pojo.student) ctx.getBean(&quot;student&quot;);    System.out.println(student.getName());&#125;\n\n\nSet注入\n\n常量注入\n&lt;property name=&quot;name&quot; value=&quot;lanyo&quot;/&gt;\n\n引用（bean）注入     【需要先准备要引用的bean】\n&lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;\n\n数组注入\n&lt;property name=&quot;books&quot;&gt;    &lt;array&gt;        &lt;value&gt;金瓶梅&lt;/value&gt;        &lt;value&gt;少妇白洁&lt;/value&gt;        &lt;value&gt;红楼梦&lt;/value&gt;    &lt;/array&gt;&lt;/property&gt;\n\nMap注入\n&lt;property name=&quot;card&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;学生卡&quot; value=&quot;201913160628&quot;/&gt;        &lt;entry key=&quot;地铁卡&quot; value=&quot;subway0501&quot;/&gt;    &lt;/map&gt;&lt;/property&gt;\n\nSet注入\n&lt;property name=&quot;games&quot;&gt;    &lt;set&gt;        &lt;value&gt;Dead cells&lt;/value&gt;        &lt;value&gt;Dark soul&lt;/value&gt;        &lt;value&gt;DDnet&lt;/value&gt;    &lt;/set&gt;&lt;/property&gt;\n\nList注入\n&lt;property name=&quot;hobbies&quot;&gt;    &lt;list&gt;        &lt;value&gt;coding&lt;/value&gt;        &lt;value&gt;sleeping&lt;/value&gt;        &lt;value&gt;eating&lt;/value&gt;        &lt;value&gt;wife&lt;/value&gt;    &lt;/list&gt;&lt;/property&gt;\n\nproperties注入\n&lt;property name=&quot;info&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;身高&quot;&gt;178&lt;/prop&gt;        &lt;prop key=&quot;体重&quot;&gt;70KG&lt;/prop&gt;        &lt;prop key=&quot;牛牛&quot;&gt;18CM&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;\n\nnull注入（不是让其为空值）\n&lt;property name=&quot;wife&quot;&gt;    &lt;null/&gt;&lt;/property&gt;\n\n\n\n10.3、拓展注入我们可以使用P命名空间和C命名空间实现注入。\n需引入xml约束：\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n\n【注意】用这两个的话，P需要无参构造函数，C需要有参构造函数\n10.4、Bean的作用域scope：singleton、prototype、request、session、application\n\n单例模式：（Spring默认的作用域）\n\n&lt;bean id=&quot;userP&quot; class=&quot;org.study.pojo.user&quot; p:name=&quot;lanyoP&quot; p:age=&quot;20&quot; scope=&quot;singleton&quot;/&gt;\n\n\n原型模式（每次用这个bean得到的对象都不一样。）\n&lt;bean id=&quot;userC&quot; class=&quot;org.study.pojo.user&quot; c:age=&quot;20&quot; c:name=&quot;lanyoC&quot; scope = &quot;prototype&quot;/&gt;\n\n其余三个在web开发中才会用到。\n\nrequest对应请求的作用域\nsession对应一个session的作用域\napplication对应的是全局的作用域。\n\n\n\n11、自动装配\n自动装配是使用spring满足bean依赖的一种方法。\nspring会在应用上下文中为某个bean找到其依赖的bean。\n\n三种装配机制：\n\n在xml中显式配置\n在Java中显式配置\n隐式的bean发现机制和自动装配。【重点】\n\nspring的自动装配需要从两个角度来实现或者说是两个操作：\n\n组件扫描——spring会自动发现应用上下文中所创建的bean\n\n自动装配——spring自动满足bean自建的依赖，也就是我们说的IOC&#x2F;DI；\n（不推荐使用自动装配xml，而是使用注解。）\n\n\n11.1、ByName自动装配&lt;bean id=&quot;dog&quot; class=&quot;org.study.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;org.study.pojo.Cat&quot;/&gt;&lt;bean id=&quot;man&quot; class=&quot;org.study.pojo.man&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;lanyo&quot;/&gt;&lt;/bean&gt;\n\n\n\n11.2、ByType自动装配&lt;bean id=&quot;dog1&quot; class=&quot;org.study.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;org.study.pojo.Cat&quot;/&gt;&lt;bean id=&quot;man&quot; class=&quot;org.study.pojo.man&quot; autowire=&quot;byType&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;lanyo&quot;/&gt;&lt;/bean&gt;\n\n\n\n11.3、小结自动装配（狂）byname：需要保证所有bean的id唯一，并且与对象属性的set方法的名字一致。\nbytype：需要保证所有bean的class唯一，并且这个class要和属性的类型一致。\n11.4、使用注解自动装配使用Autowired注解前提：\n\n添加xml约束\nxmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;\n\n开启属性注解支持\n&lt;context:annotation-config/&gt;\n\n然后就可以给属性加上**@Autowired**注解，然后spring就会帮我们自动配置bean。\npublic class man &#123;    @Autowired    private Dog dog;    @Autowired    private Cat cat;    private  String name;&#125;\n\n【注意】\n\n这个注解会自动查看是满足byname还是bytype，如果name和type都不满足唯一性，那么需要和另一个注解——**@Qualifier（value&#x3D;“”）**一起使用，此时Autowired以byname的形式运行。\n有@Autowired的话，就可以省略set方法。\nAutowired优先使用ByType。\n\n【题外话】\n@Autowired有一个required属性，如果设置为false（默认为true），则说明对象可以为null。\n否则的话没对象必须有值，不能为null。\n使用@Resource注解@Resource要比Autowired更好用一点。\n它也可以做到，当有符合的名字时，优先使用名字符合的；当名字不符合，使用唯一符合的class的bean。\n还可以对其指定要获取的bean——@Resource（value&#x3D;“BeanName”）\n@Resourceprivate Dog dog;@Resourceprivate Cat cat;\n\n\n\n11.5、小结\n都是用来自动装配的，都可以放在属性字段上。\n@Auto wired优先使用ByType，要求这个对象必须存在。\n@Resource优先使用ByName，不行的话就ByType，如果都找不到，就会报错。（还可以指定）\n\n12、使用注解开发配置xml文件，让项目能够使用注解来开发。\n1、bean略\n2、属性如何注入\n在pojo类的上面，加上**@component注解，Spring就可以用component-scan扫描到**，并将其转为bean。\n\n在对象类的属性上，可以加上@Value注解，可以通过他对属性赋值。\n@Componentpublic class user &#123;    @Value(&quot;lanyo&quot;)    private String name;&#125;\n\n\n同时，如果属性有set方法，还可以把@value注解加在set函数上面。\n@Value(&quot;lanyo&quot;)public void setName(String name) &#123;    this.name = name;&#125;\n\n\n\n3、衍生的注解@Component有几个衍生注解，我们在web开发中，会按照MVC的三层架构分层。\n\ndao——@Repository\nservice——@Service\ncontroller——@Controller\n\n这四个注解的功能都是一样的，都是代表将某个类注册到Spring中，装配为bean。\n4、自动配置即**@Autowired、@Resource**。\n5、作用域@Scope，用法和在xml中一样。\n写在对象类的头上。\n@Component@Scope(&quot;protoType&quot;)public class user &#123;&#125;\n\n\n\n6、小结\nxml与注解：\n\nxml更加万能，适用于任何场合，维护起来简单方便。\n注解，不是自己的类无法使用，维护相对复杂\n\n\n最佳实践：\n\nxml用来管理bean\n\n注解只负责对属性的注入\n\n在使用的过程中，我们只需要注意让注解生效——即开启注解的支持即可。\n&lt;!--开启注解支持--&gt;&lt;context:annotation-config/&gt;&lt;!--扫描包内的注解--&gt;&lt;context:component-scan base-package=&quot;org.study.pojo&quot;/&gt;\n\n\n\n13、使用java的方式配置Spring不再使用spring的xml配置，全权交给java。\n1、准备pojo类需要赋值的属性记得用@Value注解对其赋值\n给这个pojo类加上**@Component注解**，说明这个类被spring接管了。（不加好像也没有影响？）\n2、准备一个配置类\n给其加上**@Configuration**注解。\n这个类的作用类似于xml配置文件，在这个类中注册bean。\n【注意】加上bean注解之后，就算pojo类没有加上@Component注解也可以正常运行。（存疑）\n另外，@Configuration注解本身也是有@Component注解组成的。\n还可以给配置类加上包扫描注解——**@ComponentScan**，然后配置类就可以到包内扫描bean。\n还可以像xml一样，导入其他配置——用**@Import**注解来实现\n\n@Configuration  //注册为配置类public class MyConfig &#123;    @Bean       //将pojo注册为bean，bean的id就是这个方法的方法名    user getUser()&#123;\t\t//返回值类型相当于bean标签的class属性        return new user();    &#125;&#125;\n\n\n\n3、测试\n获取config对象\n\n不同于之前xml配置，用CPX读取xml文件名的方式获取容器\n使用注解配置之后，用AnnotationConfigApplicationContext方法，直接获取配置类\n\nApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);\n\n获取bean对象\n这一步和之前用xml实现配置没有什么区别。\nuser user = context.getBean(&quot;getUser&quot;, org.study.pojo.user.class);\n\n14、代理模式1、静态代理角色分析\n抽象角色：一般使用接口或者抽象类来实现\npublic interface Rent &#123;    void rent();&#125;\n\n真实角色：被代理的角色\npublic class Host implements Rent&#123;    @Override    public void rent() &#123;        System.out.println(&quot;房东出租房子&quot;);    &#125;&#125;\n\n代理角色：代理真实角色，代理真实角色之后，我们一般会做一些附属操作\npublic class Proxy implements Rent&#123;    private Host host;//被代理的角色    public Proxy(Host host) &#123;        this.host = host;    &#125;    public Proxy() &#123;    &#125;    public Host getHost() &#123;        return host;    &#125;    public void setHost(Host host) &#123;        this.host = host;    &#125;    public void contract()&#123;        System.out.println(&quot;签合同&quot;);    &#125;    public void getFee()&#123;        System.out.println(&quot;收中介费&quot;);    &#125;    @Override    public void rent() &#123;        host.rent();        contract();        getFee();    &#125;&#125;\n\n客户：访问代理角色的人\nHost host = new Host();Proxy proxy = new Proxy(host);proxy.rent();\n\n优点\n可以使真实角色变得纯粹，不用实现一些公共的业务\n公共业务交给代理角色。实现了业务的分工\n公共业务改动时，方便管理。\n\n缺点每一个真实角色都会需要一个代理角色，代码量会翻倍，开发效率变低。（存疑）\n优化代理模式详见spring-08-proxy-demo02\n2、动态代理\n动态代理和静态代理的角色一样\n动态代理的代理类是动态生成的，不是我们写好的\n动态代理分为两大类：基于接口的动态代理、基于类的动态代理\n基于接口——JDK动态代理\n基于类——cglib\nJava字节码实现——javasist\n\n\n需要了解两个类\nProxy（代理）\nInvocationhandler（调用处理程序）\n\n\n优点：\n涵盖静态代理的所有好处\n同时提高了代码的复用性，减少了代码量\n一个动态代理实现的就是一个接口，一般就是对应的一类业务。\n一个动态代理类可以代理多个类，只要是实现了同一个接口即可（存疑）\n\n\n\n动态代理类的生成类//利用这个类来自动生成代理类public class ProxyInvocationHandler implements InvocationHandler &#123;    //被代理的接口    private Object target;    public void setTarget(Object target) &#123;        this.target = target;    &#125;    //生成并得到代理类    public Object getProxy()&#123;        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);    &#125;    //处理代理的实例，并将其返回(通过反射的方式)    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        //动态代理的本质就是反射        return method.invoke(target,args);    &#125;&#125;\n\n\n\n如何使用生成类得到动态代理类//首先要有个真实对象UserServiceImpl userService = new UserServiceImpl();//创建生成类的对象ProxyInvocationHandler pih = new ProxyInvocationHandler();//给生成类的对象提交真实对象pih.setTarget(userService);//生成类对象返回这个真实对象的代理UserService proxy = (UserService) pih.getProxy();\n\n\n\n“动态”的实质以前我们要得到proxy，靠的是写一个proxy类，实现真实对象（可能还有多的功能要实现）\n现在通过这个生成类，我们可以只传递真实对象作为接口，就能得到这个真实对象的代理角色。\n区别就是如何的得到这个proxy对象，编写proxy类——传递真实对象接口\n路人大佬对代理的动态生成类的详解动态代理其实挺简单。就两个类。生成代理类Proxy.newProxyInvocation(参数1.参数2，参数3)参数1：表名你要用那个类加载器去加载生成的代理类。（这个是JVM类加载的知识，可以去了解一下，挺简单）。参数2：说明你要生成的代理类的接口。参数3：实现了InvocationHandle的类，这个类只有一个方法需要你要实现它。invoke(Object proxy, Method method, Object【】 args) ｛这个方法第一个参数，是生成的代理类，目前没发现用处，不管它。第二个参数，是执行的方法(利用反射的原理，可以去看反射，也很简单。)第三个参数，是执行某方法需要的参数。第二个第三个参数解释执行的方法意思是：代理类不是要代理某个对象么，然后增强里面的方法么，指得就是这个方法，代理类会为几乎所有方法都增强，除非你在这里做判断。返回值，是执行这个方法所返回的值。然后你要去执行方法，就是用第二参数的invoke(obj,args);第一个参数是你要增强的对象。第二个是参数。object是你返回的类型Object object= method.invoke(obj,args);｝\n\n\n\n15、AOP插一嘴:IOC的核心是工厂模式\tAOP的核心是代理模式\n1、 什么是AOP在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n2、AOP在Spring中的应用提供声明式服务；\t允许用户自定义切面；即在不改变源码的条件下，增加新的功能。\n3、使用Spring实现AOP使用条件：\n需要导入一个jar包\n&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.8.RC1&lt;/version&gt;  &lt;!-- 版本号无所谓 --&gt;&lt;/dependency&gt;\n\n\n\n方式一:通过Spring的API接口实现使用AOP就免去配置实现代理模式等等繁杂操作\n配置了AOP之后,各种bean都会被配置代理对象,可以直接用来实现横切\n具体实现:\n\n准备Spring配置文件,加入aop支持.\nxmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;http://www.springframework.org/schema/aophttps://www.springframework.org/schema/aop/spring-aop.xsd\n\n准备新增功能（横切内容）\npublic class BeforeLog implements MethodBeforeAdvice &#123;    //method就是这个方法  objects是参数  o是对象    @Override    public void before(Method method, Object[] objects, Object o) throws Throwable \t   &#123;        //避免对象是个空指针        assert o != null;        System.out.println(o.getClass().getName()+&quot;执行了&quot;+method.getName()+&quot;方法&quot;);    &#125;&#125;public class AfterLog implements AfterReturningAdvice &#123;    //o是返回值   o1是对象    @Override    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;        //避免对象是个空指针        assert o1 != null;        System.out.println(o1.getClass().getName()+&quot;执行了&quot;+method.getName()+&quot;方法&quot;+&quot;，返回值是&quot;+o);    &#125;&#125;\n\n注册bean、切入点和切入内容\n关于切入点配置的execution\nexecution(修饰符  返回值  包名.类名&#x2F;接口名.方法名(参数列表))\n狂神省略了修饰符\n&lt;aop:config&gt;    &lt;!--方式一：使用Spring原生API实现横切--&gt;    &lt;!--确定切入点--&gt;    &lt;aop:pointcut id=&quot;point1&quot; expression=&quot;execution(* org.study.service.ServiceImpl.*(..))&quot;/&gt;    &lt;!--指定切入内容以及切入点，用配置的形式--&gt;    &lt;aop:advisor advice-ref=&quot;bLog&quot; pointcut-ref=&quot;point1&quot;/&gt;    &lt;aop:advisor advice-ref=&quot;aLog&quot; pointcut-ref=&quot;point1&quot;/&gt;&lt;/aop:config&gt;\n\n使用\n注意context获取到的bean其实是一个代理角色,需要设为接口类型\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//使用Spring原生AOP后，会自动生成代理模式，获取到的bean都是代理对象，所以类型要转为对应类所继承的接口Service serviceImpl = (Service) context.getBean(&quot;serviceImpl&quot;);serviceImpl.add();\n\n方式二:使用自定义类实现\n准备一个自定义类\n用于实现”通知”功能,即在原有基础上实现新的功能\npublic class Diy &#123;    public void before()&#123;        System.out.println(&quot;======执行方法前======&quot;);    &#125;    public void after()&#123;        System.out.println(&quot;======执行方法后======&quot;);    &#125;&#125;\n\n在Spring配置中配置切面\n&lt;!--方式二，使用自定义类实现--&gt;&lt;bean id=&quot;diy&quot; class=&quot;org.study.diy.Diy&quot;/&gt;&lt;aop:config&gt;    &lt;aop:aspect ref=&quot;diy&quot;&gt;        &lt;!--切入点--&gt;        &lt;aop:pointcut id=&quot;point2&quot; expression=&quot;execution(* org.study.service.ServiceImpl.*(..))&quot;/&gt;        &lt;!--如何切入--&gt;        &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point2&quot;/&gt;        &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point2&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n方式二相对方式一而言, 实现起来更加简单, 但是能力也有限.\n\n\n方式三:使用注解实现\n给增强类增加**@Aspect**注解，表示这个类用作切面。\n\n把增加类配置为bean（通过xml或者注解）\n&lt;aop:aspectj-autoproxy/&gt; &lt;!--开启注解支持--&gt;\t\t&lt;!--xml配置bean--&gt;&lt;bean id=&quot;annoAop&quot; class=&quot;org.study.diy.AnnotationAop&quot;/&gt;\t\t&lt;!--用注解配置bean--&gt;&lt;context:component-scan base-package=&quot;org.study&quot;/&gt;\n\n指定各个方法的作用位置（before、after、around），并加上注解\n注解要加上切入点作为参数\n@Component@Aspectpublic class AnnotationAop &#123;    @Before(&quot;execution(* org.study.service.ServiceImpl.*(..))&quot;)    public void before()&#123;        System.out.println(&quot;=====方法执行前=====&quot;);    &#125;    @After(&quot;execution(* org.study.service.ServiceImpl.*(..))&quot;)    public void after()&#123;        System.out.println(&quot;=====方法执行后=====&quot;);    &#125;    //在环绕增强中，给定一个proceedingJoinPoint参数，表示我们要获取处理切入的点    @Around(&quot;execution(* org.study.service.ServiceImpl.*(..))&quot;)    public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123;        System.out.println(&quot;开始&quot;);        Object proceed = joinPoint.proceed();//执行方法        System.out.println(&quot;结束&quot;);    &#125;\n\n16、 整合Mybatis1、环境准备\n导入jar包\njunit\nmybatis\nmysql\nspring\naop织入\nmybatis-spring\n\n\n编写配置文件\n准备mybatis的核心配置文件\n在整合spring之后，核心配置只需要配置别名和settings\n    &lt;typeAliases&gt;        &lt;package name=&quot;org.study.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--还可以在这里配置settings--&gt;&lt;!--    &lt;settings&gt;--&gt;&lt;!--        &lt;setting name=&quot;&quot; value=&quot;&quot;/&gt;--&gt;&lt;!--    &lt;/settings&gt;--&gt;\n\n准备applicatiContext.xml\n主context，只用来注册bean\n其他操作可以写道其他的配置文件中，通过import导入\n&lt;!--一个xml专门负责配置数据库连接和工厂模式以及sqlsession--&gt;&lt;import resource=&quot;database-context.xml&quot;/&gt;&lt;bean id=&quot;UserMapperImpl&quot; class=&quot;org.study.dao.UserMapperImpl&quot;&gt;    &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt;\n\n&lt;!--注册数据源，让工厂得以成功配置--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;lin1140144729&quot;/&gt;&lt;/bean&gt;&lt;!--注册SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;!--需要用到上面配置的数据源--&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;!--指定mybatis的配置文件路径，classpath--&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;mybatis-config.xml&quot;/&gt;    &lt;!--configuration中其他配置也可以在context中实现，比如mapper的注册--&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:org/study/dao/*.xml&quot;/&gt;&lt;/bean&gt;&lt;!--注册sqlSession，类型是SqlSessionTemplate--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;    &lt;!--Template中没有set方法 只能通过构造器注入--&gt;    &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n&#x3D;&#x3D;注册工厂和sqlSession的代码可以完全不变，套入到其他项目中&#x3D;&#x3D;\n\npojo实体类     mapper接口、mapper.xml、mapper实现类\n实现方法不变，只是要把mapper实现类注册为bean，通过调用bean 的方式，调用接口的方法。\n同时接口方法的实现用的是mapper.xml方式。\n\napplicationContext.xml\n&lt;bean id=&quot;UserMapperImpl&quot; class=&quot;org.study.dao.UserMapperImpl&quot;&gt;    &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt;\n\nmapper.xml\n&lt;mapper namespace=&quot;org.study.dao.UserMapper&quot;&gt;    &lt;select id=&quot;getUser&quot; resultType=&quot;user&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;\n\nmapperImpl.class\npublic class UserMapperImpl implements UserMapper&#123;\t//实现需要用到sqlSession，在spring中是sqlSessionTemplate，其实就是同一个东西    private SqlSessionTemplate sqlSession;\t//set方法，让spring可以对其注入    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;        this.sqlSession = sqlSession;    &#125;\t//通过sqlSession调用mapper.xml的sql语句，以实现这个方法。    @Override    public List&lt;User&gt; getUser() &#123;        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);        return userMapper.getUser();    &#125;&#125;\n\n测试类\n//获取spring这个contextApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//通过context获取mapperUserMapper userMapper = (UserMapper) context.getBean(&quot;UserMapperImpl&quot;);//通过mapper调用相应方法List&lt;User&gt; userList = userMapper.getUser();\n\n\n\n\n\n2、小总结步骤：\n\n编写数据源配置\nsqlSessionFactory\nsqlSessionTemplate\n需要给接口增加实现类（不同于mybatis）\n将实现类注入到spring中\n测试\n\n17、整合Mybatis方式二使用SqlSessionDaoSupport实现\n1、让实现类继承SqlSessionDaoSupport然后就可以直接通过getSqlSession（）方法得到一个sqlSession。\n建议把代码精简到一行，显得简洁又装逼。\npublic class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper&#123;    @Override    public List&lt;User&gt; getUser() &#123;        //getMapper直接去获得接口类即可        return getSqlSession().getMapper(UserMapper.class).getUser();    &#125;&#125;\n\n\n\n2、在spring中注入这个实现类参数要传递**一个工厂**，因为父类需要工厂来生成一个sqlSession\n&lt;bean id=&quot;UserMapper2&quot; class=&quot;org.study.dao.UserMapperImpl2&quot;&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n\n\n3、使用\n还是先获取context\n通过context获得实现类的bean\n然后就可以调用bean对应的mapper的sql语句，实现增删改查。\n\nApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserMapper userMapper = (UserMapper) context.getBean(&quot;UserMapper2&quot;);List&lt;User&gt; userList = userMapper.getUser();\n\n\n\n18、声明式事务1、回顾事务\n事务在项目开发过程中非常重要，涉及到数据的一致性的问题，不容马虎。\n事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。\n\n事务就是把一系列的动作当作一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。\n事务的四个属性：\n\n原子性\n事务由一系列动作组成，要么所有动作都完成了，要么所有动作都不起作用\n\n\n一致性\n一旦事务完成，就要被提交。数据和资源处于一种满足业务规则的一致性状态中。\n\n\n隔离性\n可能多个事务会同时处理相同的数据，因此每个事务都应该和其他事务隔离开，防止数据损坏。\n\n\n持久性\n事务一旦完成，无论系统发生什么错误，结果都不会受到影响，通常情况下事务的结果被写到持久化存储器中。\n\n\n\n2、Spring中的事务管理\n声明式事务：AOP（不改变源码）\n编程式事务：需要在代码中进行事物的管理——通过try、catch，事务回滚来实现。\n\n事务是为了保证CRUD操作的同时进行，不会影响数据的一致性。\n配置方式：\n\n配置事务管理器(固定配置,无法更改,无需更改)\n&lt;!--构造事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;!--需要用到数据源做参数--&gt;    &lt;constructor-arg ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;\n\n配置要切入的内容\n使用tx需要增加命名空间约束\n&lt;tx:advice id=&quot;interceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;insert&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;select&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\n配置切面\n&lt;aop:config&gt;    &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* org.study.dao.*.*(..))&quot;/&gt;    &lt;aop:advisor advice-ref=&quot;interceptor&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;&lt;/aop:config&gt;\n\n19、总结与回顾重点掌握：\n\n理解IOC、AOP思想\n自动装配bean\n通过xml注册bean\n通过注解**@Configuration、@Component-Scan**注册bean\n\n\n使用注解开发\n通过java来配置spring（不使用xml）\n静态代理、动态代理【最好掌握】\n事务管理\n\n","categories":["框架"],"tags":["spring"]},{"title":"SpringBoot学习","url":"/springboot%E5%AD%A6%E4%B9%A0/","content":"\n\n开发发展变迁：\nSpringBoot学习内容：\n\n汇总：\n什么是SpringBoot？​\t\tSpring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，**只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring* 的*解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。\n​\t\t简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。\n有哪些优点？\n\n为所有Spring开发者更快的入门\n开箱即用，提供各种默认配置来简化项目配置\n内嵌式容器简化Web项目\n没有冗余代码生成和XML配置的要求\n\n什么是微服务？\n微服务是一种分布式系统架构，按业务进行划分为独立的服务单元，解决单体系统的不足，同时也满足越来越复杂的业务需求。\n总结起来微服务就是将一个单体架构的应用按业务划分为一个个的独立运行的程序即服务，它们之间通过HTTP协议进行通信（也可以采用消息队列来通信，如RoocketMQ，Kafaka等），可以采用不同的编程语言，使用不同的存储技术，自动化部署（如Jenkins）减少人为控制，降低出错概率。服务数量越多，管理起来越复杂，因此采用集中化管理。例如Eureka，Zookeeper等都是比较常见的服务集中化管理框架。\n第一个SpringBoot程序环境：\n\njdk 1.8\nmaven 3.6.1\nSpringBoot 最新版\nIDEA\n\n依赖导入剔除\n\n要点：\n\n通过spring init（生成器）来创建一个springboot项目\n创建时导入spring-web依赖\n可以通过修改application的properties，修改端口号（server.port&#x3D;1111)\n可以在properties的同级下新建一个banner.txt，以此修改启动项目的banner（彩蛋）\n\n原理初探自动配置（自动装配*）pom.xml：\n\nspring-boot-dependencies ： 核心依赖在父工程中\n我们在引入一些SpringBoot的依赖的时候，不需要写版本号，就是因为父工程中有版本仓库。\n但是如果是没有在依赖管理中的包，在导入时就需要手动加上版本\n\n启动器：\n\n即spring-boot-starter\n不同的启动器就对应不同的启动场景（Web等）\n比如spring-boot-starter-web，会帮我们自动导入所有web环境相关的所有依赖\nSpringBoot将所有的功能场景都变成了启动器\n要使用什么功能，只需要找到对应的启动器即可。\n\n主程序：\n@SpringBootApplicationpublic class HelloSpringBootApplication &#123;    public static void main(String[] args) &#123;        //SpringApplication        SpringApplication.run(HelloSpringBootApplication.class, args);        //将SpringBoot应用启动    &#125;&#125;\n\n@SpringBootApplication：\n标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n这个注解的深层还有很多的注解——@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan等。\n@ComponentScan——自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中\n@SpringBootConfiguration——SpringBoot的配置类，标注在某个类上，表示这是一个SpringBoot的配置类；\n\n其内部还有\n@Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件\n@Component ，说明启动类本身也是Spring中的一个组件而已，负责启动应用！\n\n\n\n@EnableAutoConfiguration——开启自动配置功能\n\n深层注解\n\n@AutoConfigurationPackage ：自动配置包\n\n@import ：Spring底层注解@import ， 给容器中导入一个组件\n\n@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；\n\nAutoConfigurationImportSelector ：自动配置导入选择器\n​\t最底层其实是调用的SpringFactoriesLoader 类的静态方法——loadFactoryNames() ，最终在      \tspring.factories（自动配置的编写文件）中读取出对应的配置的设置。\n\n\n\n\n\n\n所以，自动配置真正实现是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n结论\n简而言之：\nSpringBoot所有自动配置都是在启动的时候扫描并加载spring.factories所有的自动加载配置类。但是不一定每一个自动加载配置类都会生效，要判断条件是否成立，只要导入了对应的starter，就有对应的启动器，有了启动器，自动装配才会生效，然后才能配置成功。\nSpringApplication.run方法该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\nSpringApplication这个类主要做了以下四件事情：\n\n推断应用的类型是普通的项目还是Web项目\n查找并加载所有可用初始化器 ， 设置到initializers属性中\n找出所有的应用程序监听器，设置到listeners属性中（获取上下文，处理bean）\n推断并设置main方法的定义类，找到运行的主类\n\n配置文件SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的\n\napplication.properties\t\t语法结构 ：key&#x3D;value\napplication.yml                     语法结构：key：空格 value\n\n配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；\nyaml概述：一种以数据作为中心，而不以标记语言为中心的标记语言。\n以前的配置文件大多使用xml，而yaml相对而言更加的简洁\n基础语法：\nyaml对于空格比较敏感，语法其实非常类似于JavaScript。\n其特殊、强大之处在于可以给实体类赋值。\n强大之处：yaml可以直接给属性编写一个对应的配置文件。给各个属性赋值。\nproperties同理，可以编写一个自定义的properties，然后在需要被复制的对象类，添加@PropertySource注解，让其读取指定的properties，并在对象类的各个属性上，通过@value注解，获取指定配置文件的参数来复赋值。\n拓展知识\n\nyaml还可以调用一些spring的ER表达式：\n\n其中，random.uuid表示可以生成一个uuid，random.int表示生成一个随机整型数，${person.hello:hello}表示获取yaml中person元素的hello属性，如果没有这个属性则采用默认值hello（冒号后面的东西）。\nyaml配置与properties配置的比较\n松散绑定：java程序中的驼峰命名，在yaml中可以由 ‘-‘ 来作为分割，yaml照样可以正确读取。而@Value不支持。\n所以，可以有以下结论：\n\n推荐使用yaml\n如果只需要获取配置文件中的某一个值，那么可以使用@Value\n如果是专门写了一个JavaBean来和配置文件映射，那么直接使用@ConfigurationProperties\n\nJSP303数据校验：使用@Validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。\n使用数据校验可以保证数据的正确性，常用的参数（注解）类型：\n\n（有些注释允许自定义报错信息内容，方便在检错的时候找到是哪里出了问题。）\n​\t\n配置文件的优先级配置文件可以在四个位置生效：（按优先级顺序排列）\n\nfile:.&#x2F;config&#x2F;\nfile:.&#x2F;\nclasspath:&#x2F;config&#x2F;\nclasspath:&#x2F;      （默认位置，也是优先级最低的位置）\n\n其中，file表示项目文件目录，classpath表示resources文件夹\n多环境配置Springboot在准备了多个环境下不同的配置文件时，可以选择激活想要的配置文件(只适用properties)\n这种方式要求多个配置文件遵循一个命名规范——application-name.properties&#x2F;yml\n在配置文件中，指定spring.profiles.active &#x3D; name(不同环境配置文件的名字)\n\n而对于yaml作配置文件的情况\nyaml配置文件，允许在一个配制文件中写入多种配置情况，相互之间以—作为分隔\n同时对于不同的配置情况可以对其命名，然后选择激活想要的配置\n\n但是其实还是推荐分开存放配置文件，类似properties那样子，否则项目不易管理\n\n\n同时在测试中发现，默认配置文件对其他配置文件的激活之前的配置也是会生效的\nSpringboot WEB开发通过打jar包得到webapp\n都说SpringBoot的自动装配，到底为我们配置了什么？能不能修改？能修改哪些？能不能扩展？\n\nxxxAutoConfiguration：向容器中自动装配组件\nxxxProperties：自动配置类，装配配置文件中自定义的内容\n\n需要解决的问题：\n\n导入静态资源\n定制首页\njsp，模板引擎Thymeleaf\n装配扩展SpringBoot（JSON等等）\n增删改查\n拦截器\n国际化\n\n静态资源静态资源可以存放在三个位置：\n\nresources&#x2F;public&#x2F;\t\t   （自己建文件夹）\nresources&#x2F;static&#x2F;            （默认）\nresources&#x2F;resources&#x2F;    （自己建文件夹）\n\n其中，优先级：resources &gt; static &gt; public\n然后可以通过，localhost:8080&#x2F;**的方式访问静态资源\n定制首页程序会自动搜索index.html作为web的首页，可以直接在上述三个文件夹中任意一个创建一个index.html作为首页\n一般选择static或者public\n网页的图标也可以自定义，但是没啥用，暂时不搞这个\n模板引擎使用thymeleaf只需要导入start依赖即可\n常用的thymeleaf命名空间：\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; \t\t\t\txmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;\t\t\t\txmlns:shiro=&quot;http://www.pollix.at/thymeleaf/shiro&quot;&gt;\n\n在页面内容中，就可以通过Thymeleaf来获取后台传输的数据，有点类似jsp的取值\n其中，Thymeleaf的语法格式有：\n\n使用任意的 th:attr 来替换Html中原生属性的值！\n\n\n表达式\n好复杂，建议要使用的时候再看官方文档\n\n\n使用bootstrap模板\n下载模板，html页面加到templates文件夹下，其他的样式等静态资源加到static文件夹下。\n关闭Thymeleaf的缓存，在HTML中加入Thymeleaf的命名空间，表达式那些不用管\n如果有表达式，那么在修改了context-path的情况下可以自动拼接。\n默认情况下，html中的css、js的路径就已经满足读取的要求了。\n所以最好还是将静态资源交给Thymeleaf接管。\n对于静态资源的读取，@{&#x2F;}即可，其中的&#x2F;就已经表示在&#x2F;static文件夹下了\n\n\n\n关于样式丢失的问题\n尝试自定义资源拦截器，对静态资源放行\n尝试用thymeleaf接管静态资源\n一般来说写好的路径是没问题的，不用再次修改（改多或者改少）\n\n装配扩展springmvc自定义视图解析器：（不怎么用）\n自定义一个视图解析类，将其交给SpringBoot，然后SpringBoot就会帮我们自动装配。\n只要是继承了ViewResolver的类，就可以作为一个视图解析器。\n同时自定义的视图解析器的类，需要@Configuration的注解，不可以加上@EnableViewResolver的注解\n@Configurationpublic class MyConfig &#123;    //实现了ViewResolver的类就可以作为视图解析器，交给SpringBoot来自动装配    @Bean    public ViewResolver MyViewResolver()&#123;        return new MyViewResolver();    &#125;    //自定义的视图解析器    public static class MyViewResolver implements ViewResolver&#123;        @Override        public View resolveViewName(String viewName, Locale locale) throws Exception &#123;            return null;        &#125;    &#125;&#125;\n\n\n\n还可以通过扩展视图跳转控制（器）来扩展视图解析器的功能：\n@Configurationpublic class MyWebMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        //向浏览器输入webmvc。会跳转到/test对应的页面        registry.addViewController(&quot;/webmvc&quot;).setViewName(&quot;test&quot;);    &#125;&#125;\n\n\n\n总结：\n在springboot中，可以通过自定义xxxConfiguration来扩展SpringBoot的配置。\n@EnableWebMvc注解会让webmvc自带的配置都失效，用户可以自己定义全新的完整的Configuration\n页面国际化\n配置i18n文件\n\n自定义一个localeResolver\n\n页面中需要传参语言类型，交给解析器（用th:href，和@{}表达式，括号传参）\n&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(lang=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/index.html(lang=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt;\n\n解析器会调用返回不同的i18n配置的页面内容（text）\n\n\n\n将resolver装配为Bean\n\n取值符号 #{}\n\n\n登录+拦截器将前端的账号密码信息发送到后端进行校验\n同时配置拦截器，避免用户不通过登录直接进入到需要登录的页面。\n自定义拦截器：\npublic class LoginHandlerInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //登陆成功以后，应该有用户的session        Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;);        if(loginUser==null)&#123;//没有登录            request.setAttribute(&quot;Not_login&quot;,&quot;没有权限，请先登录&quot;);            request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response);            return false;        &#125;        else&#123;            return true;        &#125;        //return HandlerInterceptor.super.preHandle(request, response, handler);    &#125;&#125;\n\n在登录校验中传递session信息\npublic String login(@RequestParam(&quot;name&quot;) String username,                    @RequestParam(&quot;pass&quot;) String password,                    HttpSession session,                    Model model)&#123;    System.out.println(&quot;收到了来自login页面的请求&quot;);//action没有问题    if(username != null &amp;&amp; password.equals(&quot;123456&quot;))&#123;        session.setAttribute(&quot;loginUser&quot;,username);        //可以成功跳转到DashBoard，想要跳转后域名上不带有账号密码，就要重定向，并且重定向的地址要和config中配置的完全一样        return &quot;redirect:/board.html&quot;;    &#125;\n\n在配置类中注册自定义的拦截器：\n//添加自定义登录拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123;\tregistry.addInterceptor(new LoginHandlerInterceptor())\t.addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;,&quot;/css/**&quot;,&quot;/js/**&quot;,&quot;/images/**&quot;);&#125;\n\n\n\n展示员工页面：\n提取公共页面\n\nth:fragment &#x3D; “sidebar”\nth:replace &#x3D; “~{commons&#x2F;commons::topbar}”\n如果要使用参数，可以直接使用（）传参，接受判断即可。\n\n\n列表循环展示\n\n添加员工\n\n按钮提交\n跳转到添加页面\n添加员工成功\n返回首页\n\n\nCRUD\n\n404\n\n把404页面拖到template文件夹下的error文件夹即可，spring会自动接管，将其改造为特殊的404页面\n其他错误页面同理（400、500）\n\n\n\n如何写一个完整的项目\n前端长什么样子、数据怎么展示\n设计数据库（难点）\n独立化前端，让其能够正常运行\n对接数据接口：json、对象（all in one)\n前后端联调\n\n要求：\n\n有一套自己熟悉的后台模板：工作必要，推荐x-admin \n前端界面：要能够自己通过前端框架，组合出来一个网站页面，内容：\nindex\nabout\nblog\npost\nuser\n\n\n让项目运行起来\n\n做一个完整的项目至少需要一个月时间。\n回顾环节\nspringboot是什么\n微服务\n能写Helloworld程序吗\n探究了源码、自动装配原理\n配置yaml\n多文档环境切换\n静态资源映射\nThymeleaf\nspringboot如何拓展MVC      通过javaConfig\n如何及修改springboot的默认配置   通过配置文件\n实现CRUD\n国际化\n拦截器\n定制首页、错误页\n\n后续\nJDBC\nMybatis\nDruid\nShiro    安全框架\nSpring Security    安全框架\n异步任务、邮件发送、定时任务\nSwagger   前后端文档交接\nDubbo + Zookeeper\n\n整合数据源JDBCspringboot整合JDBC\n\n配置数据源\nspring:  datasource:    username: root    password: lin1140144729    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver\n\n测试数据源（在项目自带的test文件中）\n@Testvoid contextLoads() throws SQLException &#123;    //查看一下默认的数据源    com.zaxxer.hikari.HikariDataSource    //System.out.println(dataSource.getClass());    //获得数据库链接   com.mysql.cj.jdbc.ConnectionImpl@67774e29    Connection connection = dataSource.getConnection();    System.out.println(connection);    connection.close();//打开连接后要记得关闭数据库连接&#125;\n\n使用\n\n注入jdbcTemplate\n\n可以直接写controller，写sql语句交给jdbcTemplate去执行\n\nspringboot会自动处理事务相关的东西。\n@GetMapping(&quot;/userList&quot;)public List&lt;Map&lt;String,Object&gt;&gt; userList()&#123;    String sql = &quot;select * from user&quot;;    return jdbcTemplate.queryForList(sql);&#125;@GetMapping(&quot;/updateUser/&#123;id&#125;&quot;)public String updateUser(@PathVariable(&quot;id&quot;) Integer id)&#123;\tString sql = &quot;update mybatis.user set name = ?, pwd = ? where id = &quot; + id;\t//封装name和pwd\tObject[] objects = new Object[2];\tobjects[0] = &quot;upd名字&quot;;\tobjects[1] = &quot;upd密码&quot;;\t//会自动帮我们**提交事务**\tjdbcTemplate.update(sql,objects);\treturn &quot;update user OK!&quot;;&#125;\n\n\n\nDruidDruid是阿里巴巴开源平台上的一个数据库连接池实现。结合CP30、DBCP、PROXOOL等DB池的优点，同时加入了日志监控。\nDruid可以很好的监控DB池连接和SQL的执行情况，天生就是针对监控而生的DB连接池。\nSpringboot2.0以上默认使用Hikari数据源，可以说Hikari和Druid都是当前JavaWeb上最优秀的数据源。\n\n导入Druid的依赖\nmaven仓库\n\n在配置文件中配置连接池类型\nspring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource\n\n测试连接池类型\n//com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-0&#125; closing ...System.out.println(dataSource.getClass());\n\n配置Druid的私有属性\n#SpringBoot默认是不注入这些的，需要自己绑定#druid数据源专有配置initialSize: 5minIdle: 5maxActive: 20maxWait: 60000timeBetweenEvictionRunsMillis: 60000minEvictableIdleTimeMillis: 300000validationQuery: SELECT 1 FROM DUALtestWhileIdle: truetestOnBorrow: falsetestOnReturn: falsepoolPreparedStatements: true#配置监控统计拦截的filters，stat：监控统计、log4j：日志记录、wall：防御sql注入#如果允许报错，java.lang.ClassNotFoundException: org.apache.Log4j.Properity#则导入log4j 依赖就行filters: stat,wall,log4jmaxPoolPreparedStatementPerConnectionSize: 20useGlobalDataSourceStat: trueconnectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n（其中的log4j的使用，需要导包，如果没有导包可能就无法运行）\nlog4j的包只能导入老版本，双ID都是log4j的，如果是core的或其他的会不行。（logger的问题？）\n\n编写一个Druid的配置类（@Configuration）\n\n配置Druid的数据源\n\n@Bean@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)public DataSource druidDataSource()&#123;    return new DruidDataSource();&#125;\n\n\n配置后台监控和资源过滤器\n\n//后台监控  相当于一个web.xml 可以配置东西//因为SpringBoot内置了servlet容器，所以没有web.xml，替代方法：配置一个ServletRegistrationBean，他是一个专门用来配置的类。@Beanpublic ServletRegistrationBean statViewServelt()&#123;    ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(),&quot;/druid/*&quot;);    //后台需要有人登录，配置的登录的账号密码    HashMap&lt;String, String&gt; initParameters = new HashMap&lt;&gt;();    //增加配置    //登录的key和value是固定的    initParameters.put(&quot;loginUsername&quot;, &quot;admin&quot;);\t//这两个参数不能改    initParameters.put(&quot;loginPassword&quot;, &quot;123456&quot;);    //允许谁可以访问    initParameters.put(&quot;allow&quot;,&quot;&quot;);         //v为空表示谁都可以    //禁止访问      initParameters.put(&quot;lanyo&quot;,&quot;IP地址&quot;);    //将配置信息以及初始化参数交给bean    bean.setInitParameters(initParameters);    return bean;&#125;//配置一个资源过滤器@Beanpublic FilterRegistrationBean webStatFilter()&#123;    FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;();    //设置web状态过滤器    bean.setFilter(new WebStatFilter());    //通过map记录配置参数    HashMap&lt;String, String&gt; initParameters = new HashMap&lt;&gt;();    initParameters.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);    //将配置的参数填入bean，并将bean返回    bean.setInitParameters(initParameters);    return bean;&#125;\n\nDruid的使用：\n\n在localhost路径下，进入&#x2F;Druid，再通过自己配置的账号密码登入，就可以看到Druid监控的各种信息。\n\n\n\n遇到的问题log4j的导包问题\nDruid的登录用户、密码配置问题\n后台监控、资源过滤的配置问题——创建bean的时候最好直接注明类型\nServletRegistrationBean&lt;==StatViewServlet==&gt;FilterRegistrationBean&lt;==Filter==&gt; \n\n\n\n整合mybatis 导入mybatis官方提供的整合包mybatis-spring-boot-starter\n\n导入包\nmybatis-spring-boot-starterspring-boot-starter-jdbcmysql-connector-java\n\n配置文件\n配置数据库环境\nspring:  datasource:    username: root    password: lin1140144729    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver\n\nmybatis配置\n#整合mybatismybatis:  type-aliases-package: com.example.springbootmybatis.pojo  mapper-locations: classpath:mybatis/mapper/*.xml\n\n编写sql（mapper.xml）\n\nservice层调dao层\n\ncontroller层调service层\n\n\nSpringSecurity开发项目，安全是一个首要因素，如果说项目基本架构都完成了再来追加安全管理，会很麻烦。\n因此在开发时，越早把安全搞定越好。\n导包需要导入启动器：spring-boot-starter-security\n如果需要和Thymeleaf整合使用的话m，还需要导入thymeleaf-extras-springsecurity5\n同时，在使用了Thymeleaf的页面使用springsecurity的话，还需要引入命名空间：\nxmlns:sec=&quot;http://www.thymeleaf.org/extras/spring-security&quot;\n\n\n\n使用配置一个SecurityConfig类，继承WebSecurityConfigurerAdapter类，并重写configure方法，以此来配置SpringSecurity的运行。\n注意，configure方法有三个重载，主要使用的是AuthenticationManagerBuilder auth授权管理重载、\nHttpSecurity http网络安全管理重载\nconfigure方法的代码使用的是链式编程。\n用户授权在AuthenticationManagerBuilder auth重载方法里实现。\n可以通过内存设置用户的权限，也可以通过数据库给用户授权\nauth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser(&quot;lanyo&quot;).password(new BCryptPasswordEncoder().encode(&quot;123&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;).and()\n\n通过.and()方法就可以一直往下配置用户授权。\n权限验证权限验证是给功能模块加上对于用户的权限的要求。\n在configure(HttpSecurity http)中实现。\nhttp.authorizeRequests()        .antMatchers(&quot;/&quot;).permitAll()        .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)        .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)        .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);\n\nantMatchers就是设置模块对应的href\nhasRole就是设置对于用户的权限的要求。\n开启注销注销后的跳转可能会被CSRF拦截，导致无法正常注销\n//开启注销功能，注销后跳到首页http.logout().logoutSuccessUrl(&quot;/&quot;);//可以清除cookie和关闭session，一般不会这么干// http.logout().deleteCookies(&quot;remove&quot;).invalidateHttpSession(true);\n\n\n\n登录页面SpringSecurity提供了默认的用户登录页面，但是也允许用户自定义登录页面，只要配置好路径就行\n//没有权限就会默认跳转到默认的登录页面。可以通过loginPage设置登录页面http.formLogin().loginPage(&quot;/toLogin&quot;);\n\n\n\n记住我//开启记住我功能  通过cookie实现，能够保存两个星期http.rememberMe().rememberMeParameter(&quot;在前端页面写定的记住我参数&quot;);\n\n同理，登录账号、账号密码的传参也可以在HTTP的重载方法中修改。\nCSRFSpringSecurity默认开启，会自动拦截绝大多数get请求，所以前端写的请求都要改为post，以免被拦截。\n也可以将其关闭\nhttp.csrf().disable();\n\n\n\nShiro简介\n导入依赖\n配置角色\nHelloWorld\n\nShiro有三大核心对象：subject、securityManager、realm\n即用户、管理用户、连接数\nSubject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；\n常用方法：\nSubject currentUser = SecurityUtils.getSubject()Session session = currentUser.getSession()currentUser.isAuthenticated()currentUser.getPrincipal()currentUser.hasRole(&quot;&quot;)currentUser.isPermitted(&quot;&quot;)currentUser.logout()\n\n\n\n整合到SpringBoot导包：&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;    &lt;version&gt;1.9.0&lt;/version&gt;&lt;/dependency&gt;\n\nshiro不属于spring生态，所以引入依赖的时候需要注明版本号\n配置shiro配置一个shiro的配置类\n\n创建realm对象\n\n//1  创建realm对象，需要自定义类。@Bean(name = &quot;userRealm&quot;)   //qualifier的默认指定就是根据方法名来的，所以这个name属性可以不写public UserRealm userRealm()&#123;    return new UserRealm();&#125;\n\n\n创建安全管理器（SecurityManager)\n\n//2  DefaultWebSecurityManager@Bean(name = &quot;securityManager&quot;)public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123;\tDefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\t//关联UserRealm\tsecurityManager.setRealm(userRealm);\treturn securityManager;&#125;\n\n\n创建shiro的过滤器工厂的bean(ShiroFilterFactoryBean)\n\n@Beanpublic ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123;    ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();    //设置安全管理器    bean.setSecurityManager(defaultWebSecurityManager);    //添加shiro的过滤器，实现拦截功能    /*        * anon：无需认证就可以访问的        * authc:必须认证了的才能访问        * user:必须拥有 记住我 功能才能用        * perms:拥有对某个资源的权限才能访问        * role：拥有某个角色权限才能访问        * */    LinkedHashMap&lt;String, String&gt; filterMap = new LinkedHashMap&lt;&gt;();    filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;);    filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;);    //也可以使用通配符设置上面两个过滤条件    //filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;);    bean.setFilterChainDefinitionMap(filterMap);    //将配置好的拦截要求，交给bean    //设置登录的请求    bean.setLoginUrl(&quot;/toLogin&quot;);    return bean;&#125;\n\n\n\n创建一个自定义Realm类来实现授权和认证\n创建UserRealm类，并继承AuthorizingRealm类\n重写其中的授权和认证方法。\n授权：\n@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;    System.out.println(&quot;执行了===&gt;授权doGetAuthorizationInfo&quot;);    return null;&#125;\n\n认证：\n@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;    System.out.println(&quot;执行了===&gt;认证doGetAuthenticationInfo&quot;);    UsernamePasswordToken userToken = (UsernamePasswordToken) authenticationToken;    User user = userService.queryUserByName(userToken.getUsername());    if(user==null)&#123;        return null; //当用户不存在时，抛出用户名不存在异常    &#125;    //加密方式默认是MD5   可以自定义改变加密方式，改为其他如  盐值加密MD5    //出于安全性考虑，密码认证由shiro来完成    return new SimpleAuthenticationInfo(&quot;&quot;,user.getPwd(),&quot;&quot;);&#125;\n\n\n\n总结\nshiro真正执行了授权和认证方法的代码在userRealm中\nconfig类配置网站对用户的身份验证等\nuserRealm类用来实现对用户进行授权认证等\n对用户的授权在config中设置未授权的跳转页面\nbean.setUnauthorizedUrl(&quot;/noAuthed&quot;);\n\n\n\n在UserRealm认证代码中，将principal传给授权代码\nreturn new SimpleAuthenticationInfo(user,user.getPwd(),&quot;&quot;);//第一个参数\n\n\n\n在UserRealm授权代码中，根据数据库中的用户权限，对用户授权\n//获取当前对象的信息Subject subject = SecurityUtils.getSubject();User user = (User) subject.getPrincipal();  //接受由认证代码传来的principalinfo.addStringPermission(user.getPerms());  //将数据库中写好的用户权限授予用户\n\n\n\n最后在config中设置相应的权限过滤即可。\n//根据权限拦截filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;);filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;);\n\n\n\n整合Thymeleaf\n导入包thymeleaf-extras-shiro\n\n在html文件中新增命名空间：\n\n\nxmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;\n\n\n在shiro配置类中开启方言\n\n//开启shiro方言，让shiro能在html中使用@Beanpublic ShiroDialect getShiroDialect()&#123;    return new ShiroDialect();&#125;\n\n然后就可以在html中使用shiro的函数。\nshiro的RememberMe\n配置rememberMeCookie\n\n@Beanpublic SimpleCookie rememberMeCookie()&#123;    SimpleCookie cookie = new SimpleCookie(&quot;rememberMe&quot;);    cookie.setMaxAge(24*60*60);    return cookie;&#125;\n\n\n\n\n配置cookieRememberMeManager\n\n@Beanpublic CookieRememberMeManager cookieRememberMeManager()&#123;    CookieRememberMeManager manager = new CookieRememberMeManager();    manager.setCookie(rememberMeCookie());//将上面配的方法拿过来，传参cookie    //设置cookie加密的密钥 建议每个项目都不一样 默认AES算法 密钥长度(128 256 512 位)    //manager.setCipherKey(Base64.decode(&quot;4AvVhmFLUs0KTA3Kprsdag==&quot;));    return manager;&#125;\n\n\n\n\n在SecurityManager中RememberMeManager\n\nsecurityManager.setRememberMeManager(cookieRememberMeManager());\n\n\n\n\n在页面中创建记住我按钮（form表单下）\n\n&lt;input type=&quot;checkbox&quot; name=&quot;rememberMe&quot;&gt;记住我\n\n其他详细参考文档\n注销系统的学习注销\n可以直接通过shiro的拦截器拦截”&#x2F;logout”请求，让其logout\nshiro的默认登出也会清理用户的session信息,并且也会清理掉 redis中缓存的用户 身份认证和 权限认证的相关信息\n//通过过滤器实现登出filterMap.put(&quot;/logout&quot;,&quot;logout&quot;);\n\n\n\n也可以自己配置一个Controller来实现登出\n@RequestMapping(&quot;/logout&quot;)public String logout(Model model)&#123;    Subject subject = SecurityUtils.getSubject();    subject.logout();    model.addAttribute(&quot;msg&quot;,&quot;已退出，请重新登录&quot;);    return &quot;login&quot;;&#125;\n\n\n\nSwagger学习目标：\n\n了解Swagger的作用和概念\n了解前后端分离\n在SpringBoot中继承Swagger\n\n简介前后端分离：\nVue + SpringBoot\n后端时代：前端只用管理静态页面：Html&#x3D;&#x3D;》后端。模板引擎JSP\n前后端分离时代：\n\n后端：Controller、Services、Dao\n\n前端：前端控制层、视图层\n\n前后端如何交互？&#x3D;&#x3D;》API\n\n前后端相对独立，低耦合\n\n前后端甚至可以部署在不同的服务器上\n\n\n问题：\n\n前后端集成联调，前后端人员无法及时协商\n\n解决方案：\n\n首先制定schema，实时更新最新的API，降低集成风险\n\n前后端分离：\n\n前端测试后端接口：postman\n后端提供接口，需要及时更新最新的消息及改动\n\n\nSwagger号称世界上最流行的API框架\n\nRestFul API文档在线自动生成工具&#x3D;&#x3D;&#x3D;》API文档与api定义同时更新\n\n直接运行，可以在线测试API接口（Controller、Pequestmapping）\n\n支持多种语言\n\n\n集成到SpringBoot核心是Docket\n\n导包\n3.0版本的swagger可以使用starter\n\n\n&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;\n\n\n在application.properties中配置\n\nspring.mvc.pathmatch.matching-strategy=ant_path_matcher\n\n\n编写swagger的配置文件\n\n（4. 不用在主启动类中加@EnableOpenAPI 也可以）\n@Configuration@EnableSwagger2     //开启swagger2public class SwaggerConfig &#123;&#125;\n\n\n\n配置swagger通过Docket返回swagger信息\n//通过swagger的Docket来配置swagger信息@Beanpublic Docket docket()&#123;    return new Docket(DocumentationType.OAS_30).apiInfo(apiInfo());&#125;\n\n\n\n通过ApiInfoBuilder来配置ApiInfo，交给Docket\npublic ApiInfo apiInfo()&#123;    ApiInfoBuilder infoBuilder = new ApiInfoBuilder();    infoBuilder.title(&quot;TestInfoBuilder&quot;);    infoBuilder.description(&quot;TestDescription&quot;);    infoBuilder.contact(new Contact(&quot;lanyo&quot;, \t\t\t\t&quot;https://www.baidu.com&quot;,&quot;1140144729@qq.com&quot;));    return infoBuilder.build();&#125;\n\n\n\n配置扫描接口@Beanpublic Docket docket()&#123;    return new Docket(DocumentationType.OAS_30)            .apiInfo(apiInfo())            .select()            //RequestHandlerSelectors，配置要扫描的接口的方式            //basePackage：指定要扫描的包            //withClassAnnotation：扫描类上的注解，参数是一个注解的反射对象            //withMethodAnnotation：扫描方法上的注解            .apis(RequestHandlerSelectors.basePackage(&quot;com.example.swagger.controller&quot;))//通过包扫描查询API            //.paths(PathSelectors.ant(&quot;/Doesnt want&quot;))//根据路径查询匹配的API            .build();&#125;\n\n\n\n配置是否启动Swagger\nDocket.enable(false);\n\n\n\n根据生产环境判断是否需要开启swagger\nproduct环境中一般不用swagger\nProfiles.of设置想要的环境\nenvironment.acceptsProfiles(profiles)  在环境中匹配有无想要的环境，有责返回true，否则返回false\n然后即可通过enable_swagger判断是否需要开启swagger。\npublic Docket docket(Environment environment)&#123;        Profiles profiles = Profiles.of(&quot;dev&quot;,&quot;pro&quot;);        boolean enable_swagger = environment.acceptsProfiles(profiles);\n\n\n\n配置API文档分组\nreturn new Docket(DocumentationType.OAS_30).groupName(&quot;lanyo&quot;)//给当前Docket设置组名，多分组可以通过实现多个Docket实例，来设置不同组名\n\n\n\n返回实体类的controller被扫描到后，实体类也能被识别到，就算实体类没有@Api相关注释来声明\n@Api(tag &#x3D; “”)可以作用于模块（controller、实体类）上\n@ApiOperation(“XXX”)作用于方法上 \n@ApiParam 可以作用在参数上\n@ApiModel 可以作用在实体类上\n总结：\n\n可以通过swagger给一些比较难理解的属性或者接口，增加注释信息\n\n接口文档实时更新\n\n可以在线测试接口\n\n是一个不错的工具\n\n\n任务异步任务新建一个多线程服务包（service.package)\n创建一个异步方法的异步类，加上@Service的注解(Async.class)\n在里面编写异步方法，方法上要加上@Async注解\n@Asyncpublic void hello()&#123;\ttry &#123;\t\tThread.sleep(3000);\t&#125;\tcatch (InterruptedException e) &#123;\t\te.printStackTrace();\t&#125;&#125;\n\n在主启动类上加上开启异步注解的功能——**@EnableAsync**\n在controller中调用异步方法，已经可以实现异步的效果。\n总结：\n\n编写异步方法（@Async）\n开启异步支持注解（@EnableAsync）\n调用异步方法\n\n定时任务需要用到两个注解：\n@EnableScheduling   写在主启动类上，表示启用定时任务功能@Scheduled(cron = &quot;0 0 0 24 4 ?&quot;)写在方法上，表示这个方法会在指定时间执行\n\n@Scheduiled注解的参数是一个cron表达式，六个参数分别代表：秒、分、时、日、月、周几\n网上有现成的cron表达式生成器\nScheduled方法应该写在Services里面。\n实例：\n@Scheduled(cron = &quot;0 16 16 * * ?&quot;)public void TestScheduled()&#123;    System.out.println(&quot;定时方法执行了&quot;);&#125;\n\n\n\n邮件发送导包：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n配置\n#配置使用Spring.mailspring.mail.username=1140144729@qq.comspring.mail.password=dxnwhlkoslujidaispring.mail.host=smtp.qq.com#开起加密验证spring.mail.properties.mail.smtl.sll.enable=true\n\n\n\n简单邮件示例：\n发送邮件都需要用到MailSender&#x3D;&#x3D;&#x3D;》JavaMailSenderImpl类\n@AutowiredJavaMailSenderImpl javaMailSender;//要先配置了上面的properties，否则这里会报错//发送一个***简单***的邮件@Testpublic void SendMail()&#123;    SimpleMailMessage message = new SimpleMailMessage();    message.setSubject(&quot;邮件标题测试&quot;);//标题    message.setText(&quot;邮件正文测试&quot;);//正文    message.setTo(&quot;1140144729@qq.com&quot;);//去向    message.setFrom(&quot;1140144729@qq.com&quot;);//来源    javaMailSender.send(message);//通过sneder发送&#125;\n\n\n\n复杂邮件实例：\n//发送一个复杂的邮件@Testpublic void SendComplexMail() throws MessagingException &#123;    MimeMessage message = javaMailSender.createMimeMessage();    //通过helper封装message,需要开启multiple来发送多样式文本、行内元素或者附件    MimeMessageHelper helper = new MimeMessageHelper(message,true);    //设置邮件正文    helper.setSubject(&quot;复杂邮件测试&quot;);    helper.setText(&quot;&lt;p style=&#x27;color:red&#x27;&gt;复杂邮件测试&lt;/p&gt;&quot;,true);    //没有true无法将html语句渲染出来    //helper.setText(&quot;&lt;p style=&#x27;color:red&#x27;&gt;复杂邮件测试&lt;/p&gt;&quot;);    //添加邮件的附件    helper.addAttachment(&quot;附件测试&quot;,new File(&quot;C://Users/ASUS/Desktop/面经.md&quot;));    //设置发送和接受    helper.setTo(&quot;1140144729@qq.com&quot;);    helper.setFrom(&quot;1140144729@qq.com&quot;);    //交由sender发送邮件    javaMailSender.send(message);&#125;\n\n\n\nDubbo和Zookeeper集成什么是分布式系统在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；\n分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。\n分布式系统（distributed system）是建立在网络之上的软件系统。\n首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。\n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。\n缺点：公用模块无法重复利用，开发性的浪费\n分布式服务架构\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。\n什么是RPCRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数&#x2F;方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求【无法通过本地调用实现】，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；\n什么是DubboApache Dubbo是一块高性能、轻量级的开源Java RPC框架，提供了六大核心能力：\n\n面向接口代理的高性能RPC调用\n智能容错和负载均衡\n服务自动注册和发现\n高度可扩展能力\n运行期流量调度\n可视化的服务治理与运维。\n\n设计模式：生产者消费者模型、 \n未来学完了springboot并真正的掌握、熟练，只能算作中级开发，接下来要学习更高一级的架构——微服务架构\n微服务架构的提出基于，当前单服务器系统已经无法满足日益增多的需求，负载过高。如果只是一昧地增加处理服务器，是远远不够的，对于性能的提升相当有限，也会有更多的隐患。\n于是微服务架构应运而生，将所有的功能都模块化，而不是全都集中在一个项目之中。并且将不同的服务部署在不同的服务器上，通过HTTP、RPC来进行异步调用。\n但是微服务架构的使用也存在着一些需要解决的问题：\n\n这么多服务，客户端如何访问？\n服务之间如何通信？\n服务太多了，该如何治理？\n服务挂了，怎么办？\n\n针对以上问题，有一套方案：\n\n网关\nDubbo，是一个基于JAVA的轻量级、高性能RPC通信框架。\nZookeeper，可以方便快捷地管理众多服务。\n熔断机制，采用之前SPringCloudNetflix的Hystrix（已经不再维护了）\n\n本质上，针对的是：\n\nAPI网关、服务的路由\nHttp、RPC框架、异步调用\n服务注册与发现，可用性\n熔断机制，服务降级\n\n再究其本质，就是因为网络是不可靠的，无法得到其会在何时何地出现怎样的问题，为了避免、解决问题，就需要上述这些东西。\n","categories":["框架"],"tags":["spring"]},{"title":"SpringMVC","url":"/springmvc/","content":"SpringMVC重点是执行流程、SSM框架整合。\nController：\n\n取得表单数据\n调用业务逻辑\n转向指定的页面\n\nModel：\n\n业务逻辑\n保存数据的状态\n\nView：\n\n显示页面\n\n最典型的MVC：JSP + servlet + javabean\n1、回顾servlet\n导入jar包\n&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt;\n\n编写servlet类，处理用户的请求\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    //1.获取前端参数    String method = req.getParameter(&quot;method&quot;);    if(method.equals(&quot;add&quot;))&#123;        req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);    &#125;    else if(method.equals(&quot;delete&quot;))&#123;        req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);    &#125;    //2.调用业务层    //3.视图转发或者重定向   记得把参数传递下去    req.getRequestDispatcher(&quot;WEB-INF/jsp/test.jsp&quot;).forward(req,resp);&#125;@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    doGet(req, resp);&#125;\n\n在web-INF下新建jsp文件夹，新建一个页面（jsp）\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;测试视图&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    $&#123;msg&#125;&lt;%--接收servlet传递的信息--%&gt;&lt;/body&gt;&lt;/html&gt;\n\n在web.xml中注册servlet\nservlet中就会指定要跳转到哪个页面。\n&lt;servlet&gt;    &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.study.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n配置Tomcat，测试\n\n【注意】要给项目添加web支持\n\n\nMVC框架要做哪些事情：\n\n将url映射到java类或者Java类的方法。\n封装用户提交的数据。\n处理请求——调用相关的业务来处理——封装响应的数据。\n渲染响应的数据——jsp或者html。\nｊｋｈｊｋｈ\n\n2、什么是SpringMVCSpring原生态搭建SpringMVC项目：\n\n在WEB-INF.xml中配置DispatcherServlet\n&lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!--绑定一个springMVC的配置文件，【servlet-name】-servlet.xml--&gt;    &lt;init-param&gt;        &lt;param-name&gt;ContextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;ClassPath:springmvc-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--启动级别--&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;\n\n准备springmvc-servlet.xml\n&lt;!--处理映射器，映射处理和处理器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;&lt;!--处理器适配器，根据映射器结果分配处理器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;&lt;!--视图解析器,DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;    &lt;!--前缀，WEB-INF前的斜杠不能少--&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;    &lt;!--后缀--&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;\n\n准备Controller，用于处理业务.\npublic class HelloController implements Controller &#123;    @Override    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        //模型和视图        ModelAndView mv = new ModelAndView();        //业务代码        //在mv中封装对象        mv.addObject(&quot;msg&quot;,&quot;Hello SpringMVC!&quot;);        //视图跳转        //在mv中封装要跳转的视图（页面）        mv.setViewName(&quot;hello&quot;);        return mv;    &#125;&#125;\n\n准备一个返回前端的页面\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;HelloSpringMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n3、SpringMVC的执行流程\n用户输入url，发送请求到DispatcherServlet\nDispatcherServlet转发请求到处理映射器和处理器，找到对应的处理器，返回目的处理器给DispatcherServlet．\nDispatcherServlet把目标处理器和参数发给处理器适配器，由适配器将数据传给Controller\nController调用业务处理, 得到ModelAndView, 加上要返回给用户的页面, 一起传给适配器, 适配器再传回给DispatcherServlet.\nDispatcherServlet将适配器传回的数据渲染到目标视图, 返回目标视图给用户.\n\n4、注解式开发SpringMVC项目\n也是在web.xml中配置DispatcherServlet\n略\n\n准备DispatcherServlet的配置文件\n视图解析器的配置不变，其他的由开启约束支持，搭配注解实现．\n&lt;!--自动扫描包，让指定包下的注解生效，再由IOC容器统一管理--&gt;&lt;context:component-scan base-package=&quot;org.study.controller&quot;/&gt;&lt;!--开启注解驱动支持，并由注解开启处理映射器、处理器适配器--&gt;&lt;mvc:annotation-driven/&gt;&lt;!--开启过滤，不处理静态资源--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--视图解析器,DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt;    &lt;!--前缀，WEB-INF前的斜杠不能少--&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;    &lt;!--后缀--&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;!--不再在spring核心配置中注册Controller为bean，而是使用注解--&gt;\n\n准备控制器\n\n不使用实现接口的方式得到控制类\n映射要将数据展示的页面\n可以通过多个方法,  实现对不同页面不同内容的渲染\n每个方法有自己对应处理的url请求**@RequestMapping()**\nSpringMVC 会自动实例化一个Model对象由于传递数据\n将数据传给要返回给用户的页面**(return””)**\n\n@Controllerpublic class helloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello(Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;Hello SpringMVC with annotation!&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n&#x3D;&#x3D;注意：如果是实现Controller类的控制器, 那么只能写一个方法;是注解的话可以写多个&#x3D;&#x3D;\n\n准备要返回给用户的页面\n获取由控制器传递的数据并将其渲染．\n\n关于RequestMapping\n如果类和方法都写了RequestMapping, 那么应该先进入类注解的目录, 再进入方法注解的地址.\n【注意】不过建议不在类上写RequestMapping，因为后期调试的时候，代码量很大，不一定注意到类名上的注解，最好就是直接写定在方法的RequestMapping上．\n\n\n　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　\n５、RestFul风格一种资源定位以及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次、更易于实现缓存等机制。\n传统操作资源的方式：通过*不同的参数来实现不同的效果。要实现不同的功能需要不同的url*。\n使用RestFul风格：不同的请求方式就可以得到不同的效果不同的功能可以通过相同的url实现。\n注解实现：\n通过RequestMapping指定 处理的URL，以及对应的提交方式（Get&#x2F;Post）\n\nRequestMapping有两个参数——Path(Value)、method。分别指定URL和提交方式.\n\n也可以直接使用确定了提交方式的Mapping——Get Mapping、PostMapping等。\n\n使用RestFul，一般需要在页面里面传参，要用到一个加在参数前面的注解@PathVariable\n\n然后要对应在Mapping注解中指明如何由URL取得参数\n\n写控制器，要记得在传参中写入Model对象,  负责传参到跳转页面(理解为MV即可)\n\n例如下:\n@PostMapping(&quot;GetMapping/&#123;a&#125;/&#123;b&#125;&quot;)public String PostMappingTest(@PathVariable int a,@PathVariable int b, Model model)&#123;    int res = a + b;    model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res);    return &quot;test&quot;;&#125;\n\n小黄鸭调试法一行行地自己讲解代码能够有效的帮助自找到bug出在哪。\n６、结果跳转方式通过ModelAndVew通过视图解析器,  直接在MV对象中指定跳转页面地的名称（不需要前缀后缀）\n@GetMapping(&quot;ModelAndViewTest&quot;)public ModelAndView MVTest(HttpServletRequest req, HttpServletResponse resp)&#123;    ModelAndView mv = new ModelAndView();    mv.addObject(&quot;msg&quot;,&quot;modelandviewTest&quot;);    mv.setViewName(&quot;test&quot;);    return mv;&#125;\n\n\n\n通过ServletAPI\n通过response输出\n//利用ServletAPI进行输出@RequestMapping(&quot;result/t1&quot;)public void ImplOut(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    response.getWriter().println(&quot;hello , Spring by Servlet API !&quot;);&#125;\n\n利用response重定向\n//利用ServletAPI重定向@RequestMapping(&quot;result/t2&quot;)public void ImplRed(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;    response.sendRedirect(&quot;/spring_04_Controller_war_exploded/index.jsp&quot;);    //用的是打包后项目路径下的地址&#125;\n\n\n\n利用request转发\n//利用ServletAPI转发@RequestMapping(&quot;result/t3&quot;)public void ImplForw(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    request.setAttribute(&quot;msg&quot;,&quot;reslut/t3&quot;);//和mapping注解的地址一致    request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request,response);&#125;\n\n通过SpringMVC有视图解析器:\n//利用SpringMVC、视图解析器来转发、重定向@GetMapping(&quot;result/t4&quot;)public String MVCTest(Model model)&#123;    model.addAttribute(&quot;msg&quot;,&quot;forward by MVC&quot;);    return &quot;test&quot;;&#125;//利用SpringMVC、视图解析器重定向@GetMapping(&quot;result/t5&quot;)public String MVCforwTest(Model model)&#123;    model.addAttribute(&quot;redirect by MVC&quot;);//会作为参数被拼接到URL中，一般重定向也不需要参数(输出)    return &quot;redirect:/index.jsp&quot;;&#125;\n\n\n\n无视图解析器：\n//无视图解析器转发1@GetMapping(&quot;res/t1&quot;)public String unVRforwTest1(Model model)&#123;    model.addAttribute(&quot;msg&quot;,&quot;不依靠视图解析器的转发&quot;);    return &quot;/WEB-INF/jsp/test.jsp&quot;;//还可以参考重定向的方式加上一个forward:&#125;//无视图解析器的重定向@GetMapping(&quot;res/t2&quot;)public String unVRforwTest2(Model model)&#123;    model.addAttribute(&quot;msg&quot;,&quot;不依靠视图解析器的重定向&quot;);//作为参数被加入到URL中    return &quot;redirect:/index.jsp&quot;;&#125;\n\n\n\n转发和重定向的区别1、请求次数\n重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次；\n2、地址栏不同\n重定向地址栏会发生变化，转发地址栏不会发生变化；\n3、是否共享数据\n重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；\n4、跳转限制\n重定向可以跳转到任意URL，转发只能跳转本站点资源；\n5、发生行为不同\n重定向是客户端行为，转发是服务器端行为；\n７、接收数据以及数据回显获取单个参数@RequestParam注解,旨在告诉前端要通过这个参数名传参,否则后端无法拿到这个参数\n@GetMapping(&quot;user/Test1&quot;)public String GetFormQian(@RequestParam(&quot;name&quot;) String name, Model model)&#123;    System.out.println(name);    model.addAttribute(&quot;msg&quot;,name);    return &quot;test&quot;;&#125;\n\n\n\n获取对象参数前端需要在url中写上参数，否则默认为空　\n接收对象参数不需要@RequestParam注解\n@GetMapping(&quot;user/Test2&quot;)public String GetUserQian(user user)&#123;    System.out.println(user);    return &quot;test&quot;;&#125;\n\n以上两个代码块的输出都是在IDEA的输出区输出，不在网页输出。\n数据返回前端显示\n通过ModelAndView\n方法可以不用参数\nModelAndView mv = new ModelAndView();mv.addObject(&quot;msg&quot;,&quot;modelandviewTest&quot;);mv.setViewName(&quot;test&quot;);return mv;\n\n\n\n通过ModelMap\nModel Map继承了LinkeHashMap,  有其全部方法,   可以实现很多效果\n@GetMapping(&quot;user/Test3&quot;)public String ModelMapTest(ModelMap map)&#123;    map.addAttribute(&quot;msg&quot;,&quot;ModelMap Test&quot;);    return &quot;test&quot;;&#125;\n\n\n\n通过Model\nModel是精简版的，只有几个方法，但是一般用不上很复杂的方法传参，所以大多数情况下都是在使用Model，因为他就已经够用了，不需要相对更复杂的ModelAndView或者ModleMap。\npublic String MVCTest(Model model)&#123;    model.addAttribute(&quot;msg&quot;,&quot;forward by MVC&quot;);    return &quot;test&quot;;&#125;\n\n８、乱码解决\n查看各个应用端的编码配置是否都是utf-8\n\n可以通过配置SpringMVC的过滤器,  尝试解决（在web.xml中配置）\n&lt;filter&gt;    &lt;filter-name&gt;encoding&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encoding&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!--/只对请求有过滤，/*才会多支持jsp--&gt;&lt;/filter-mapping&gt;\n\n尝试使用一个来自大佬的自定义过滤器\n详见随笔\n\n\n９、JSON什么是json？\nJSON是一种轻量级的数据交换格式\n采用完全独立于编程语言的文本格式来存储和表示数据。\n简洁和清晰的层次结构使得JSON成为理想的数据交换语言。\n易于人的读写,同时也易于及其的解析和生成,能够有效地提升网络传输效率。\n\n在JavaScript中，一切都是对象.  因此任何javascript支持的类型都可以通过JSON来表示,  例如字符串、数字、对象、数组等。\n语法要求如下:\n\n对象标识为键值对时,数据由都好分割\n花括号保存对象\n方括号保存数组\n\n例子:\n&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;&#123;&quot;age&quot;: &quot;3&quot;&#125;&#123;&quot;sex&quot;: &quot;男&quot;&#125;\n\n一种理解:\nJSON 是**JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串**。\nJSON和JavaScript对象的互转在HTML中的实现：\n\n要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：\n//将json对象转换为JS对象const obj = JSON.parse(json);console.log(obj);\n\n要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：\n//将JS对象转换为json对象const json = JSON.stringify(user);//user是一个多属性对象console.log(json);\n\n使用JSON导入依赖：2021.11.16最新\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.13.0&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n配置web.xml与不使用JSON的项目的配置没啥区别\n\nDispatcherServlet\nSpringMVC的乱码filter\n\n配置springmvc-servlet.xml开启注解支持、配置对JSON乱码的解决\n&lt;!--开启注解驱动支持，并由注解开启处理映射器、处理器适配器--&gt;&lt;!--JSON乱码问题配置--&gt;&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;        &lt;/bean&gt;        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;            &lt;property name=&quot;objectMapper&quot;&gt;                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;                &lt;/bean&gt;            &lt;/property&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;\n\n其他：\n\n包扫描\n注解驱动\n资源过滤\n视图解析器\n\nFastJSONfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现\nJavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后\n的实现结果都是一样的。\n导入依赖（kuang的老版本）\n&lt;dependency&gt;   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;   &lt;artifactId&gt;fastjson&lt;/artifactId&gt;   &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n具体的一些使用（方法）\nSystem.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);String str1 = JSON.toJSONString(list);System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);String str2 = JSON.toJSONString(user1);System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;);User jp_user1=JSON.parseObject(str2,User.class);System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;);JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;);User to_java_user = JSON.toJavaObject(jsonObject1, User.class);System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);\n\n\n\n10、整合SSMMybatis层1、准备数据库\n2、新建maven项目\n3、导入依赖\n\n开启资源过滤\n\n4、准备配置文件\n\nmybatis\nspring\n数据库的数据源\n\n5、配置POJO类、Mapper、Services（、Controller）\nSpring层用Spring来整合Mybatis层\nDAO层1、关联数据库的配置文件（properties）\n2、数据库连接池\n3、配置sqlSessionfactory\n4、配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 \nServices层1、扫描services的bean（或是注册）\n2、配置事务管理器（需要注入数据库的连接池）\nSpringMVC层1、添加web框架支持\n2、配置web.xml文件\n\n配置DispatcherServelet\n编码过滤器\nsession生存周期\n\n3、配置springmvc-servlet.xml文件\n\n注解驱动支持\n静态资源过滤器\n视图解析器\n（扫描Controller的bean）\n\n4、整合各层配置文件到applicationContext.xml\nCRUD准备前端页面\n\n需要掌握一定前端知识\n组件开发、vue架构\n在前端提供操作数据的**按钮**\n\n在后端调用接口实现\n\nController层调用对应的方法来执行前端发起的请求\n必要时跳转额外的视图来对数据进行处理——增加、更改。\n然后重定向回到主界面或者类似这个功能的页面。\n\n","categories":["框架"],"tags":["spring"]},{"title":"SpringBoot学习（Runoob）","url":"/springboot%E5%AD%A6%E4%B9%A0%EF%BC%88runoob%EF%BC%89/","content":"\n\n1.SpringBoot是什么由于spring的配置太过繁琐，所以有了SpringBoot来简化spring的配置的同时，保留spring的可用性。\nSpring Boot 具有 Spring 一切优秀特性，Spring 能做的事，Spring Boot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮\nSpring Boot 提供了大量开箱即用（out-of-the-box）的依赖模块，例如 spring-boot-starter-redis、spring-boot-starter-data-mongodb 和 spring-boot-starter-data-elasticsearch 等。这些依赖模块为 Spring Boot 应用提供了大量的自动配置，使得 Spring Boot 应用只需要非常少量的配置甚至零配置，便可以运行起来，让开发人员从 Spring 的“配置地狱”中解放出来，有更多的精力专注于业务逻辑的开发。\n特点\n独立运行的 Spring 项目\n\n内嵌 Servlet 容器 \n嵌入了 Tomcat 等\n\n提供 starter 简化 Maven 配置\n提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。\n\n提供了大量的自动配置\n\n自带应用监控\n可以对正在运行的项目提供监控。\n\n无代码生成和 xml 配置\n\n\n2.starter入门Spring Boot 将日常企业应用研发中的各种场景都抽取出来，做成一个个的 starter（启动器），starter 中整合了该场景下各种可能用到的依赖，用户只需要在 Maven 中引入 starter 依赖，SpringBoot 就能自动扫描到要加载的信息并启动相应的默认配置。starter 提供了大量的自动配置，让用户摆脱了处理各种依赖和配置的困扰。所有这些 starter 都遵循着约定成俗的默认配置，并允许用户调整这些配置，即遵循“约定大于配置”的原则。\n以 spring-boot-starter-web 为例，它能够为提供 Web 开发场景所需要的几乎所有依赖，因此在使用 Spring Boot 开发 Web 项目时，只需要引入该 Starter 即可，而不需要额外导入 Web 服务器和其他的 Web 依赖。\nspring-boot-starter-parentspring-boot-starter-parent 是所有 Spring Boot 项目的父级依赖，它被称为 Spring Boot 的&#x3D;&#x3D;版本仲裁中心&#x3D;&#x3D;，可以对项目内的部分常用依赖进行统一管理。\n因为starter中不设有依赖的版本，所以需要一个同一的版本管理中心来管理所有的依赖各自的版本。\nSpring Boot 项目通过继承 spring-boot-starter-parent 来获得一些合理的默认配置，它主要提供了以下特性：\n\n默认 JDK 版本（Java 8）\n默认字符集（UTF-8）\n依赖管理功能\n资源过滤\n默认插件配置\n识别 application.properties 和 application.yml 类型的配置文件\n\nYAMLapplication.yml 是一种使用 YAML 语言编写的文件，它与 application.properties 一样，可以在 Spring Boot 启动时被自动读取，修改 Spring Boot 自动配置的默认值。\nYAML 全称 YAML Ain’t Markup Language，它是一种以数据为中心的标记语言，比 XML 和 JSON 更适合作为配置文件。\n使用YAML只需要引入spring-boot-starter-&#x3D;&#x3D;web&#x3D;&#x3D; 或 spring-boot-starter即可。\n语法YAML 的语法如下：\n\n使用缩进表示层级关系。\n缩进时不允许使用 Tab 键，只允许使用空格。\n缩进的空格数不重要，但同级元素必须左侧对齐。\n大小写敏感。\n\n例如：\nspring:  profiles: dev  datasource:    url: jdbc:mysql://127.0.01/banchengbang_springboot    username: root    password: root    driver-class-name: com.mysql.jdbc.Driver\n\n\n\n常用写法YAML 支持以下三种数据结构：\n\n对象：键值对的集合\n数组：一组按次序排列的值\n字面量：单个的、不可拆分的值\n\n字面量默认情况下字符串是不需要使用单引号或双引号的\nname: bianchengbang\n\n\n\n若字符串使用单引号，则会转义特殊字符。\nname: zhangsan \\n lisi输出: zhangsan \\n lisi\n\n\n\n若字符串使用双引号，则不会转义特殊字符，特殊字符会输出为其本身想表达的含义\nname: zhangsan \\n lisi输出: zhangsan lisi\n\n\n\n对象YAML 为对象提供了 2 种写法：\n普通写法，使用缩进表示对象与属性的层级关系。\nwebsite:   name: bianchengbang  url: www.biancheng.net\n\n\n\n行内写法：大括号括起来全部，键值对表示一种属性，逗号分开\nwebsite: &#123;name: bianchengbang,url: www.biancheng.net&#125;\n\n\n\nYAML 数组写法YAML 使用“-”表示数组中的元素，普通写法如下：\npets:  -dog  -cat  -pig\n\n\n\n行内写法:中括号括起来，逗号分开，没有空格（有也可以）\npets: [dog,cat,pig]\n\n\n\n复合结构以上三种数据结构可以任意组合使用，以实现不同的用户需求，例如：\nperson:  name: zhangsan  age: 30  pets:    -dog    -cat    -pig  car:    name: QQ  child:    name: zhangxiaosan    age: 2\n\n\n\nYAML 组织结构一个 YAML 文件可以由一个或多个文档组成，文档之间使用&#x3D;&#x3D;“—”作为分隔符&#x3D;&#x3D;，且个文档相互独立，互不干扰。如果 YAML 文件只包含一个文档，则“—”分隔符可以省略。\n---website:  name: bianchengbang  url: www.biancheng.net---website: &#123;name: bianchengbang,url: www.biancheng.net&#125;pets:  -dog  -cat  -pig---pets: [dog,cat,pig]name: &quot;zhangsan \\n lisi&quot;---name: &#x27;zhangsan \\n lisi&#x27;\n\n\n\n配置绑定把配置文件中的值与 JavaBean 中对应的属性进行绑定\nSpringBoot 提供了以下 2 种方式进行配置绑定：\n\n使用 @ConfigurationProperties 注解\n使用 @Value 注解\n\n@ConfigurationProperties通过 Spring Boot 提供的 @ConfigurationProperties 注解，可以将全局配置文件中的配置数据绑定到 JavaBean 中。下面我们以 Spring Boot 项目 helloworld 为例，演示如何通过 @ConfigurationProperties 注解进行配置绑定。\n1.在properties文件中自定义配置\nperson:  lastName: 张三  age: 18  boss: false  birth: 1990/12/12  maps: &#123; k1: v1,k2: 12 &#125;  lists:    ‐ lisi    ‐ zhaoliu  dog:    name: 迪迪    age: 5\n\n2.创建实体类，并将配置文件中的属性映射到这个实体类上面\n@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Data@AllConstructor@NoConstructorpublic class Person &#123;\tprivate String lastName;    private Integer age;    private Boolean boss;    private Date birth;    private Map&lt;String, Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;    &#125;\n\n注意：\n\n只有在容器中的组件，才会拥有 SpringBoot 提供的强大功能。如果我们想要使用 @ConfigurationProperties 注解进行配置绑定，那么首先就要保证该对 JavaBean 对象在 IoC 容器中，所以需要用到 @Component 注解来添加组件到容器中。\nJavaBean 上使用了注解 @ConfigurationProperties(prefix &#x3D; “person”) ，它表示将这个 JavaBean 中的所有属性与配置文件中以“person”为前缀的配置进行绑定。\n\n3.由于person中有Dog，所以还需要创建一个Dog的javaBean\npublic class Dog &#123;    private String name;    private String age;    &#125;\n\n4.在调用了Person的地方进行自动装配\n@Controllerpublic class HelloController &#123;    @Autowired\t//将配置文件中的配置装配给Bean    private Person person;    @ResponseBody\t//只返回数据，不跳转页面    @RequestMapping(&quot;/hello&quot;)    public Person hello() &#123;        return person;    &#125;&#125;\n\n\n\n@Value当我们&#x3D;&#x3D;只需要&#x3D;&#x3D;读取配置文件中的&#x3D;&#x3D;某一个&#x3D;&#x3D;配置时，可以通过 @Value 注解获取。\n修改上面person的代码为例子\n在需要特定取值的属性上面用@Value来取值即可。\n@Componentpublic class Person &#123;    @Value(&quot;$&#123;person.lastName&#125;&quot;)    private String lastName;    @Value(&quot;$&#123;person.age&#125;&quot;)    private Integer age;    @Value(&quot;$&#123;person.boss&#125;&quot;)    private Boolean boss;    @Value(&quot;$&#123;person.birth&#125;&quot;)    private Date birth;&#125;\n\n\n\n@Value 与 @ConfigurationProperties 对比两个都能读取配置文件中的信息并绑定到javaBean中，但有以下不同：\n\n使用位置不同：\n\n@ConfigurationProperties：标注在 JavaBean 的**&#x3D;&#x3D;类名上&#x3D;&#x3D;**；\n@Value：标注在 JavaBean 的**&#x3D;&#x3D;属性上&#x3D;&#x3D;**。\n\n\n功能不同\n\n@ConfigurationProperties：用于&#x3D;&#x3D;批量绑定&#x3D;&#x3D;配置文件中的配置；\n@Value：只能一个&#x3D;&#x3D;一个的指定&#x3D;&#x3D;需要绑定的配置。\n\n\n松散绑定支持不同\n\n@ConfigurationProperties：支持松散绑定（松散语法），例如实体类 Person 中有一个属性为 firstName，那么配置文件中的属性名支持以下写法：\nperson.firstName\nperson.first-name\nperson.first_name\nPERSON_FIRST_NAME\n\n\n而@Vaule：不支持松散绑定\n\n\nSpEL 支持不同\n\n@ConfigurationProperties：不支持 SpEL 表达式;\n@Value：支持 SpEL 表达式。\n\n\n复杂类型封装\n\n@ConfigurationProperties：支持所有类型数据的封装，例如 Map、List、Set、以及对象等；\n@Value：只支持基本数据类型的封装，例如字符串、布尔值、整数等类型。\n\n\n应用场景不同\n@Value 和 @ConfigurationProperties 两个注解之间，并没有明显的优劣之分，它们只是适合的应用场景不同而已。\n\n若只是获取配置文件中的某项值，则推荐使用 @Value 注解；\n若专门编写了一个 JavaBean 来和配置文件进行映射，则建议使用 @ConfigurationProperties 注解。\n\n\n\n@PropertySource如果将所有的配置都集中到 application.properties 或 application.yml 中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 Spring Boot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的 JavaBean 上使用 @PropertySource 注解指向该配置文件。\n1.编写配置文件\nlanyo:  name: linxu  gender: 1  age: 21\n\n2.编写实体类，绑定配置文件\n@Component@PropertySource(value = &quot;classpath:text.yml&quot;)@ConfigurationProperties(prefix = &quot;lanyo&quot;)public class lanyoText &#123;    public String name;    public boolean gender;    public Integer age;&#125;\n\n3.在调用时注入数据\n@Autowiredpublic lanyoText lanyo;@RequestMapping(&quot;/lanyo&quot;)public lanyoText lanyo()&#123;    return lanyo;&#125;\n\n\n\nspringboot导入spring配置默认情况下，Spring Boot 中是不包含任何的 Spring 配置文件的，即使我们手动添加 Spring 配置文件到项目中，也不会被识别。\nSpring Boot 为了我们提供了以下 2 种方式来导入 Spring 配置：\n\n使用 @ImportResource 注解加载 Spring 配置文件\n使用全注解方式加载 Spring 配置\n\n@ImportResource 导入 Spring 配置文件在&#x3D;&#x3D;主启动类&#x3D;&#x3D;上使用 @ImportResource 注解可以导入一个或多个 Spring 配置文件，并使其中的内容生效。\n\n新建一个接口类\npublic interface PersonService &#123;    public Person getPersonInfo();&#125;\n\n\n\n新建一个接口的实现类\npublic class PersonServiceImpl implements PersonService &#123;    @Autowired    private Person person;    @Override    public Person getPersonInfo() &#123;        return person;    &#125;&#125;\n\n\n\n在该项目的 resources 下添加一个名为 beans.xml 的 Spring 配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;personService&quot; class=&quot;net.biancheng.www.service.impl.PersonServiceImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\n校验 IOC 容器是否已经加入 personService\n@SpringBootTestclass HelloworldApplicationTests &#123;    @Autowired    Person person;    //IOC 容器    @Autowired    ApplicationContext ioc;    @Test    public void testHelloService() &#123;        //校验 IOC 容器中是否包含组件 personService        boolean b = ioc.containsBean(&quot;personService&quot;);        if (b) &#123;            System.out.println(&quot;personService 已经添加到 IOC 容器中&quot;);        &#125; else &#123;            System.out.println(&quot;personService 没添加到 IOC 容器中&quot;);        &#125;    &#125;    @Test    void contextLoads() &#123;        System.out.println(person);    &#125;&#125;\n\n\n\n在主启动程序类上使用 @ImportResource 注解，将 Spring 配置文件 beans.xml 加载到项目中\n@ImportResource(locations = &#123;&quot;classpath:/beans.xml&quot;&#125;)@SpringBootApplicationpublic class HelloworldApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(HelloworldApplication.class, args);    &#125;&#125;\n\n全注解方式加载 Spring 配置&#x3D;&#x3D;Spring Boot 推荐我们使用全注解的方式加载 Spring 配置&#x3D;&#x3D;\n\n使用 @Configuration 注解定义配置类，替换 Spring 的配置文件；\n\n配置类内部可以包含有一个或多个被 @Bean 注解的方法，这些方法会被 AnnotationConfigApplicationContext 或 AnnotationConfigWebApplicationContext 类扫描，构建 bean 定义（相当于 Spring 配置文件中的标签），方法的返回值会以组件的形式添加到容器中，组件的 id 就是方法名。\n参考第一个文档中关于MyConfig的使用方式，通过自定义配置来驱动项目。\n@Configurationpublic class MyAppConfig &#123;    @Bean    public PersonService personService() &#123;        System.out.println(&quot;在容器中添加了一个组件:peronService&quot;);        return new PersonServiceImpl();    &#125;&#125;\n\n&#x3D;&#x3D;全注解方式其实就是在配置类里面，写一个方法，返回想要的组件，同时用@Bean来注释这个方法即可。&#x3D;&#x3D;\n\n\nSpring Boot Profile（多环境配置）在实际的项目开发中，一个项目通常会存在多个环境，例如，开发环境、测试环境和生产环境等。不同环境的配置也不尽相同，例如开发环境使用的是开发数据库，测试环境使用的是测试数据库，而生产环境使用的是线上的正式数据库。\nProfile 为在不同环境下使用不同的配置提供了支持，我们可以通过激活、指定参数等方式快速切换环境。\n多 Profile 的文件方式Spring Boot 的配置文件共有两种形式：.properties 文件和 .yml 文件，不管哪种形式，它们都能通过文件名的命名形式区分出不同的环境的配置，文件命名格式为：\napplication-&#123;profile&#125;.properties/yml\n\n其中，{profile} 一般为各个环境的名称或简称，例如 dev、test 和 prod 等等。\n如果没有在默认的配置文件中指出激活哪个配置文件，那么项目将以默认的配置运行。\nproperties文件:\n#激活指定的profilespring.profiles.active=prod #prod就是配置文件中的简称\n\nyaml文件同理:\n#切换配置spring:  profiles:    active: dev #激活开发环境配置\n\n\n\n多 Profile 的文档块模式在 YAML 配置文件中，可以使用“—”把配置文件分割成了多个文档块，因此我们可以在不同的文档块中针对不同的环境进行不同的配置，并在第一个文档块内对配置进行切换。\n#默认配置server:  port: 8080#切换配置spring:  profiles:    active: test---#开发环境server:  port: 8081spring:  config:    activate:      on-profile: dev---#测试环境server:  port: 8082spring:  config:    activate:      on-profile: test\n\n&#x3D;&#x3D;yaml的profile实现，文件方式和文档快方式的写法不一样&#x3D;&#x3D;\n激活 Profile除了可以在配置文件中激活指定 Profile，Spring Boot 还为我们提供了另外 2 种激活 Profile 的方式：\n\n命令行激活\n虚拟机参数激活\n\nSpring Boot配置文件通常情况下，Spring Boot 在启动时会将 resources 目录下的 application.properties 或 apllication.yml 作为其默认配置文件，我们可以在该配置文件中对项目进行配置，但这并不意味着 Spring Boot 项目中只能存在一个 application.properties 或 application.yml。\n默认配置文件Spring Boot 项目中可以存在多个 application.properties 或 apllication.yml。\nSpring Boot 启动时会扫描以下 5 个位置的 application.properties 或 apllication.yml 文件，并将它们作为 Spring boot 的默认配置文件。\n\nfile:.&#x2F;config&#x2F;\nfile:.&#x2F;config&#x2F;*&#x2F;\nfile:.&#x2F;\nclasspath:&#x2F;config&#x2F;\nclasspath:&#x2F;\n\n注：file: 指当前项目根目录；classpath: 指当前项目的类路径，即 resources 目录。\n\n以上所有位置的配置文件都会被加载，且它们优先级依次降低，序号越小优先级越高。其次，位于相同位置的 application.properties 的优先级高于 application.yml。\n外部配置文件除了默认配置文件，Spring Boot 还可以加载一些位于项目外部的配置文件。我们可以通过如下 2 个参数，指定外部配置文件的路径：\n\nspring.config.location \nspring.config.additional-location\n\n使用外部配置文件需要先将项目打包成为jar包。\n但与 –spring.config.location 不同，–spring.config.additional-location 不会使项目默认的配置文件失效，使用该命令行参数添加的外部配置文件会与项目默认的配置文件共同生效，形成互补配置，且其优先级是最高的，比所有默认配置文件的优先级都高。\nSpring Boot 不仅可以通过配置文件进行配置，还可以通过环境变量、命令行参数等多种形式进行配置。这些配置都可以让开发人员在不修改任何代码的前提下，直接将一套 Spring Boot 应用程序在&#x3D;&#x3D;不同的环境&#x3D;&#x3D;中运行。\n配置优先级以下是常用的 Spring Boot 配置形式及其加载顺序（优先级由高到低）：\n\n命令行参数\n来自 java:comp&#x2F;env 的 JNDI 属性\nJava 系统属性（System.getProperties()）\n操作系统环境变量\nRandomValuePropertySource 配置的 random.* 属性值\n配置文件（YAML 文件、Properties 文件）\n@Configuration 注解类上的 @PropertySource 指定的配置文件\n通过 SpringApplication.setDefaultProperties 指定的默认属性\n\n自动配置原理我们知道，Spring Boot 项目创建完成后，即使不进行任何的配置，也能够顺利地运行，这都要归功于 Spring Boot 的自动化配置。\n统一日志框架在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。在 Java 领域里存在着多种日志框架，如 JCL、SLF4J、Jboss-logging、jUL、log4j、log4j2、logback 等等。\n日志框架的选择市面上常见的日志框架有很多，它们可以被分为两类：日志门面（日志抽象层）和日志实现，如下表。\n\n\n\n日志分类\n描述\n举例\n\n\n\n日志门面（日志抽象层）\n为 Java 日志访问提供一套标准和规范的 API 框架，其主要意义在于提供接口。\nJCL（Jakarta Commons Logging）、SLF4j（Simple Logging Facade for Java）、jboss-logging\n\n\n日志实现\n日志门面的具体的实现\nLog4j、JUL（java.util.logging）、Log4j2、Logback\n\n\n通常情况下，日志由一个日志门面与一个日志实现组合搭建而成，Spring Boot 选用 SLF4J + Logback 的组合来搭建日志系统。\nSLF4J 是目前市面上最流行的日志门面，使用 Slf4j 可以很灵活的使用占位符进行参数占位，简化代码，拥有更好的可读性。\nLogback 是 Slf4j 的原生实现框架，它与 Log4j 出自一个人之手，但拥有比 log4j 更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流。\nSLF4J 的使用SLF4J——simple logging facade for java\n在项目开发中，记录日志时不应该直接调用日志实现层的方法，而应该调用日志门面（日志抽象层）的方法。\n在使用 SLF4J 记录日志时，我们需要在应用中导入 SLF4J 及日志实现，并在记录日志时调用 SLF4J 的方法\nimport org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123;    public static void main(String[] args) &#123;        Logger logger = LoggerFactory.getLogger(HelloWorld.class);       //调用 sl4j 的 info() 方法，而非调用 logback 的方法        logger.info(&quot;Hello World&quot;);    &#125;&#125;\n\nSLF4J 作为一款优秀的日志门面或者日志抽象层，它可以与各种日志实现框架组合使用，以达到记录日志的目的。\n从 SLF4J 官方给出的方案可以看出：\n\nLogback 作为 Slf4j 的原生实现框架，当应用使用 SLF4J+Logback 的组合记录日志时，只需要引入 SLF4J 和 Logback 的 Jar 包即可；\nLog4j 虽然与 Logback 出自同一个人之手，但是 Log4j 出现要早于 SLF4J，因而 Log4j 没有直接实现 SLF4J，当应用使用 SLF4J+Log4j 的组合记录日志时，不但需要引入 SLF4J 和 Log4j 的 Jar 包，还必须引入它们之间的适配层（Adaptation layer）slf4j-log4j12.jar，该适配层可谓“上有老下有小”，它既要实现 SLF4J 的方法，还有调用 Log4j 的方法，以达到承上启下的作用；\n当应用使用 SLF4J+JUL 记录日志时，与 SLF4J+Log4j 一样，不但需要引入 SLF4J 和 JUL 的对应的 Jar 包，还要引入适配层 slf4j-jdk14.jar。\n\n这里我们需要注意一点，每一个日志的实现框架都有自己的配置文件。使用 slf4j 记录日志时，配置文件应该使用日志实现框架（例如 logback、log4j 和 JUL 等等）自己本身的配置文件。\n\n\n\n统一日志框架（通用）通常一个完整的应用下会依赖于多种不同的框架，而且它们记录日志使用的日志框架也不尽相同，例如，Spring Boot（slf4j+logback），Spring（commons-logging）、Hibernate（jboss-logging）等等。那么如何统一日志框架的使用呢？\n统一日志框架一共需要以下 3 步 ：\n\n排除应用中的原来的日志框架；\n引入**&#x3D;&#x3D;替换包&#x3D;&#x3D;**替换被排除的日志框架；\n导入 SLF4J 实现。\n\nSLF4J 官方给出的统一日志框架的方案是“狸猫换太子”，即使用一个替换包来替换原来的日志框架，例如 log4j-over-slf4j 替换 Log4j（Commons Logging API）、jul-to-slf4j.jar 替换 JUL（java.util.logging API）等等。\n替换包内包含被替换的日志框架中的所有类，这样就可以保证应用不会报错，但替换包内部实际使用的是 SLF4J API，以达到统一日主框架的目的。\n统一日志框架我们在使用 Spring Boot 时，同样可能用到其他的框架，例如 Mybatis、Spring MVC、 Hibernate 等等，这些框架的底层都有自己的日志框架，此时我们也需要对日志框架进行统一。\n我们知道，统一日志框架的使用一共分为 3 步，Soring Boot 作为一款优秀的开箱即用的框架，已经为用户完成了其中 2 步：引入替换包和导入 SLF4J 实现。\nSpring Boot 的核心启动器 spring-boot-starter 引入了 spring-boot-starter-logging，使用 IDEA 查看其依赖关系，如下图。\n\n\n从图可知，spring-boot-starter-logging 的 Maven 依赖不但引入了 logback-classic （包含了日志框架 SLF4J 的实现），还引入了 log4j-to-slf4j（log4j 的替换包），jul-to-slf4j （JUL 的替换包），即 Spring Boot 已经为我们完成了统一日志框架的 3 个步骤中的 2 步。\nSpringBoot 底层使用 slf4j+logback 的方式记录日志，当我们引入了依赖了其他日志框架的第三方框架（例如 Hibernate）时，只需要把这个框架所依赖的日志框架排除，即可实现日志框架的统一，示例代码如下。\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;    &lt;artifactId&gt;activemq-console&lt;/artifactId&gt;    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;    &lt;!--排除掉其他框架的日志框架--&gt;            &lt;groupId&gt;commons-logging&lt;/groupId&gt;            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;\n\n\n\nSpring Boot日志配置及输出默认配置Spring Boot 默认使用 SLF4J+Logback 记录日志，并提供了默认配置，即使我们不进行任何额外配，也可以使用 SLF4J+Logback 进行日志输出。\n常见的日志配置包括日志级别、日志的输入出格式等内容。\n日志级别日志的输出都是分级别的，当一条日志信息的级别大于或等于配置文件的级别时，就对这条日志进行记录。\n常见的日志级别如下（优先级依次升高）。\n\n\n\n序号\n日志级别\n说明\n\n\n\n1\ntrace(低)\n追踪，指明程序运行轨迹。\n\n\n2\ndebug\n调试，实际应用中一般将其作为最低级别，而 trace 则很少使用。\n\n\n3\ninfo\n输出重要的信息，使用较多。\n\n\n4\nwarn\n警告，使用较多。\n\n\n5\nerror(高)\n错误信息，使用较多。\n\n\n输出格式我们可以通过以下常用日志参数对日志的输出格式进行修改，如下表。\n\n\n\n序号\n输出格式\n说明\n\n\n\n1\n%d{yyyy-MM-dd HH:mm:ss, SSS}\n日志生产时间,输出到毫秒的时间\n\n\n2\n%-5level\n输出日志级别，-5 表示左对齐并且固定输出 5 个字符，如果不足在右边补 0\n\n\n3\n%logger 或 %c\nlogger 的名称\n\n\n4\n%thread 或 %t\n输出当前线程名称\n\n\n5\n%p\n日志输出格式\n\n\n6\n%message 或 %msg 或 %m\n日志内容，即 logger.info(“message”)\n\n\n7\n%n\n换行符\n\n\n8\n%class 或 %C\n输出 Java 类名\n\n\n9\n%file 或 %F\n输出文件名\n\n\n10\n%L\n输出错误行号\n\n\n11\n%method 或 %M\n输出方法名\n\n\n12\n%l\n输出语句所在的行数, 包括类名、方法名、文件名、行数\n\n\n13\nhostName\n本地机器名\n\n\n14\nhostAddress\n本地 ip 地址\n\n\nSpring Boot 日志默认级别为 info，日志输出内容默认包含以下元素：\n\n时间日期\n日志级别\n进程 ID\n分隔符：—\n线程名：方括号括起来（可能会截断控制台输出）\nLogger 名称\n日志内容\n\n修改默认日志配置我们可以根据自身的需求，通过全局配置文件（application.properties&#x2F;yml）修改 Spring Boot 日志级别和显示格式等默认配置。\n#日志级别logging.level.net.biancheng.www=trace#使用相对路径的方式设置日志输出的位置（项目根目录目录\\my-log\\mylog\\spring.log）#logging.file.path=my-log/myLog#绝对路径方式将日志文件输出到 【项目所在磁盘根目录\\springboot\\logging\\my\\spring.log】logging.file.path=/spring-boot/logging#控制台日志输出格式logging.pattern.console=%d&#123;yyyy-MM-dd hh:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#日志文件输出格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; === - %msg%n\n\n\n\n自定义日志配置在 Spring Boot 的配置文件 application.porperties&#x2F;yml 中，可以对日志的一些默认配置进行修改，但这种方式只能修改个别的日志配置，想要修改更多的配置或者使用更高级的功能，则需要通过日志实现框架的配置文件进行配置。\nSpring 官方提供了各个日志实现框架所需的配置文件，用户只要将指定的配置文件放置到**项目的&#x3D;&#x3D;类路径&#x3D;&#x3D;**下即可。\n\n\n\n日志框架\n配置文件\n\n\n\nLogback\nlogback-spring.xml、logback-spring.groovy、logback.xml、logback.groovy\n\n\nLog4j2\nlog4j2-spring.xml、log4j2.xml\n\n\nJUL (Java Util Logging)\nlogging.properties\n\n\n从上表可以看出，日志框架的配置文件基本上被分为 2 类：\n\n普通日志配置文件，即不带 srping 标识的配置文件，例如 logback.xml；\n带有 spring 表示的日志配置文件，例如 logback-spring.xml。\n\n普通日志配置文件我们将 logback.xml、log4j2.xml 等不带 spring 标识的普通日志配置文件，放在项目的类路径下后，这些配置文件会跳过 Spring Boot，直接被日志框架加载。通过这些配置文件，我们就可以达到自定义日志配置的目的。\n带有 spring 标识的日志配置文件Spring Boot 推荐用户使用 logback-spring.xml、log4j2-spring.xml 等这种带有 spring 标识的配置文件。这种配置文件被放在项目类路径后，不会直接被日志框架加载，而是由 Spring Boot 对它们进行解析，这样就可以使用 Spring Boot 的高级功能 Profile，实现在不同的环境中使用不同的日志配置。\n&#x3D;&#x3D;两个自定义日志配置的示例见链接&#x3D;&#x3D;\nWEB启动器Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，其本身就是 Spring 框架的一部分，可以与 Spring 无缝集成，性能方面具有先天的优越性，是当今业界最主流的 Web 开发框架之一。\nSpring Boot 是在 Spring 的基础上创建一款开源框架，它提供了 spring-boot-starter-web（Web 场景启动器） 来为 Web 开发予以支持。spring-boot-starter-web 为我们&#x3D;&#x3D;提供了嵌入的 Servlet 容器以及 SpringMVC 的依赖，并为 Spring MVC 提供了大量自动配置&#x3D;&#x3D;，可以适用于大多数 Web 开发场景。\nSpring Boot Web 快速开发Spring Boot 为 Spring MVC 提供了自动配置，并在 Spring MVC 默认功能的基础上添加了以下特性：\n\n引入了 ContentNegotiatingViewResolver 和 BeanNameViewResolver（视图解析器）\n对包括 WebJars 在内的静态资源的支持\n自动注册 Converter、GenericConverter 和 Formatter （转换器和格式化器）\n对 HttpMessageConverters 的支持（Spring MVC 中用于转换 HTTP 请求和响应的消息转换器）\n自动注册 MessageCodesResolver（用于定义错误代码生成规则）\n支持对静态首页（index.html）的访问\n自动使用 ConfigurableWebBindingInitializer\n\n只要我们在 Spring Boot 项目中的 pom.xml 中引入了 spring-boot-starter-web ，即使不进行任何配置，也可以直接使用 Spring MVC 进行 Web 开发。\n由于 spring-boot-starter-web 默认替我们引入了核心启动器 spring-boot-starter，因此，当 Spring Boot 项目中的 pom.xml 引入了 spring-boot-starter-web 的依赖后，就无须在引入 spring-boot-starter 核心启动器的依赖了。\n静态资源映射在 Web 应用中会涉及到大量的静态资源，例如 JS、CSS 和 HTML 等。我们知道，Spring MVC 导入静态资源文件时，需要配置静态资源的映射；但在 SpringBoot 中则不再需要进行此项配置，因为 SpringBoot 已经默认完成了这一工作。\nSpring Boot 默认为我们提供了 3 种静态资源映射规则：\n\nWebJars 映射\n默认资源映射\n静态首页（欢迎页）映射\n\nWebJars 映射为了让页面更加美观，让用户有更多更好的体验，Web 应用中通常会使用大量的 JS 和 CSS，例如 jQuery，Backbone.js 和 Bootstrap 等等。通常我们会将这些 Web 前端资源拷贝到 Java Web 项目的 webapp 相应目录下进行管理。但是 Spring Boot 项目是以 JAR 包的形式进行部署的，不存在 webapp 目录，那么 Web 前端资源该如何引入到 Spring Boot 项目中呢？\nWebJars 可以完美的解决上面的问题，它可以 Jar 形式为 Web 项目提供资源文件。\nWebJars 可以将 Web 前端资源（JS，CSS 等）打成一个个的 Jar 包，然后将这些 Jar 包部署到 Maven 中央仓库中进行统一管理，当 Spring Boot 项目中需要引入 Web 前端资源时，只需要访问 WebJars 官网，找到所需资源的 pom 依赖，将其导入到项目中即可。\n所有通过 WebJars 引入的前端资源都存放在当前项目类路径（classpath）下的“&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;” 目录中。（以jar包的形式）\nSpring Boot通过 MVC 的自动配置类 WebMvcAutoConfiguration为这些WebJars前端资源提供了默认映射规则\nWebJars 的映射路径为“&#x2F;webjars&#x2F;”，即所有访问“&#x2F;webjars&#x2F;”的请求，都会去“classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;”查找 WebJars 前端资源。\n默认静态资源映射当访问项目中的任意资源（即“&#x2F;**”）时，Spring Boot 会默认从以下路径中查找资源文件（优先级依次降低）：\n\nclasspath:&#x2F;META-INF&#x2F;resources&#x2F;\nclasspath:&#x2F;resources&#x2F;\nclasspath:&#x2F;static&#x2F;\nclasspath:&#x2F;public&#x2F;\n\n这些路径又被称为静态资源文件夹，它们的优先级顺序为：classpath:&#x2F;META-INF&#x2F;resources&#x2F; &gt; classpath:&#x2F;resources&#x2F; &gt; classpath:&#x2F;static&#x2F; &gt; classpath:&#x2F;public&#x2F; 。\n当我们请求某个静态资源（即以“.html”结尾的请求）时，Spring Boot 会先查找优先级高的文件夹，再查找优先级低的文件夹，直到找到指定的静态资源为止。\n静态首页（欢迎页）映射静态资源文件夹下的所有 index.html 被称为静态首页或者欢迎页，它们会被 &#x2F;** 映射，换句话说就是，当我们访问“&#x2F;”或者“&#x2F;index.html”时，都会跳转到静态首页（欢迎页）。\n注意，访问静态首页或欢迎页时，其查找顺序也遵循默认静态资源的查找顺序，即先查找优先级高的目录，在查找优先级低的目录，直到找到 index.html 为止。\nThymeleafThymeleaf 是一款用于渲染 XML&#x2F;XHTML&#x2F;HTML5 内容的&#x3D;&#x3D;模板引擎&#x3D;&#x3D;。它与 JSP，Velocity，FreeMaker 等模板引擎类似，也可以轻易地与 Spring MVC 等 Web 框架集成。与其它模板引擎相比，Thymeleaf 最大的特点是，即使不启动 Web 应用，也可以直接在浏览器中打开并正确显示模板页面 。\nThymeleaf 通过在 html 标签中，**&#x3D;&#x3D;增加额外属性来达到“模板+数据”的展示方式&#x3D;&#x3D;**\nThymeleaf 的特点Thymeleaf 模板引擎具有以下特点：\n\n动静结合：Thymeleaf 既可以直接使用浏览器打开，查看页面的静态效果，也可以通过 Web 应用程序进行访问，查看动态页面效果。\n开箱即用：Thymeleaf 提供了 Spring 标准方言以及一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。\n多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。\n与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了默认配置，并且还为 Thymeleaf 设置了视图解析器，因此 Thymeleaf 可以与 Spring Boot 完美整合。\n\nThymeleaf 语法规则在使用 Thymeleaf 之前，首先要在页面的 html 标签中声明名称空间\nxmlns:th=&quot;http://www.thymeleaf.org&quot;\n\n在 html 标签中声明此名称空间，可避免编辑器出现 html 验证错误，但这一步并非必须进行的，&#x3D;&#x3D;即使我们不声明该命名空间，也不影响 Thymeleaf 的使用&#x3D;&#x3D;。\nThymeleaf 作为一种模板引擎，它拥有自己的语法规则。Thymeleaf 语法分为以下 2 类：\n\n标准表达式语法\nth 属性\n\n标准表达式语法Thymeleaf 模板引擎支持多种表达式：\n\n变量表达式：${…}\n选择变量表达式：{…}*\n链接表达式：@{…}\n国际化表达式：#{…}\n片段引用表达式：~{…}\n\n变量表达式使用 ${} 包裹的表达式被称为变量表达式，该表达式具有以下功能：\n\n获取对象的属性和方法\n$&#123;person.lastName&#125;\n\n使用**内置的基本对象**\n使用内置基本对象，获取内置对象的属性，调用内置对象的方法\n$&#123;#session.getAttribute(&#x27;map&#x27;)&#125;$&#123;session.map&#125;\n\n使用**内置的工具对象**\nstrings、numbers、bools、arrays、lists&#x2F;sets、maps、dates\n$&#123;#strings.equals(&#x27;编程帮&#x27;,name)&#125;\n\n选择变量表达式选择变量表达式与变量表达式功能基本一致，只是在变量表达式的基础上增加了与 th:object 的配合使用。当使用 th:object &#x3D;&#x3D;存储&#x3D;&#x3D;一个对象后，我们可以在其后代中使用选择变量表达式（*{…}）获取该对象中的属性，其中，星号即代表该对象。\n&lt;div th:object=&quot;$&#123;session.user&#125;&quot; &gt;    &lt;p th:text=&quot;*&#123;fisrtName&#125;&quot;&gt;firstname&lt;/p&gt;&lt;/div&gt;\n\nth:object 用于存储一个临时变量，该变量只在该标签及其后代中有效\n链接表达式不管是静态资源的引用，还是 form 表单的请求，凡是&#x3D;&#x3D;链接&#x3D;&#x3D;都可以用链接表达式 （@{…}）。\n链接表达式的形式结构如下：\n\n无参请求：@{&#x2F;xxx}\n有参请求：@{&#x2F;xxx(k1&#x3D;v1,k2&#x3D;v2)}\n\n例如使用链接表达式引入 css 样式表\n&lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;\n\n\n\n片段引用表达式&#x3D;&#x3D;用来模板化开发页面&#x3D;&#x3D;\n片段引用表达式用于在模板页面中引用其他的模板片段，该表达式支持以下 2 种语法结构：\n\n推荐：~{templatename::fragmentname}\n支持：~{templatename::#id}\n\n以上语法结构说明如下：\n\ntemplatename：模版名，Thymeleaf 会根据模版名解析完整路径：&#x2F;resources&#x2F;templates&#x2F;templatename.html，要注意文件的路径。\nfragmentname：片段名，Thymeleaf 通过 &#x3D;&#x3D;th:fragment 声明定义代码块&#x3D;&#x3D;，即：th:fragment&#x3D;”fragmentname”\nid：HTML 的 id 选择器，使用时要在前面加上 # 号，不支持 class 选择器。\n\nThymeleaf 公共页面抽取在 Web 项目中，通常会存在一些公共页面片段（重复代码），例如头部导航栏、侧边菜单栏和公共的 js css 等。我们一般会把这些公共页面片段抽取出来，存放在一个独立的页面中，然后再由其他页面根据需要进行引用，这样可以消除代码重复，使页面更加简洁。\n1 抽取公共页面Thymeleaf 作为一种优雅且高度可维护的模板引擎，同样支持公共页面的抽取和引用。我们可以将公共页面片段抽取出来，存放到一个独立的页面中，并使用 Thymeleaf 提供的 th:fragment 属性为这些抽取出来的公共页面片段命名。\n将公共页面片段抽取出来，存放在 commons.html 中，代码如下。\n纯文本复制&lt;div th:fragment=&quot;fragment-name&quot; id=&quot;fragment-id&quot;&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;\n\n\n\n2 引用公共页面在 Thymeleaf 中，我们可以使用以下 3 个属性，将公共页面片段引入到当前页面中。\n\nth:insert：将代码块片段整个插入到使用了 th:insert 属性的 HTML 标签中；\nth:replace：将代码块片段整个替换使用了 th:replace 属性的 HTML 标签中；\nth:include：将代码块片段包含的内容插入到使用了 th:include 属性的 HTML 标签中。\n\n使用上 3 个属性引入页面片段，都可以通过以下 2 种方式实现。\n\n~{templatename::selector}：模板名::选择器\n~{templatename::fragmentname}：模板名::片段名\n\n通常情况下，~&#123;&#125; 可以省略，其行内写法为 [[~&#123;...&#125;]] 或 [(~&#123;...&#125;)]，其中  [[~&#123;...&#125;]] 会转义特殊字符，[(~&#123;...&#125;)] 则不会转义特殊字符。\n\n\n\n 在页面 fragment.html 中引入 commons.html 中声明的页面片段，可以通过以下方式实现。\n&lt;!--th:insert 片段名引入--&gt;&lt;div th:insert=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div th:insert=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div th:replace=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div th:replace=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div th:include=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div th:include=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;\n\n\n\n3 传递参数Thymeleaf 在抽取和引入公共页面片段时，还可以进行参数传递，大致步骤如下：\n\n传入参数；\n使用参数。\n\n传入参数\n引用公共页面片段时，我们可以通过以下 2 种方式，将参数传入到被引用的页面片段中：\n\n模板名::选择器名或片段名(参数1&#x3D;参数值1,参数2&#x3D;参数值2)\n模板名::选择器名或片段名(参数值1,参数值2)\n\n注：\n\n若传入参数较少时，一般采用第二种方式，直接将参数值传入页面片段中；\n若参数较多时，建议使用第一种方式，明确指定参数名和参数值。\n\n&lt;!--th:insert 片段名引入--&gt;&lt;div th:insert=&quot;commons::fragment-name(var1=&#x27;insert-name&#x27;,var2=&#x27;insert-name2&#x27;)&quot;&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div th:insert=&quot;commons::#fragment-id(var1=&#x27;insert-id&#x27;,var2=&#x27;insert-id2&#x27;)&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div th:replace=&quot;commons::fragment-name(var1=&#x27;replace-name&#x27;,var2=&#x27;replace-name2&#x27;)&quot;&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div th:replace=&quot;commons::#fragment-id(var1=&#x27;replace-id&#x27;,var2=&#x27;replace-id2&#x27;)&quot;&gt;&lt;/div&gt;\n\n\n\n 使用参数\n在声明页面片段时，我们可以在片段中声明并使用这些参数，例如：\n&lt;!--使用 var1 和 var2 声明传入的参数，并在该片段中直接使用这些参数 --&gt;&lt;div th:fragment=&quot;fragment-name(var1,var2)&quot; id=&quot;fragment-id&quot;&gt;    &lt;p th:text=&quot;&#x27;参数1:&#x27;+$&#123;var1&#125; + &#x27;-------------------参数2:&#x27; + $&#123;var2&#125;&quot;&gt;...&lt;/p&gt;&lt;/div&gt;\n\n​\t\n整合ThymeleafSpring Boot 推荐使用 Thymeleaf 作为其模板引擎。SpringBoot 为 Thymeleaf 提供了一系列默认配置，项目中一但导入了 Thymeleaf 的依赖，相对应的自动配置 （ThymeleafAutoConfiguration） 就会自动生效，因此 Thymeleaf 可以与 Spring Boot 完美整合 。\nSpring Boot 整合 Thymeleaf 模板引擎，需要以下步骤：\n\n引入 Starter 依赖\n创建模板文件，并放在在指定目录下\n\n引入依赖：\nSpring Boot 整合 Thymeleaf 的第一步，就是在项目的 pom.xml 中添加 Thymeleaf 的 Starter 依赖，代码如下。\n&lt;!--Thymeleaf 启动器--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n创建模板文件:\nSpring Boot 通过 ThymeleafAutoConfiguration 自动配置类对 Thymeleaf 提供了一整套的自动化配置方案。\nThymeleafAutoConfiguration 使用 @EnableConfigurationProperties 注解导入了 ThymeleafProperties 类，该类包含了与 Thymeleaf 相关的自动配置属性\nThymeleafProperties 通过 @ConfigurationProperties 注解将配置文件（application.properties&#x2F;yml） 中前缀为 spring.thymeleaf 的配置和这个类中的属性绑定。\nThymeleaf 模板的默认位置在 resources&#x2F;templates 目录下，默认的后缀是 html，即只要将 HTML 页面放在“classpath:&#x2F;templates&#x2F;”下，Thymeleaf 就能自动进行渲染。\n与 Spring Boot 其他自定义配置一样，我们可以在 application.properties&#x2F;yml 中修改以 spring.thymeleaf 开始的属性，以实现修改 Spring Boot 对 Thymeleaf 的自动配置的目的。\n定制Spring MVCSpring Boot 抛弃了传统 xml 配置文件，通过&#x3D;&#x3D;配置类&#x3D;&#x3D;（标注 @Configuration 的类，相当于一个 xml 配置文件）以 JavaBean 形式进行相关配置。\nSpring Boot 对 Spring MVC 的自动配置可以满足我们的大部分需求，但是我们也可以通过自定义配置类（标注 @Configuration 的类）并**&#x3D;&#x3D;实现 WebMvcConfigurer 接口&#x3D;&#x3D;**来定制 Spring MVC 配置，例如拦截器、格式化程序、视图控制器等等。\nWebMvcConfigurer 是一个基于 Java 8 的接口，该接口定义了许多与 Spring MVC 相关的方法，其中大部分方法都是 default 类型的，且都是空实现。因此我们只需要定义一个配置类实现 WebMvcConfigurer 接口，并重写相应的方法便可以定制 Spring MVC 的配置。\n\n\n\n方法\n说明\n\n\n\ndefault void addResourceHandlers(ResourceHandlerRegistry registry) {}\n添加或修改静态资源（例如图片，js，css 等）映射； Spring Boot 默认设置的静态资源文件夹就是通过重写该方法设置的。\n\n\ndefault void addViewControllers(ViewControllerRegistry registry) {}\n主要用于实现无业务逻辑跳转，例如主页跳转，简单的请求重定向，错误页跳转等\n\n\ndefault void configureViewResolvers(ViewResolverRegistry registry) {}\n配置视图解析器，将 Controller 返回的字符串（视图名称），转换为具体的视图进行渲染。\n\n\ndefault void configureAsyncSupport(AsyncSupportConfigurer configurer) {}\n处理异步请求。\n\n\ndefault void addInterceptors(InterceptorRegistry registry) {}\n添加 Spring MVC 生命周期拦截器，对请求进行拦截处理。\n\n\n在 Spring Boot 项目中，我们可以通过以下 2 中形式定制 Spring MVC:\n\n扩展 Spring MVC\n全面接管 Spring MVC\n\n&#x3D;&#x3D;扩展&#x3D;&#x3D; Spring MVC如果 Spring Boot 对 Spring MVC 的自动配置不能满足我们的需要，我们还可以通过自定义一个 WebMvcConfigurer 类型（实现 WebMvcConfigurer 接口）的配置类（标注 @Configuration，但&#x3D;&#x3D;不标注 @EnableWebMvc&#x3D;&#x3D; 注解的类），来扩展 Spring MVC。这样不但能够保留 Spring Boot 对 Spring MVC 的自动配置，享受 Spring Boot 自动配置带来的便利，还能额外增加自定义的 Spring MVC 配置。\n全面接管 Spring MVC在一些特殊情况下，我们可能需要抛弃 Spring Boot 对 Spring MVC 的全部自动配置，**完全接管** Spring MVC。此时我们可以自定义一个 WebMvcConfigurer 类型（实现 WebMvcConfigurer 接口）的配置类，并在该类上标注 &#x3D;&#x3D;@EnableWebMvc 注解&#x3D;&#x3D;，来实现**完全接管** Spring MVC。\n完全接管 Spring MVC 后，Spring Boot 对 Spring MVC 的自动配置将全部失效。\nSpring Boot 能够访问位于静态资源文件夹中的静态文件，这是在 Spring Boot 对 Spring MVC 的默认自动配置中定义的，当我们全面接管 Spring MVC 后，Spring Boot 对 Spring MVC 的默认配置都会失效，此时再访问静态资源文件夹中的静态资源就会报 404 错误。\n国际化拦截器我们对拦截器并不陌生，无论是 Struts 2 还是 Spring MVC 中都提供了拦截器功能，它可以根据 URL 对请求进行拦截，主要应用于&#x3D;&#x3D;登陆校验、权限验证、乱码解决、性能监控和异常处理&#x3D;&#x3D;等功能上。Spring Boot 同样提供了拦截器功能。 \n在 Spring Boot 项目中，使用拦截器功能通常需要以下 3 步：\n\n定义拦截器；\n注册拦截器；\n指定拦截规则（如果是拦截所有，静态资源也会被拦截）。\n\n定义拦截器在 Spring Boot 中定义拦截器十分的简单，只需要创建一个拦截器类，并实现 HandlerInterceptor 接口即可。\nHandlerInterceptor 接口中定义以下 3 个方法，如下表。\n\n\n\n返回值类型\n方法声明\n描述\n\n\n\nboolean\npreHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n该方法在控制器**&#x3D;&#x3D;处理请求方法前执行&#x3D;&#x3D;，其返回值表示是否中断后续操作**，返回 true 表示继续向下执行，返回 false 表示中断后续操作。\n\n\nvoid\npostHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)\n该方法在控制器处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步修改。\n\n\nvoid\nafterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n该方法在视图渲染结束后执行，可以通过此方法实现资源清理、记录日志信息等工作。\n\n\n一般登录校验、权限验证用第一个方法比较多，也足够了。\n注册拦截器在配置类中，重写 addInterceptors() 方法，并在该方法中调用 registry.addInterceptor() 方法将自定义的拦截器注册到容器中。\n指定拦截规则修改 MyMvcConfig 配置类中 addInterceptors() 方法的代码，继续指定拦截器的拦截规则。\n在指定拦截器拦截规则时，调用了两个方法，这两个方法的说明如下：\n\naddPathPatterns：该方法用于指定拦截路径，例如拦截路径为“&#x2F;**”，表示拦截所有请求，包括对静态资源的请求。\nexcludePathPatterns：该方法用于排除拦截路径，即指定不需要被拦截器拦截的请求。\n\n实现登录功能\n默认异常处理全局异常处理","categories":["框架"],"tags":["spring"]},{"title":"java数据结构","url":"/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"PriorityQueue 优先队列可以对其中的元素进行排序，数据类型可以是基本数据类型的包装（如Integer、Long等）或自定义的类。\n对于基本数据类型的包装器类，优先队列中元素默认排列顺序是升序排列。\n默认比较器下堆顶的是最小的元素（即小顶堆）。\n但对于自己定义的类来说，需要自己定义比较器。\nJava 使用 PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)) 可方便实现大顶堆。\n常用方法：\npeek()//返回队首元素poll()//返回队首元素，队首元素出队列add()//添加元素size()//返回队列元素个数isEmpty()//判断队列是否为空，为空返回true,不空返回false\n\n遍历：\nPriorityQueue的iterator（）不保证以任何特定顺序遍历队列元素。\n若想按特定顺序遍历，先将队列转成数组，然后排序遍历。\nObject[] nn = queue.toArray();Arrays.sort(nn);\n\n使用优先队列的难点在于创建比较器\nComparator&lt;Object&gt; cmp = new Comparator&lt;Object&gt;() &#123;       public int compare(Object o1, Object o2) &#123;           //升序           return o1-o2;           //降序           return o2-o1;       &#125;   &#125;;\n\n\n\nLinkedList 链表LinkedList是一种常用的数据容器，与ArrayList相比，LinkedList的增删操作效率更高，而查改操作效率较低。\nLinkedList 实现了List 接口，能对它进行列表操作。\nLinkedList 实现了Deque 接口，即能将LinkedList当作双端队列使用。\nLinkedList 实现了java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。\n常用方法：\nadd();\nremove();\nget();\nStack栈现在使用栈，更多是用Deque\nStack&lt;泛型&gt; stack = new Stack&lt;&gt;();\n\n常用方法：\npush();\npop();\npeek();\nQueue队列Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();\n\n常用方法：\noffer();\n查询第一个元素：\nelement();\t在队列为空时，返回一个异常\npeek();\t\t\t在队列为空时，返回null\n取出第一个元素：\nremove();\t\t在队列为空时抛出异常\npoll();\t\t\t\t在队列为空时返回一个null\nHashSetHashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。\nHashSet 允许有 null 值。\nHashSet 是无序的，即不会记录插入的顺序。\nHashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。\nHashSet 实现了 Set 接口。\n常用方法：\nadd()；\ncontains() \n remove() \nclear();\nsize()\nHashMapHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。\nHashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。\nHashMap 是无序的，即不会记录插入的顺序。\nHashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。\n常用方法：\n\nhttps://www.runoob.com/java/java-hashmap.html\n\nput()\nget(key）\nremove(key)\nclear()\nsize() \ncontainsKey()\ncontainsValue()\nSet和List的区别\nSet 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。\nSet检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。\nList和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。\n\n双端队列Deque：Deque可以用来实现双端队列、队列、堆栈\n\nStringBuilder：当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。\n在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。\nStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。\n 在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。\n对于String与其他类型之间的类型互转：int -&gt; String    str &#x3D; String.valueOf(int num)\n","categories":["数据结构"],"tags":["java"]},{"title":"一些随笔","url":"/%E4%B8%80%E4%BA%9B%E9%9A%8F%E7%AC%94/","content":"面试高频：\nMysql引擎\nInnoDB底层原理\n索引\n索引优化\n\n配置Spring&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.3.9&lt;/version&gt;&lt;/dependency&gt;\n\n或者通过springframe的官方文档,复制其maven配置\n链接\nSpring配置bean.xml（下面配置包含了对注解使用的支持）\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;&lt;/beans&gt;\n\n\n\n实例化容器ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);Hello hello = (Hello) context.getBean(&quot;hello&quot;)\n\n\n\n配置命名空间（用于di）xml约束：\nxmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;\n\n\n\nMybatis配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;\n\n\n\n乱码过滤器import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter &#123;   @Override   public void destroy() &#123;  &#125;   @Override   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;       //处理response的字符编码       HttpServletResponse myResponse=(HttpServletResponse) response;       myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);       // 转型为与协议相关对象       HttpServletRequest httpServletRequest = (HttpServletRequest) request;       // 对request包装增强       HttpServletRequest myrequest = new MyRequest(httpServletRequest);       chain.doFilter(myrequest, response);  &#125;   @Override   public void init(FilterConfig filterConfig) throws ServletException &#123;  &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123;   private HttpServletRequest request;   //是否编码的标记   private boolean hasEncode;   //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰   public MyRequest(HttpServletRequest request) &#123;       super(request);// super必须写       this.request = request;  &#125;   // 对需要增强方法 进行覆盖   @Override   public Map getParameterMap() &#123;       // 先获得请求方式       String method = request.getMethod();       if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;           // post请求           try &#123;               // 处理post乱码               request.setCharacterEncoding(&quot;utf-8&quot;);               return request.getParameterMap();          &#125; catch (UnsupportedEncodingException e) &#123;               e.printStackTrace();          &#125;      &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;           // get请求           Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();           if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次               for (String parameterName : parameterMap.keySet()) &#123;                   String[] values = parameterMap.get(parameterName);                   if (values != null) &#123;                       for (int i = 0; i &lt; values.length; i++) &#123;                           try &#123;                               // 处理get乱码                               values[i] = new String(values[i]                                      .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);                          &#125; catch (UnsupportedEncodingException e) &#123;                               e.printStackTrace();                          &#125;                      &#125;                  &#125;              &#125;               hasEncode = true;          &#125;           return parameterMap;      &#125;       return super.getParameterMap();  &#125;   //取一个值   @Override   public String getParameter(String name) &#123;       Map&lt;String, String[]&gt; parameterMap = getParameterMap();       String[] values = parameterMap.get(name);       if (values == null) &#123;           return null;      &#125;       return values[0]; // 取回参数的第一个值  &#125;   //取所有值   @Override   public String[] getParameterValues(String name) &#123;       Map&lt;String, String[]&gt; parameterMap = getParameterMap();       String[] values = parameterMap.get(name);       return values;  &#125;&#125;\n\n"},{"title":"人机交互复习","url":"/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E5%A4%8D%E4%B9%A0/","content":"第一二章 人机交互基础知识重点：\n\n不同交互范型\n用户特性\n设备特性\n人机交互框架\n\n人机交互主要目的：\n尊重用户的角度来改善用户和计算机之间的交互，从而使计算机系统更加容易使用。\n认知隔阂：\n\n以机械技术为主要的产品。如机械闹钟、车子（开车难学）\n以电子信息为主的产品。手机、计算机\n\nEEC模型\n\n交互范型:\n\n命令行交互\n\n节约系统资源、操作精确、快速完成任务\n要求掌握命令，对用户不友好、基于回忆的方式、出错频率高\n\n\n菜单驱动界面：以一组层次化菜单的方式提供用户可用的功能选项\n\n通过鼠标键盘选择\n对用户友好、容易纠错\n导航不够灵活、占用屏幕空间、对专家用户效率不高\n\n\n基于表格的界面（用来显示的表格或者用来输入的表格）\n\n直接操纵：\n\n自由阶段——指用户执行操作前的屏幕视图；\n\n捕获阶段——在用户动作（点击、点击拖拽等）执行过程中屏幕的显示情况；\n\n终止阶段——用户动作执行后屏幕的显示情况。\n\n\n\n问答界面（Web问卷）\n\n隐喻界面（回收站的垃圾桶UI）\n\n\n\n**WIMP：Windows、Icon、Menu、Pointer**，图形界面电脑所采用的界面典范\n自然交互【用户特性】狭义的自然交互是指基于自然用户界面的人机交互，采用语音、动作、手势，甚至人的面部表情等来操作和控制计算机用户的交互方式。旨在提高人机交互的自然性和高效性。\n广义的人机交互泛指用户产品之间的交互行为均符合人类的行为习惯，反映了用户和产品之间的一种自然化的交互趋势。在理想情况下，产品将是一个有生命的智慧物，人的所作所为能被产品理解，并能做出判断和决策。\n产品的交互方式应该以更快捷直接的方式适应用户的需求，而不是人去适应产品。\n体感交互：全身动捕\n触觉反馈：虚拟现实手柄\n触觉交互：触摸屏\n眼球追踪、手势跟踪（深度摄像头、数据手套）\n语音交互：语音助手\n适用物理场景语音交互需要用户能听和说；\n触控交互需要用户和设备接触；\n手势交互需要用户的手能自由移动。\n用户并不总是具备以上的交互条件。\n交互效率空间触控交互是需要某种实体承载的，用户必须要接触到设备才能发出指令。\n手势交互和语音交互则在空间上更为自由，不需要用户亲身接触到设备。\n交互效率时间当触控设备就在手边，触控操作需要的时间可能是三种交互方式中最短的。\n语音交互需要唤醒时间。唤醒交互可能是只能语音产品的痛点之一，虽然它也作为卖点。\n交互效率 指令识别的准确性在识别指令方面，触控交互的准确性是最高的。\n【设备特性】评估设备的原则：\n\n学习成本\n隐私性\n情感互动\n情感交互\n\n信息处理模型：\n\n扩展\n\n相近性原则：空间上比较靠近的物体容易被视为整体。设计界面时，应按照相关性对组件进行分组\n相似性原则：人们习惯将看上去相似的物体看成一个整体 。功能相近的组件应该使用相同或相近的表现形式\n连续性原则：共线或具有相同方向的物体会被组合在一起 。将组件对齐，更有助于增强用户的主观感知效果\n完整和闭合性原则：人们倾向于忽视轮廓的间隙而将其视作一个完整的整体 。页面上的空白可帮助实现分组\n人机处理模型【人机交互模型】感知处理器\t认知处理器\t动作处理器\n视错觉知觉感受的扭曲\n\n前后景互换实际上就是视错觉的一种\n白色三角的例子\n\n视错觉是不可避免的，幻觉是可以避免的\n启示：对于物体的视觉感受与物体所处的上下文密切相关。\n交互设备：\n文本输入设备：键盘\n定位设备：鼠标、触摸板、触摸屏、光笔\n图像输入设备：扫描仪、数码相机、传真机\n显示设备：液晶显示屏、等离子体显示器、发光二极管\n虚拟环境下的交互设备：VR眼镜、手柄\n交互设计的目标与原则易学性：系统应当容易学习，从而用户可以在较短时间内采用系统完成某些任务\n易记性：用户在学会使用软件之后应当容易记忆，能够迅速回想起他的使用方法\n主观满意度：用户对系统的主观喜爱程度，某种情况下，系统的娱乐价值比完成任务的速度更重要。\n高效率、少出错\n第三章 交互设计目标与原则重点：\n\n设计目标\n可用性目标\n用户体验目标\n\n\n简易可用性工程\n可用性属性的度量\n四项关键技术【？】\n\n\n设计原则\n一般原则\n黄金规则\n启发式规则\n\n\n\n可用性目标\n易学性：系统应当容易学习，从而用户可以在较短时间内应用系统来完成某些任务【最基本】\n易记性：学会某个系统后，应能够迅速回想起它的使用方法\n少出错：减少出错评率、保证出错后迅速回到正常状态\n高效率：用户可以借助产品发挥出更高的生产力\n主观满意度：用户对系统的主观喜爱程度，系统的娱乐价值\n\n用户体验目标：设计规则：\n\n可学习性\n\n\n\n灵活性\n\n\n\n健壮性\n\n\n黄金规则\n尽可能保证一致 \n符合普遍可用性\n提供信息丰富的反馈\n设计说明对话框以生成结束信息\n预防并处理错误\n让操作容易撤销\n支持内部控制点\n减轻短时记忆负担\n\n十项启发式规则\n系统状态的可见度\n系统和现实世界的吻合\n用户享有控制权和自主权\n一致性和标准化\n避免出错\n依赖识别而非记忆\n使用的灵活性和高效性\n审美感和最小化设计\n帮助用户识别、诊断和恢复错误\n帮助和文档\n\n简易可用性工程可用性度量：\n\n通过执行任务测试系统，然后打分\n度量一定要针对特定的用户和特定的任务进行\n要明确一组具有代表性的测试任务\n\n易学性度量：找一些从未使用过系统的用户，统计他们学习使用系统直至达到某种熟练程度的时间\n使用效率度量：不是所有用户都能够迅速达到最终的绩效水平，区分不同的用户群体 ，先使用，然后度量其绩效水平，为用户绘制学习曲线，绩效水平在一段时间内不再提高时，就认为已经达到了该用户的稳定绩效水平 \n易记性度量：\n\n用户分类：\n\n新手用户，熟练用户，非频繁使用用户\n对非频繁使用用户进行测试最能体现系统的易记性\n\n\n度量方法：\n\n记录下这些用户执行特定任务所用的时间\n对用户进行记忆测试 ，在执行任务后，让用户解释各种命令的作用\n\n\n\n错误率度量：\n\n在用户执行特定任务时通过统计这种操作的次数\n可以在度量其他可用性属性的同时来度量\n\n满意度度量：\n\n满意度度量评价都是主观的 \n以询问用户的方式进行度量更合适\n把多个用户的结果综合起来取其平均值\n\n\n一定要在用户使用系统执行真实的任务之后再来询问他们的看法\n\n第四章 交互设计过程交互设计的基本活动\n\n标识用户需要并建立需求。\n开发满足需求的候选设计方案。\n构建设计的交互式版本，以便进行测试和评估。\n评估设计。\n\n交互设计过程的三个关键特征\n\n以用户为中心\n稳定的可用性标准\n迭代设计\n\n第五章 人机交互的软件工程方法重点：\n\n需求\n原型\n用户\n产品\n\n无论取代或更新已有系统，还是开发新产品，需求的建立都是非常重要的\n需求获取是项目设计的第一个阶段\n产品是不同的（对需求提出了特殊的要求）\n用户是不同的\n需求：\n关于目标产品的一种陈述，它指定了产品应做什么，或者应如何工作 \n应该是具体、明确和无歧义的\n\n目标：理解用户，从用户需要中提炼出一组稳定的需求作为后续设计的基础\n活动：\n\n搜集数据\n解释数据\n提取需求\n\n获取需求：观察、（应用）场景\n\n直接观察——在身边观察\n间接观察——通过视频、录音\n\n定义需求的五个步骤：\n\n创建问题和前景综述\n头脑风暴\n确定人物角色的期望\n构建情境场景剧本\n确立需求\n\n验证需求：通过原型来验证需求是否被满足，是否还有新的需求。\n原型是什么？——  一种接近于实际产品的模型 \n有啥用？——借助于原型，当事人就能与未来的产品交互，从中获得一些实际的使用体验，并发掘新思路 \n重要性：\n\n用户往往不能准确描述自己的需要\n用户在看到或尝试某些事物后，就能立即知道自己不需要什么\n\n分类：\n\n低保真——与最终产品不太相似的原型，不同材料，易于制作和修改\n高保真——与最终产品更为接近，使用相同的材料\n\n基本原型：图纸（在纸上）、位图（绘图工具）、可执行文件（交互式）\n产品特性：功能不同、物理条件不同、使用环境不同\n用户特性：\n\n心理学原理适用大多数人\n产品设计人员应该知道用户之间有差异\n用户差异：体验水平、年龄、文化、健康？\n\n体验水平差异：\n数目最多、最稳定和最重要的用户群是中间用户 ，中间用户往往被忽略\n设计目标：\n\n让新手快速和无痛苦地成为中间用户\n避免为想成为专家的用户设置障碍\n让中间用户感到愉快\n\n用户建模：\n是在人口统计学调查收集到的实际用户的行为数据的基础上形成的综合原型 \n作用是解决产品开发过程中出现的3个设计问题：\n\n弹性用户 （根据自己的意愿编码，而仍然能够为“用户”服务）\n自参考设计（开发人员将其自己的目标、动机、技巧及心智模型投射到产品的设计中 ）\n边缘情况设计\n\n建模过程：\n\n拼凑，零碎概念或模型的片段\n直至，片段按照所构造模型的需要进行分组和分类，删除冗余\n细节，完善相应描述，补充遗漏的数据 \n求精，对模型进行推敲，以便改进和完善\n\n第六章 人机交互系统的设计设计框架——屏幕布局、产品的工作流、行为和组织\t\n步骤：\n定义外形因素和输入方法\n外形因素——web应用？手机产品？\n产品输入方法——互动的形式\n\n定义功能和数据元素\n\n决定功能组合层次\n\n勾画大致的设计框架 \n\n构建关键情景场景剧本——描述了人物角色如何同产品交互\n\n通过验证性的场景剧本来检查设计\n\n\n简化设计的四个策略：\n\n删除——最明显的简化设计方法，关注核心，删除冗余\n组织——最快捷的简化设计方式、分块，根据行为划分组织\n隐藏——隐藏是一种低成本的简化方案\n转移\n\n删除不必要的、组织要提供的、隐藏非核心的\n软件设计细节设计体贴的软件\n\n加快系统的响应时间\n减轻用户的记忆负担 \n减少用户的等待感\n设计好的出错信息\n\n设计中的折中\n\n个性化、配置\n本地化和国际化\n审美学与实用性\n\n交互设计模式，如向导模式\n模式：某个情形下某个问题的解决方案\n【作业】完成产品的关键界面原型         【第六章课件 P88】\n给定关键任务、要求写出执行路径、给出关键页面原型\n第七章 可视化设计主要内容：\n\n窗口和菜单 \n对话框 \n常用控件 \n工具栏 \n屏幕复杂性度量 \n用户界面设计原理\n\n窗口源于Xerox Alto系统，后被融入Apple操作系统和Windows操作系统\n状态：最大化、最小化、还原\n\n平铺：允许拖放操作\n重叠窗口：有效利用屏幕空间\n层叠窗口：可视化组织各窗口\n\n类型：\n\n多文档界面（如PS）\n单文档界面（如Word、WPS）\n标签文档界面（如浏览器界面）\n\n菜单访问系统功能的工具，已经成为窗口环境的标准特征\n\n菜单栏\n所有菜单必备\n菜单栏是代表下拉式菜单的菜单\n选项的标签、位置、归类等均已标准化\n\n\n注意事项：\n按语义及任务结构来组织菜单\n合理组织菜单接口的结构与层次 \n名字应符合日常命名习惯\n选项列表即可以是有序的也可以是无序的\n\n\n\n对话框典型的辅助性窗口\n分为模态对话框和非模态对话框。\n\n模态对话框\n\n冻结了它属于的应用，禁止用户做其他操作，直到处理了对话框中出现的问题\n可以切换到其他程序进行操作\n最容易理解，操作非常清晰\n\n\n应用模态——只暂停所属的应用程序\n\n系统模态——系统中所有程序都被暂停。大多数情况下，应用程序不应该有系统模态对话框。\n\n非模态对话框\n\n无须停止进度，应用程序也不会冻结\n由于其操作范围不确定而难以使用和理解\n如：Word的查找和替换对话框、画图程序\n存在的问题：缺乏一致的终止命令\n\n\n属性对话框：\n\n展示对象的属性或者设置，并允许用户改变\n模态、非模态均可\n\n\n功能对话框：（如：打印对话框）\n\n控制单个功能，如打印、拼写检查等\n允许用户开始一个动作，并允许设置动作的细节\n\n\n进度对话框\n\n由程序启动，而不是根据用户请求启动（无法由用户调用出来）\n进度表应表明相对整个过程所耗费时间的进度，而不是相对整个过程规模的进度(显示还需要多少时间)\n\n\n公告对话框\n\nGUI中滥用最多的元素\n无须请求，由程序直接启动\n阻塞型公告（错误、警告） VS. 临时公告\n\n\n错误对话框——用户希望避免发生错误，而不是受到错误信息\n\n警告对话框——用来通知用户，用户可以忽略\n\n确认对话框——程序对自己的行为不自信，用对话框来征求许可\n\n标签对话框——充斥大量控制程序组件的标签，如windows的系统设置，勾选打开或关闭\n\n扩展对话框——让用户自行选择是否扩展对话框以对更多东西进行控制。（如：高级选项）\n\n级联对话框——在对话框中嵌套其他的对话框\n\n\n**对话框设计原则**：\n\n把主要的交互操作放在主窗口中\n视觉上区分模态与非模态对话框\n不要用临时对话框作为错误信息框或确认信息框\n不要堆叠标签\n\n控件是什么？——用户和数字产品进行交流的屏幕对象\n命令控件——接收操作并立即执行，如按钮\n选择控件——允许用户从一组有效的选项中选择一个操作数，还能用来设定操作（如：下拉列表选择）\n\n复选框：一堆属性供勾选\n列表框：将可供选择的选项放在下拉列表\n\n显示控件：显示和管理屏幕上信息的视觉显示方式（如：滚动条）\n输入控件——让用户可以输入新的信息，而不仅仅是从列表中选择。\n\n有界输入控件（如滑动条——亮度、音量）\n无界输入控件（如文本输入）\n\n工具栏\n微软第一个将其引入用户界面\n工具栏 VS. 菜单\n都提供对程序功能的访问\n菜单提供完整的工具集，主要用于教学；工具栏是为常用命令设置的\n多用图标作为icon，鼠标悬浮会有气泡提示按钮名字或者功能。\n\n\n\n屏幕复杂性度量\n布局复杂度 \n根据可视对象的大小和位置来衡量\n可视对象在高度和宽度上经常改变,以及对象与可视交互环境边界之间的距离比较大的话，就可以说这个布局较复杂\n\n\n布局统一度 \n只对界面组成部分的空间排列进行衡量，不考虑其是什么干什么。\n以“视觉上无序的排列有碍于可用性”这一原理为基础 \n**排列越整齐，统一度越高。统一度介于50%-85%**之间是比较合理的。\n\n\n\n用户界面设计原理\n结构原理\n简单性原理 ——使简单常用的功能简便易行。\n可见性原理——让用户能看见他要用的东西。\n反馈原理——让用户能够清楚地接受到反馈信息，好的出错信息。\n宽容原理——帮助用户减少错误、适当的合法性检测。\n重用原理——界面之间合理的一致性，帮助用户记忆。\n\n第八章 交互设计模型与理论重点：\n\n预测模型\nGOMS\nFitts\n\n\n动态特性建模\n状态转移网\n三态模型\n\n\n语言模型\nBNF\n\n\n系统模型\nZ标记法\n\n\n\n预测模型能够预测用户的执行情况，但不需要对用户做实际测试\n特别适合于无法进行用户测试的情形\nGOMS模型\n最著名的预测模型，1983年提出，基于人类处理机模型 ，泛指整个GOMS模型体系\n是关于人类如何执行认知—动作型任务以及如何与系统交互的理论模型 \nGoal    Operation    Method    Selection-rules\n\n用户要达到的目的\n用户为了完成任务必须执行的基本动作\n为实现目标所需要的操作序列\n选择规则是用户要遵守的判定规则\n\nGOMS方法步骤：\n\n选出最高层的用户目标 \n写出具体的完成目标的方法\n写出子目标的方法\n子目标的关系 （顺序、选择）\n\n优点：可以分析不同的界面、系统，可以分析有效性。\n局限性：只针对专家用户 、任务之间的关系描述过于简单 、忽略了用户间的个体差异 。\nFitts定律\n用户访问屏幕组件的时间对于系统的使用效率是至关重要的 \n建议：\n\n大目标、小距离具有优势\n屏幕元素应该尽可能多的占据屏幕空间\n最好的像素是光标所处的像素\n屏幕元素应尽可能利用屏幕边缘的优势\n大菜单，如饼型菜单，比其他类型的菜单使用简单\n\n应用：\n\n缩短当前位置到目标区域的距离\n增大目标大小以缩短定位时间\n\n动态特性建模状态转移网\n用于描述用户和系统之间的对话\n最常用的状态转移网的形式——状态转移图\n三态模型\n帮助设计者为特定交互设计选择合适的I&#x2F;O设备\n无反馈运动（状态0）、跟踪运动（状态1）、拖动运动（状态2）\n鼠标\n跟踪状态（1）：左键抬起\n拖动状态（2）：左键按下\n无反馈状态（0）：把鼠标拿起来\n触摸板：\n无反馈状态（0）：手指不接触触摸板\n跟踪状态（1）：手指接触触摸板\n在没有其他组件配合的条件下触摸板没有状态2（**触摸板一般没有拖动**）\n完整交互建模\n通过拓展三态模型，可捕捉所有交互状态。\n语言模型BNF\nBNF语法常用于说明对话，目的在于理解用户的行为和分析认知界面的难度\n系统模型研究系统模型是为评估系统的可用性，需要知道系统做的是什么\nZ标记法：基于集合和函数\n函数：具有程序语言中标准计算的功能\n第九章以用户为中心把人置于系统设计过程的中心 、以用户为中心\n如何了解你的用户？\n沟通、观察、想象、。\n以用户为中心UCD：（UCD——user center design)\n\n及早以用户为中心 \n综合设计 \n及早并持续性地进行测试 \n迭代设计\n\nUCD方法：\n用户参与、问卷调查、观察、专家评估、可用性测试\n以活动为中心ACD：重点关注用户要做的事\nUCD的缺陷：\n\n影响创新，忽略人的主观能动性、对技术的适应能力。\n\n反思：早期设计以技术为中心，然后是UCD，ACD综合考虑了人和技术。\n第十章 评估的基础知识什么是评估？\n\n系统化的数据搜集过程\n目的是了解用户或用户组在特定环境中，使用产品执行特定任务的情况\n\n评估不是设计的某一个阶段，应该是一边开发一边评估。\n目的：\n\n评估系统功能的范围和可达性\n评估交互中用户的体验\n确定系统的某些特定问题\n\n原则：\n\n评估应该依赖于产品的用户\n评估与设计应结合进行\n评估应在用户的实际工作任务和操作环境下进行\n要选择有广泛代表性的用户\n\n评估范型：\n快速评估\n设计人员非正式地向用户或顾问了解反馈信息\n强调 “快速了解”，而非仔细记录研究发现\n\n\n可用性测试\n评测典型用户执行典型任务时的情况（出错次数、完成任务时间）\n基本特征——在评估人员的密切控制之下实行的 \n主要任务——量化表示用户的执行情况\n缺点——测试用户数量少，不适合进行细致的统计分析\n\n\n实地研究\n基本特征——在自然环境下进行\n目的——理解用户的实际工作情形以及技术对他们的影响\n作用——探索新技术、确定需求\n\n\n预测性评估 \n专家们根据自己对典型用户的了解（通常使用启发式过程）预测可用性问题\n基本特征——无需用户在场、过程快速成本较低\n典型的预测性评估方法——启发式评估\n\n\n\n评估技术：\n观察用户\n询问用户意见\n询问专家意见\n测试用户执行情况\n基于模型和理论，预测界面的有效性\n\n评估方法组合：启发式评估+用户测试技术、访谈（粗）+问卷调查（细）\nDecide评估框架\n决定评估需要完成的总体目标\n发掘需要回答的具体问题\n选择用于回答具体问题的评估范型和技术\n标识必须解决的实际问题，如测试用户的选择\n决定如何处理有关道德的问题\n评估解释并表示数据\n\n可用性问题分级\n基于量化数据的多少分级\n问题严重性的主观打分，取平均值\n可用性分级的两个因素\n多少用户会遇到这个问题\n用户受该问题影响的程度\n\n\n该问题只在第一次使用时出现，还是会永远出现\n\n第十一章 评估之观察用户重点：\n\n直接观察\n实验室观察\n现场观察\n\n\n间接观察\n日志和交互记录\n\n\n数据记录\n纸笔、音视频、日志和交互记录\n\n\n数据分析\n定性分析、定量分析\n\n\n\n观察可以发现一些意想不到的用户操作方式\n\n真实环境中的观察\n受控环境中的观察\n\n直接观察实验室观察\n在专门为可用性测试而安装配置的固定设备的环境下进行的观察，划分测试区、观察区\n\n测试地点选择，测试设备安装（记录用户行为）\n测试设备检查（确保设备正常运行）\n文档准备（协议书）\n能够使得研究人员更好地分离多个可能的影响因素，从而能够得出更准确的研究结果 \n观察者对被观察者的影响取决于观察类型和观察技巧\n\n现场观察：\n\n明确初步的研究目标和问题\n选择一个框架指导观察\n决定数据记录方式\n要注意区分个人意见和观察数据\n\n\n评估后，尽快与观察者或被观察者共同检查所记录的笔记和其他数据\n\n直接观察的观察框架：\n\nGoetz and Lecomfte框架\n人员、行为、时间、地点 、原因、方式。\n\nRobson框架\n空间、行为者、活动、物体、举止、事件、目标、感觉（情绪）\n\n\n观察中的问题\n\n不知道用户在想什么——让用户边做边说\n\n几个难题：\n\n要观察多久\n如何根据紧凑的开发期限和开发人员的技能相应修改现场研究技术 \n如何降低噪音、测试中断及其他易使注意力分散的外界干扰\n\n注意事项：\n\n观察人员自始至终应尽量保持安静 \n当用户的操作令观察人员无法理解时\n观察初期，应该拒绝用户的任何帮助请求\n\n步骤\n观察和访谈相结合\n观察只能知道用户做了什么，而不知道用户为什么要这么做\n应该在数据记录之后结合其他的方法\n避免让用户在数据记录是产生被监视的感觉\n\n\n数据记录\n根据研究人员的专业素质及环境、项目的特点来选取合适的方法 \n纸笔记录、音视频记录\n\n\n日志和交互记录\n其实就是间接观察用户\n直接观察可能会影响用户\n便于收集数据\n\n\n观察数据\n定性分析\n找出关键事件，如用户遇到困难的地方 \n内容分析\n会话分析\n话语分析\n\n\n定量分析\n录像记录时，当发现错误或异常操作时，观察的同时要对数据做标记和简短说明\n统计分析（平均值、标准差、T检验）\n\n\n\n第十二章 评估之询问用户和专家了解用户的需要和对产品的意见和建议——观察用户、询问用户、请教专家\n重点\n\n访谈\n问卷调查——与访谈的区别、何时选用\n认知走查——有哪些特点\n启发式评估——灵活运用\n\n访谈有目的的对话过程\n指导原则：（照顾用户心理感受，避免误导）\n\n避免过长的问题 \n避免使用复合句 \n避免使用可能让用户感觉尴尬的术语或他们无法理解的语言\n避免使用有诱导性的问题\n尽可能保证问题是中性的\n\n步骤：\n\n开始阶段\n访问人介绍自己\n阐述访谈详情。\n\n\n热身阶段\n先提出简单的问题\n\n\n主要访谈阶段\n由简到难提问\n\n\n冷却阶段\n问简单的问题，消除用户的紧张感\n\n\n结束访谈\n感谢受访者，收拾记录的数据。\n\n\n\n访谈类型\n\n非结构化访谈——不限定内容形式、受访人自行选择粗略、详细回答。\n\n结构化访谈——预先准备一组问题，要求准确的回答。\n\n半结构化访谈——开放式问题+封闭式问题。\n\n集体访谈——焦点小组\n\n\n焦点小组\n\n非正式的评估方法\n\n在界面设计之前和经过一段使用之后评估用户的需要和感受 \n是研究中的常用方法\n需要6-9个典型用户\n\n\n主持人工作\n\n事先列出一张讨论问题和数据收集目标的清单 \t\n保持所谈论的内容不离题\n保证小组的每个成员都积极参与谈论\n讨论结果的分析报告\n\n\n存在一定风险\n\n\n问卷调查问卷调查是用于搜集统计数据和用户意见的常用方法\n原则：\n\n应确保问题明确，具体\n在可能时，采用封闭式问题并提供充分的答案选项\n对于征求用户意见的问题，应提供一个“无看法”的答案选项（让用户自行输入）\n注意提问次序，先提出一般化问题，再提出具体问题\n\n两个关键问题：\n\n如何寻找有代表性的用户？\n如何达到合理的回复率？\n\n在线问卷调查\n能有效而方便地搜集大量人员的意见。\n可以基于电子邮件、可以基于网页。\n问卷调查和访谈的区别\n两者都属于间接方法，都不能完全听信用户的说法。\n访谈：更加自由、数据不确切、花费更多时间、立刻得到结果\n问卷调查：更有效方便、确切的数据、不能马上得到结果、需要时间统计分析。\n认知走查\n逐步检查使用系统执行任务的过程，从中找出可用性问题\n无需用户参与 \n认知走查的主要目标是确定使一个系统如何易于学习\n试图想象出人们在第一次使用某个产品时的想法以及所采取的动作，它的大致流程是怎样的 \n具体过程就是把用户在完成这个功能时所做的所有动作讲述成一个令人可以信服的故事\n\n步骤\n\n标识并记录典型用户的特性\n基于评估重点，设计样本任务\n制作界面原型（或界面描述），明确用户执行任务的具体步骤\n由设计人员和专家级评估人员（一位或多位）共同进行分析\n评估人员结合应用的上下文，逐步检查每项任务的操作步骤 \n在完成逐步检查之后，汇总关键信息 \n修改设计，更正发现的问题\n\n协作走查\n由用户、开发人员和可用性专家合作，逐步检查任务场景，讨论与对话元素相关的可用性问题 （专家也是用户）\n\n优点：专注于任务，获得定量数据。\n缺点：需要各方面专家，速度慢。时间限制，评估有限场景。\n\n启发式评估一种十分灵活而又廉价的评估方式，由专家模拟典型用户\n介绍、评估、总结\n优点：成本低、不涉及用户\n缺点：成为专家需要经过长时间的培训、可能出现“虚假警报”\n七项启发式原则：\n\n内部一致性——用户能明确所有措辞的含义\n对话的简单性——对话不应包含无关、不必要或极少用到的信息 \n快捷链接——适合无经验和有经验用户使用\n尽可能减轻用户的记忆负担——不应要求用户记忆先前的对话信息 \n预防错误——能够预防错误的发生\n提示信息——应能掌握系统的运行状态 \n内部控制——允许用户立即退出错误选择\n\n评估网站的原则\n\n&#x3D;&#x3D;导航&#x3D;&#x3D;\n保证在多个网页之间不会迷失\n避免使用孤立网页\n不应强迫用户滚屏\n提供浏览指引\n用标准颜色表示链接\n\n\n访问\n避免使用复杂的URL\n单个网页不要太大，让用户加载半天\n\n\n信息设计\n考虑内容的可理解性和美感\n\n\n\n"},{"title":"八股文-java基础","url":"/%E5%85%AB%E8%82%A1%E6%96%87-java%E5%9F%BA%E7%A1%80/","content":"\n\n1.Java基础1.1 为什么Java代码可以实现一次编写、到处运行？JVM是java代码能够跨平台运行的关键。在运行代码之前，java源代码会被编译器编译为字节码，字节码再被JVM转为机器码交由执行。相对于java源代码，JVM并不是跨平台的，它由c&#x2F;c++编写，不同的平台有着不同的版本。\n1.2 一个Java文件里可以有多个类吗（不含内部类）？可以。在一个java文件内可以编写多个类，但是只有一个类能够用public修饰，并且这个类需要和所在的java文件名同名。\n1.3 说一说你对Java访问权限的了解java提供了三种修饰符——public、protected、private。但在没有显式地写明修饰符时，其权限是default。\n对于成员变量、方法：\nprivate——类内部方法和变量可以访问\ndefault——类内部方法和变量可以访问，同一个包下的类可以访问\nprotected——类内部方法和变量可以访问，同一个包下的类可以访问，子类也可以访问。\npublic——任意包下的任意类都可以访问。\n对于类：default：同一个包下的类可以访问\npublic：任意包下的任意类\n1.4 介绍一下Java的数据类型java的数据类型可以分为：基本数据类型、引用数据类型。\n基本数据类型：\n\n整型：byte、short、int、long(8、16、32、64位)\n浮点型：float、double（32、64位）\n字符型：char（16位）\n布尔型：boolean（2位）\n\n按顺序，各个数据类型的占位分别是1248482\n在这8个基本类型当中，除了布尔类型之外的其他7个类型，都可以看做是数字类型，它们相互之间可以进行类型转换。\n引用数据类型：\n即对象的引用，一般是类、数组、接口。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。\n1.5 int类型的数据范围是多少？-2^31 ~ 2^31 - 1 \n1.6 请介绍全局变量和局部变量的区别全局变量：\n\n定义在类中\n有个默认的初始值\n被static修饰的是类变量，存储于方法区中，生命周期与当前类相同。\n不被static修饰的是实例变量，存储于对象所在的堆内存中，生命周期与对象相同；\n\n局部变量：\n\n定义在方法中\n没有初始化的默认值\n局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。\n\nJava中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。\n1.7 请介绍一下实例变量的默认值如果是引用类型数据，那么其默认值为null；\n如果是基本数据类型的默认值：\nbyte——0\nshort——0\nint——0\nlong——0L\nfloat——0.0f\ndouble——0.0\nchar——**’\\u0000’**\nboolean——false\n上述默认值规则适用于所有的成员变量，所以对于类变量也是适用的。\n1.8 为啥要有包装类？java的核心思想就是一切面向对象，但是八种基本数据类型却是例外，它们不具备对象的特性，为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。\n拓展：\nJava之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。\n1.9 说一说自动装箱、自动拆箱的应用场景自动装箱、自动拆箱是jdk1.5推出的功能。\n自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；\n自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；\n通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。\n1.10 如何对Integer和Double类型判断相等？可以转为相同类型的数据类型再通过&#x3D;&#x3D;判断是否相等\n不能直接判断是否相等的原因有：\n\n两种数据的类型不同\n不能转为String再比较，因为Double型数据有小数点，两者永远不可能相等\n也不能使用compareTo，因为二者类型不同\n\n整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用&#x3D;&#x3D;进行比较。\nInteger i = 100;Double d = 100.00;System.out.println(i.doubleValue() == d.doubleValue());\n\n\n\n1.11 int和Integer有什么区别，二者在做&#x3D;&#x3D;运算时会得到什么结果？int是基本数据类型，而Integer是包装类，二者类型不同。而在比较时，Integer类型的数据会被自动拆箱为int，然后两者进行比较，如果相等就会返回true，否则返回flase\n1.12 说一说你对面向对象的理解面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。\n1.13 面向对象的三大特征是什么？三大特征：封装、继承、多态\n封装：指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能\n继承：继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法\n多态：多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。\n1.14 封装的目的是什么，为什么要有封装？封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。\n这样做的好处是：\n\n隐藏类的实现细节；\n让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；\n可进行数据检查，从而有利于保证对象信息的完整性；\n便于修改，提高代码的可维护性。\n\n为了实现良好的封装，需要从两个方面考虑：\n\n将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；\n把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。\n\n把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要java提供的访问控制符来实现\n1.15 说一说你对多态的理解子类是一种特殊的父类。当一个父类类型的变量被赋以子类的类型时，如果他被调用，则表现出该子类的行为特征。所以就有可能，对于同一个类型的变量，由于其可能被好几个子类实现，所以有可能表现出多种行为特征，这就是多态。\nJava允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。\n1.16 Java中的多态是怎么实现的？多态的实现离不开继承，在设计参数的时候，可以将其声明为父类类型，然后在调用程序（传参）的时候，向其传递一个子类型的实例，这样就可以实现多态。\n对于父类型，可以有三种形式，即普通的类、抽象类、接口。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类&#x2F;接口的某些抽象方法。\n（对于抽象类，java其实不常用，java已经将其抽象为了接口）\n1.17 Java为什么是单继承，为什么不能多继承？java的继承其实参照了C++的继承机制，但是为了避免在多个父类都有相同的方法，导致子类在调用父类的方法时出现混淆，java就采用了单继承的机制，一个类只能有一个直接父类，但是却可以有多个间接的父类， 即是父类的父类。\n1.18 说一说重写与重载的区别重载发生在同一个类内，当多个方法的方法名相同，而参数列表不同时，它们之间就是重载的关系。重载与方法的修饰符、返回值无关。\n而重写发生在父类和子类之间，子类想要重写父类的方法，必须方法名、参数列表都与父类的完全相同。并且返回值类型、抛出异常都小于等于父类。访问修饰符则要大于等于父类方法。还有，若父类方法的访问修饰符为private，则子类不能对其重写。\n1.19 构造方法能不能重写？构造方法不能被子类重写，因为构造方法必须和类名同名，如果子类中重写了父类的构造方法，就会存在和类名不同的构造方法，而这与构造方法的定义相悖。\n1.20 介绍一下Object类中的方法getClass（）：返回当前对象的类\nequals（）：判断当前对象与参数对象是否相等\nhashCode（）：返回当前对象的散列值，Object的散列值根据其物理存储地址计算得出。而许多类已经重写了Object的hashCode方法，不在由物理存储地址计算。\ntoString（）：返回当前对象的字符串表示。Object的toString方法会返回类名@对象的十六进制hashCode，大多数类都重写了toString方法，使其被调用时可以以字符串的形式输出这个对象的属性。而且在对象和字符串进行拼接或者直接sout对象时，会自动调用toString方法。\nwait（）、notify（）、notifyAll（），都可以控制进程的开始和停止。\nObject类还提供了一个clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。\n拓展：\nObject类还提供了一个finalize()方法，当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。并且，针对某一个对象，垃圾回收器最多只会调用它的finalize()方法一次。\n注意，finalize()方法何时调用、是否调用都是不确定的，我们也不要主动调用finalize()方法。从JDK9开始，这个方法被标记为不推荐使用的方法。\n1.21 说一说hashCode()和equals()的关系\nhashCode()用于获取哈希码（散列码），eauqls()用于比较两个对象是否相等，它们应遵守如下规定：\n如果两个对象相等，则它们必须有相同的哈希码。\n如果两个对象有相同的哈希码，则它们未必相等。\n\n\n\n扩展阅读\n在Java中，Set接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。\n当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。实际上，HashSet是通过获取对象的哈希码，以及调用对象的equals()方法来解决这个判断问题的。\nHashSet首先会调用对象的hashCode()方法获取其哈希码，并通过哈希码确定该对象在集合中存放的位置。假设这个位置之前已经存了一个对象，则HashSet会调用equals()对两个对象进行比较。若相等则说明对象重复，此时不会保存新加的对象。若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会采用链式结构在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。\n1.22 为什么要重写hashCode()和equals()？Object默认的equals方法，是通过&#x3D;&#x3D;来比较两个对象是否相等。然而在实际业务中，我们希望只要两个对象有相同的内容就认为其相等，所以需要重写equals方法来满足我们的需求。\n由于hashCode()与equals()具有联动关系（参考“说一说hashCode()和equals()的关系”一题），所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法始终满足相关的约定。\n1.23 &#x3D;&#x3D;和equals()有什么区别？&#x3D;&#x3D;运算符：\n\n对于基本数据类型，可以判断两个变量数值是否相等。\n对于引用数据类型，判断两个对象的内存地址是否完全相等。\n\nequals（）：\n\n没有重写时，判断两个对象的内存地址是否相同。\n重写之后，一般判断两个对象的内容是否相同。\n\n1.24 String类有哪些方法？参考答案\nString类是Java最常用的API，它包含了大量处理字符串的方法，比较常用的有：\n\nchar charAt(int index)：返回指定索引处的字符；\nString substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；\nString[] split(String regex)：以指定的规则将此字符串分割成数组；\nString trim()：删除字符串前导和后置的空格；\nint indexOf(String str)：返回子串在此字符串首次出现的索引；\nint lastIndexOf(String str)：返回子串在此字符串最后出现的索引；\nboolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；\nboolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；\nString toUpperCase()：将此字符串中所有的字符大写；\nString toLowerCase()：将此字符串中所有的字符小写；\nString replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；\nString replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。\n\n建议你挑几个方法仔细看看源码实现，面试时可以重点说这几个方法。\n1.25 String可以被继承吗？参考答案\nString类由final修饰，所以不能被继承。\n扩展阅读\n在Java中，String类被设计为不可变类，主要表现在它保存字符串的成员变量是final的。\n\nJava 9之前字符串采用char[]数组来保存字符，即 private final char[] value；\nJava 9做了改进，采用byte[]数组来保存字符，即 private final byte[] value；\n\n之所以要把String类设计为不可变类，主要是出于安全和性能的考虑，可归纳为如下4点。\n\n由于字符串无论在任何 Java 系统中都广泛使用，会用来存储敏感信息，如账号，密码，网络路径，文件处理等场景里，保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。\n在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。\n字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。\n当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。\n\n因为要保证String类的不可变，那么将这个类定义为final的就很容易理解了。如果没有final修饰，那么就会存在String的子类，这些子类可以重写String类的方法，强行改变字符串的值，这便违背了String类设计的初衷。\n1.26 说一说String和StringBuffer有什么区别参考答案\nString类是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。\nStringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。\n1.27 说一说StringBuffer和StringBuilder有什么区别参考答案\nStringBuffer、StringBuilder都代表可变的字符串对象，它们有共同的父类 AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。不同的是，StringBuffer是线程安全的，而StringBuilder是非线程安全的，所以StringBuilder性能略高。一般情况下，要创建一个内容可变的字符串，建议优先考虑StringBuilder类。\n1.28 使用字符串时，new和””推荐使用哪种方式？直接使用“”生成的字符串JVM将会使用常量池来管理这个字符串；。\n通过new生成的字符串JVM会先使用常量池来管理直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在堆内存中。\n显然new会多创建一个对象。\n1.29 说一说你对字符串拼接的理解\n+ 运算符：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接；\nStringBuilder：如果拼接的字符串中包含变量，并*不要求线程安全*，则适合使用StringBuilder；\nStringBuffer：如果拼接的字符串中包含变量，并且*要求线程安全*，则适合使用StringBuffer；\nString类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；\n\n拓展：\n\nconcat方法的拼接逻辑是，先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。\n在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是只拼接2个字符串时，concat方法的效率要优于StringBuilder。并且这种拼接方式代码简洁，所以只拼2个字符串时建议优先选择concat方法。、\n\n1.30 两个字符串相加的底层是如何实现的？如果只是拼接两个字符串常量，那么编译器会自动将其优化为一个字符串常量，等同于直接创建一个字符串常量。\n如果是含有变量，那么编译器会自动创建StringBuilder对象，并调用其append方法以拼接。\n1.31 String a = &quot;abc&quot;; ，说一下这个过程会创建什么，放在哪里？java使用常量池来管理字符串直接量，在执行这条语句是，会先在常量池中查找是否存在“abc”这个字符串，如果不存在，就将”abc”存入常量池。如果存在就会调用其引用赋值给a。\n1.32 new String(&quot;abc&quot;) 是去了哪里，仅仅是在堆里面吗？会先在常量池创建一个“abc”直接量，然后在堆内存上创建一个string对象，指向常量池中的abc字符串。\n1.33 接口和抽象类有什么区别？接口体现的是规范。对于实现者而言，规定了其要实现哪些功能。而对于使用者而言，规定了其可以调用哪些功能以及如何调用哪些功能。在一个程序中，接口是多个模块之间的耦合标准。在多个程序中，接口是多个程序之间的通信标准。\n抽象类体现的是模板式设计模式，抽象类可以视作一个中间产品，已经实现了部分功能，但是并不完全，它需要被完善，并且可以有多种完成方式。\n从使用方式上来说，二者有如下的区别：\n\n接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。\n接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。\n接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。\n接口里不能包含初始化块；但抽象类则完全可以包含初始化块。\n一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。\n\n拓展：\n\n接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。\n接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。\n\n1.34 接口中可以有构造函数吗？不可以，接口中不允许有构造函数、初始化模块。\n接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法、默认方法或私有方法）、内部类（包括内部接口、枚举）定义。\n1.35 谈谈你对面向接口编程的理解面向接口是规范与实现的分离，这种方式可以有效减少程序之间的耦合度，增加系统的可维护性、可拓展性。\n1.36 遇到过异常吗，如何处理？\n捕获异常\n将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。\n\n处理异常\n在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。\n\n回收资源\n如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。\n\n\n1.37 说一说Java的异常机制关于异常处理：（上一问题的简略版）\n在Java中，处理异常的语句由try、catch、finally三部分组成。其中，try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。\n关于抛出异常：\n当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。\n关于异常跟踪栈：\n程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息\n1.38 请介绍Java的异常接口Throwable是异常的顶层父类，代表所有的非正常情况。它有两个直接子类，分别是Error、Exception。\nError是错误，一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，*将导致应用程序中断*。通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象。在定义方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类。\nException是异常，它被分为两大类，分别是Checked异常和Runtime异常。所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常。Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try…catch块来实现。\n1.39 finally是无条件执行的吗？是的，就算try或catch字块中出现了return语句，finally语句也会执行。\n但有一种可能，在try…catch中执行了System,exit(1)。此时finally不会执行，但是一般不会写这个语句。\n1.40 在finally中return会发生什么？如果在try…catch中使用了return语句，那么finally中的return语句会使上面的return语句失效。\n因为当在try…catch中使用return语句时，程序在执行return之间，会先查找是否有finally语句，如果有，就会先执行finally块中的代码，那么如果此时finally中也有return语句，程序就会在执行完finally的return语句之后结束，而不会返回去执行try…catch中的return语句。\n1.41 说一说你对static关键字的理解static 关键字可以把类中的成员、方法等声明为类成员，类成员无法访问实例成员，因为有可能类成员已经初始化完成，而实例成员还没有初始化。\n类成员属于整个类，而不属于单个对象。\n1.42 static修饰的类能不能被继承？可以被继承。\n拓展：static 只能修饰内部类，而不能修饰外部类（上一级是包）。\n静态内部类需满足如下规则：\n\n静态内部类可以包含静态成员，也可以包含非静态成员；\n静态内部类不能访问外部类的实例成员，只能访问它的静态成员；\n外部类的所有方法、初始化块都能访问其内部定义的静态内部类；\n在外部类的外部，也可以实例化静态内部类，语法如下：\n\n\t\n外部类.内部类 变量名 = new 外部类.内部类构造方法();\n\n\n\n1.43 static和final有什么区别？static修饰类的成员，将成员、方法、初始块、内部类定义为类的成员。\n\n类变量：被static修饰的成员变量叫类变量（静态变量）。类变量属于类，它随类的信息存储在方法区，并不随对象存储在堆中，类变量可以通过类名来访问，也可以通过对象名来访问，但建议通过类名访问它。\n类方法：被static修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，建议通过类名访问它。\n静态块：被static修饰的初始化块叫静态初始化块。静态块属于类，它在类加载的时候被隐式调用一次，之后便不会被调用了。\n静态内部类：被static修饰的内部类叫静态内部类。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。\n\nfinal可以修饰成员、变量、方法。\n\nfinal类：final关键字修饰的类不可以被继承。\nfinal方法：final关键字修饰的方法不可以被重写。\nfinal变量：final关键字修饰的变量，一旦获得了初始值，就不可以被修改。\n\n1.44 说一说你对泛型的理解最开始的java集合，为了追求通用性，并不限制集合中元素的类型，所有元素都可以加入一个集合，最终取出时作为Object被取出，然后通过类型转换得到远啦跌元素。\n后来java引入了参数化类型的概念，即在定义集合时，可以指定集合能够存放哪种类型的元素，这就是泛型。这样不仅使得代码更加简洁，也免去了去除元素后进行类型转换的麻烦。\n从Java 5开始，Java引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，Java的参数化类型被称为泛型\n1.45 介绍一下泛型擦除泛型擦除是指，在编译时，编译器会擦除在声明时使用了泛型的变量指定的泛型类型，如：ArrayList 会被擦除变成——ArrayList。或是将一个有泛型约束的变量赋值给另一个没有泛型约束的变量，此时也会发生泛型擦除。\n擦除规则有：\n\n若泛型类型没有指定具体类型，用Object作为原始类型；\n若有限定类型&lt; T exnteds XClass &gt;，使用XClass作为原始类型；\n若有多个限定&lt; T exnteds XClass1 &amp; XClass2 &gt;，使用第一个边界类型XClass1作为原始类型；\n其中Xclass1可以是class也可以是interface，但第二个只能是interface\n\n\n\nJava 泛型擦除是 Java 泛型中的一个重要特性，其目的是避免过多的创建类而造成的运行时的过度消耗。所以，想 ArrayList 和 ArrayList 这两个实例，其类实例是同一个。\n泛型的约束是在编译时约束的，真正运行的 class 是没有泛型约束的。所以可以在运行时向一个本来有泛型约束的对象中加入约束之外类型的元素（可以借助try…catch语句实现，但一般不会这么做）。\n当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉\nList&lt;String&gt; list1 = ...;List list2 = list1; // list2将元素当做Object处理\n\n如果把一个List赋值给一个List，并不会引起编译错误，编译器仅仅提示“未经检查的转换”。\nList list1 = ...;List&lt;String&gt; list2 = list1; // 编译时警告“未经检查的转换”\n\n\n\n1.46 List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？\n? 是类型通配符，List&lt;?&gt; 可以表示各种泛型List的父类，意思是元素类型未知的List；\nList&lt;? super T&gt; 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是T的父类型；\nList&lt;? extends T&gt; 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的子类型。\n\n拓展阅读：\n数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但G&lt;Foo&gt; 不是 G&lt;Bar&gt; 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，Java的数组支持型变，但Java集合并不支持型变。  Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。\n1.47 说一说你对Java反射机制的理解Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。——【百度百科】\n一个java对象的类型可以分为编译时类型和运行时类型。\n通过反射机制，我们可以实现如下的操作：\n\n程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的信息；\n程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员；\n程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象。\n\n1.48 Java反射在实际项目中有哪些应用场景\n使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；\n多数框架都支持注解&#x2F;XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；\n面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。\n\n1.49 说一说Java的四种引用方式\n强引用：java程序中最常见的引用方式，即程序创建一个对象，然后将其赋给一个引用对象，通过引用对象来操作实际对象。当一个对象有多个引用时，不会被垃圾回收机制回收。\n软引用：当一个对象只有软引用时，如果系统内存足够，那么就不会被垃圾回收机制所回收其内存空间，如果系统内存不足，系统可能会回收它。\n弱引用：如果一个对象只有弱引用，那么在程序执行垃圾回收机制时，不论系统内存是否做都会被回收。\n虚引用：虚引用对对象几乎没有影响，只是用来追踪对象的回收情况。虚引用不能单独使用，虚引用必须和引用队列联合使用。\n\n2.集合类2.1 Java中有哪些容器（集合类）？java中的容器可以分为Collection和Map。\n其中Collection还有三个子接口：Set、List、Queue。\n\nSet：无序不可重复的集合。\nList：有序可重复的集合。\nQueue：先进先出的队列集合。\nMap：具有映射关系的集合。\n\n这些接口拥有众多的实现类，其中最常用的实现类有HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。\n拓展：\nCollection体系的继承树：\n\nMap体系的继承树：\n\n注：紫色框体代表接口，其中加粗的是代表四类集合的接口。蓝色框体代表实现类，其中有阴影的是常用实现类。\n2.2 Java中的容器，线程安全和线程不安全的分别有哪些？线程安全的都是些老API，如HashTable、Vector，其他都是非线程安全的。但是线程安全的类性能很差，而线程不安全的类基本都性能比较好。如果是需要使用线程安全的集合类，也建议使用Collection提供的包装方法，将线程不安全的类包装为线程安全的类再进行使用。\n如果需要使用线程安全的集合类，则可以使用Collections工具类提供的synchronizedXxx()方法，将这些集合类包装成线程安全的集合类。\n从Java5开始，Java在java.util.concurrent包下提供了大量支持高效并发访问的集合类，它们既能包装良好的访问性能，有能包装线程安全。这些集合类可以分为两部分，它们的特征如下：\n\n以Concurrent开头的集合类：\n以Concurrent开头的集合类代表了支持并发访问的集合，它们可以支持多个线程并发写入访问，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定。以Concurrent开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合，因此在并发写入时有较好的性能。\n\n以CopyOnWrite开头的集合类：\n以CopyOnWrite开头的集合类采用复制底层数组的方式来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。\n\n\n2.4 描述一下Map put的过程\n首次扩容：判断数组中是否为空，如果为空就进行第一次扩容\n计算索引：通过hash算法，计算键值对在数组中的索引\n插入数据：\n如果当前位置为空，则直接插入数据\n如果当前位置非空，且已有key，直接覆盖value\n如果当前位置非空，且没有key，则把数据链接到链表末端\n若链表的长度达到8，那么就将链表转换为红黑树（平衡二叉树）\n\n\n再次扩容，如果此时元素个数超过了threshold，则再次扩容\n\n&#x3D;&#x3D;Map的get方法和put方法&#x3D;&#x3D;\n①通过key.hashCode()获得键的哈希值\n②用hash函数计算上一步得到的哈希值，进而得到在数组中的索引\n③插入数据，同上\n2.5 如何得到一个线程安全的Map？\n使用Collection下的方法，将Map包装为一个线程安全的类。\n使用Concurrent下的ConcurrentHashMap。\n不建议使用HashTable，虽然线程安全，但是性能较差。\n\n2.6 HashMap有什么特点？\n不是线程安全的\nkey或者value都可以是null\n\n2.7 JDK7和JDK8中的HashMap有什么区别？JDK7中的HashMap，是基于数组+链表来实现的，它的底层维护一个Entry数组。它会根据计算的hashCode将对应的KV键值对存储到该数组中，一旦发生hashCode冲突，那么就会将该KV键值对放到对应的已有元素的后面， 此时便形成了一个链表式的存储结构。\nJDK7中HashMap的实现方案有一个明显的缺点，即当Hash冲突严重时，在桶上形成的链表会变得越来越长，这样在查询时的效率就会越来越低，其时间复杂度为O(N)。\nJDK8中的HashMap，是基于数组+链表+红黑树来实现的，它的底层维护一个Node数组。当链表的存储的数据个数大于等于8的时候，不再采用链表存储，而采用了红黑树存储结构。这么做主要是在查询的时间复杂度上进行优化，链表为O(N)，而红黑树一直是O(logN)，可以大大的提高查找性能。\n2.8 介绍一下HashMap底层的实现原理它基于hash算法，通过put方法和get方法存储和获取对象。\n存储对象时，我们将K&#x2F;V传给put方法时，它调用K的hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。\n如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来。在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。\n2.9 介绍一下HashMap的扩容机制\n数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。\n数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。\n为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时（6），又会将红黑树转换回单向链表提高性能。\n对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。\n\n2.10 HashMap中的循环链表是如何产生的？在多线程的情况下，当重新调整HashMap大小的时候，就会存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，那么就会产生死循环了。\n2.11 HashMap为什么用红黑树而不用B树？B&#x2F;B+树多用于外存上时，B&#x2F;B+也被成为一个磁盘友好的数据结构。\nHashMap本来是数组+链表的形式，链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。如果用B&#x2F;B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表。\n2.12 HashMap为什么线程不安全？HashMap的put操作，可能引起数组大小的调整，而在多线程的情况下，调整数组的大小可能会导致出现数组中出现循环列表，进而出现死循环，所以HashMap不是线程安全的。\n2.13 HashMap如何实现线程安全？\n利用Collections的包装类，将其包装为一个线程安全的类。\n直接使用ConcurrentHashMap类。\n直接使用HashTable类。\n\n2.14 HashMap是如何解决哈希冲突的？为了解决碰撞，数组中的元素是一个单项链表，当发生冲突时，可以将键值对存放在链表尾部，当链表长度达到阈值时，会把链表转换为红黑树。并且当冲突元素的个数小于阈值时，会重新转换回链表。\n2.15 说一说HashMap和HashTable的区别\nHashMap的性能比Hashtable的性能更好\nHashMap不是线程安全的，而Hashtable是线程安全的\nHashtable不允许使用null作为key和value，如果试图把null值放进Hashtable中，将会引发空指针异常，但HashMap可以使用null作为key或value。\n\n2.16 HashMap与ConcurrentHashMap有什么区别？HashMap不是线程安全的，意味着如果在多线程的环境下操作map，可能会发生数据不一致的情况，并且如果是插入数据，还可能使得链表成环，进而在查找数据时陷入死循环，影响整个应用程序。\nCollections工具类可以将一个Map转换成线程安全的实现，其实也就是通过一个包装类，然后把所有功能都委托给传入的Map，而包装类是基于synchronized关键字来保证线程安全的（Hashtable也是基于synchronized关键字），底层使用的是互斥锁，性能与吞吐量比较低。\nConcurrentHashMap的实现细节远没有这么简单，因此性能也要高上许多。它没有使用一个全局锁来锁住自己，而是采用了减少锁粒度的方法，尽量减少因为竞争锁而导致的阻塞与冲突，而且ConcurrentHashMap的检索操作是不需要锁的。\n2.17 介绍一下ConcurrentHashMap是怎么实现的？在JDK1.7中，ConcurrentHashMap由Segment数据结构和HashEntry数据结构组成，采取分段锁来保证安全性，Segment 是 ReentrantLock 重入锁，在 ConcurrentHashMap 中扮演锁的角色，HashEntry 则用于存储键值对数据。map由segment数组组成，而segment数组中的元素是HashEntry数组，所以其结构也是数组加链表。\n\n而在JDK1.8中，摒弃了Segment概念，直接采用Node数组、链表、红黑树来实现。并发控制用Synchronized和CAS来操作，整个看起来就像是优化到线程安全的HashMap，虽然在1.8中还能看到Segment，但已经简化了属性，只是为了兼容旧版本。\n\n2.18 ConcurrentHashMap是怎么分段分组的？get操作：\nSegment的get操作实现非常简单和高效，先经过一次再散列，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素。get操作的高效之处在于整个get过程都不需要加锁，除非读到空的值才会加锁重读。原因就是将使用的共享变量定义成 volatile 类型。\nput操作：\n当执行put操作时，会经历两个步骤：\n\n判断是否需要扩容；\n定位到添加元素的位置，将其放入 HashEntry 数组中。\n\n插入过程会进行第一次 key 的 hash 来定位 Segment 的位置，如果该 Segment 还没有初始化，即通过 CAS 操作进行赋值，然后进行第二次 hash 操作，找到相应的 HashEntry 的位置，这里会利用继承过来的锁的特性，在将数据插入指定的 HashEntry 位置时（尾插法），会通过继承 ReentrantLock 的 tryLock() 方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用 tryLock() 方法去获取锁，超过指定次数就挂起，等待唤醒。\n2.19 说一说你对LinkedHashMap的理解LinkedHashMap使用双向链表来维护键值对的顺序，其实也就是key的顺序，迭代顺序和 插入顺序一致。\nLinkedHashMap可以避免对HashMap、Hashtable里的key-value对进行排序（只要插入key-value对时保持顺序即可），同时又可避免使用TreeMap所增加的成本。\n需要在插入时维护链表的顺序，所以性能稍低于HashMap，但又因为是链表的结构，所以在迭代访问Map中所有元素时有着较好的性能。\n2.20 请介绍LinkedHashMap的底层原理LinkedHashMap继承自HashMap，大部分方法直接继承，只有少部分方法为了适配双向链表而重写。\n链表中存在head指针和tail指针，添加元素时，会将元素连接到tail指针指向元素的后面，并将tail指针向后移动一位。\n\n2.21 请介绍TreeMap的底层原理TreeMap基于红黑树实现。依据键的自然排序或是比较器来建立映射。\nTreeMap的主要的方法有：get、put、containsKey、remove。\nTreeMap中重要的成员变量：root、size、comparator。其中root是根节点，节点是Entry类，包含的属性有：key、value、left、right、parent、color。size表示红黑树的大小。comparator可以用来比较key的大小。\n2.22 Map和Set有什么区别？Set代表无序的，元素不可重复的集合；\nMap代表具有映射关系（key-value）的集合，其所有的key是一个Set集合，即key无序且不能重复。\n2.23 List和Set有什么区别？Set代表无序的，元素不可重复的集合；\nList代表有序的，元素可以重复的集合。\n回答这类集合是什么，一定要说明他是一个集合\n2.24 ArrayList和LinkedList有什么区别？\nArrayList的实现基于数组，而LinkedList的实现基于双向链表。\n对于查找随机元素，ArrayList可以根据索引直接获取，时间复杂度是O（1）；而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起，查找某个元素的时间复杂度是O(N)；\n对于插入删除元素，LinkedList的性能要优于ArrayList，因为在ArrayList中需要每次都要计算大小和更新索引，而在LinkedList中，只需要改变指针指向即可。\nLinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。\n\n2.25 有哪些线程安全的List？\nvector——虽然线程安全，但是效率低，不建议使用\nCollections.SynchronizedList——通过Collections的方法包装得到的线程安全的List类，它比Vector有更好的扩展性和兼容性，但是它所有的方法都带有同步锁，也不是性能最优的List。\nCopyOnWriteArrayList——CopyOnWriteArrayList是Java 1.5在java.util.concurrent包下增加的类，在进行读操作时不具有锁；在执行写操作时，会复制一个底层数组，对数组副本进行写入，所以是线程安全的，同时性能最优的。\n\n2.26 介绍一下ArrayList的数据结构？ArrayList的底层是用数组来实现的，默认大小是10，如果超出，则自动扩容50%并通过 System.arraycopy将原有数据复制到新的数组中。\n在读取元素时可以按照小（索引）读取，有较快的速度。但是在按下标插入数据或者删除元素时，需要通过System.arraycopy来复制一部分数组，效率较低。\n2.27 谈谈CopyOnWriteArrayList的原理CopyOnWriteArrayList是并发包下的一个线程安全的类，原型就是ArrayList。在进行读操作时不会发生上锁和阻塞，而在写操作中，会先将数组拷贝一份，然后对拷贝出来的数组进行写操作。并且在写操作过程中是上锁的，只有当写操作完成之后，才会将原来List容器指向拷贝出来的List容器。在写操作完成之前，如果有其他线程进行读操作，则是对原List容器进行读操作。\nCopyOnWriteArrayList采用读写分离的思想，好处是可以保证线程的安全以及读取数据的效率，比较适用读多写少的数据。而当数据量较大时需要写操作，就可能导致内存压力过大而出问题。其次就是由于其读写分离，无法保证数据的实时性。\n2.28 说一说TreeSet和HashSet的区别两者的元素都不能重复，并且都不是线程安全的。\n\nTreeSet中元素不可以为null，而HashSet中元素可以为null\nHashSet不能保证元素的排列顺序，而TreeSet中元素可以是自然排序也可以是自定义排序\nHashSet的底层是HashMap，而TreeSet的底层原理是红黑树。\n\n2.29 说一说HashSet的底层结构HashSet底层是用HashMap实现的，封装了一个大小为16，负载因子为0.75的HashMap来存放元素。并且只使用HashMap的key来存放数据，而value存放了一个PRESENT，PRESENT是一个静态的Object对象。\n2.30 BlockingQueue中有哪些方法，为什么这样设计？BlockingQueue是阻塞队列，适用于多线程消费者生产者模型，用于在消费者生产者之间充当数据交换的控制容器，分别在生产过多、消费过多的情况下，挂起（阻塞）生产者、挂起消费者。\nBlockingQueue中对于数据有三种操作——插入、删除、检查，对于插入删除有四种不同的执行方法：\n\n\n\n\n\n\n\n\n\n\n\n\n\n抛异常\n特定值\n阻塞\n超时\n\n\n插入\nadd(e)\noffer(e)\nput(e)\noffer(e, time, unit)\n\n\n移除\nremove()\npoll()\ntake()\npoll(time, unit)\n\n\n检查\nelement()\npeek()\n\n\n\n\n\n四组不同的行为方式含义如下：\n\n抛异常：如果操作无法立即执行，则抛一个异常；\n特定值：如果操作无法立即执行，则返回一个特定的值(一般是 true &#x2F; false)。\n阻塞：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行；\n**超时**：如果操作无法立即执行，则该方法调用将会发生阻塞，直到能够执行。但等待时间不会超过给定值，并返回一个特定值以告知该操作是否成功(典型的是true &#x2F; false)。\n\n2.31 BlockingQueue是怎么实现的？BlockingQueue是一个接口，它的实现类有ArrayBlockingQueue、DelayQueue、 LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue等。它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于put与take操作的原理是类似的。下面以ArrayBlockingQueue为例，来说明BlockingQueue的实现原理。\n首先看一下ArrayBlockingQueue的构造函数，它初始化了put和take函数中用到的关键成员变量，这两个变量的类型分别是ReentrantLock和Condition。ReentrantLock是AbstractQueuedSynchronizer（AQS）的子类，它的newCondition函数返回的Condition实例，是定义在AQS类内部的ConditionObject类，该类可以直接调用AQS相关的函数。\npublic ArrayBlockingQueue(int capacity, boolean fair) &#123;    if (capacity &lt;= 0)        throw new IllegalArgumentException();    this.items = new Object[capacity];    lock = new ReentrantLock(fair);    notEmpty = lock.newCondition();    notFull =  lock.newCondition();&#125;\n\nput函数会在队列末尾添加元素，如果队列已经满了，无法添加元素的话，就一直阻塞等待到可以加入为止。函数的源码如下所示。我们会发现put函数使用了wait&#x2F;notify的机制。与一般生产者-消费者的实现方式不同，同步队列使用ReentrantLock和Condition相结合的机制，即先获得锁，再等待，而不是synchronized和wait的机制。\npublic void put(E e) throws InterruptedException &#123;    checkNotNull(e);    final ReentrantLock lock = this.lock;//先获得锁    lock.lockInterruptibly();//上锁    try &#123;        while (count == items.length)             notFull.await();//在队列满时进入等待        enqueue(e);//队列不满，入队    &#125; finally &#123;        lock.unlock();//解锁    &#125;&#125;\n\n再来看一下消费者调用的take函数，take函数在队列为空时会被阻塞，一直到阻塞队列加入了新的元素。\npublic E take() throws InterruptedException &#123;    final ReentrantLock lock = this.lock;//获得锁    lock.lockInterruptibly();//上锁    try &#123;        while (count == 0)            notEmpty.await();//挂起        return dequeue();//出队    &#125; finally &#123;        lock.unlock();//解锁    &#125;&#125;\n\n拓展：await操作：\n我们发现ArrayBlockingQueue并没有使用Object.wait，而是使用的Condition.await，这是为什么呢？Condition对象可以提供和Object的wait和notify一样的行为，但是后者必须先获取synchronized这个内置的monitor锁才能调用，而Condition则必须先获取ReentrantLock。这两种方式在阻塞等待时都会将相应的锁释放掉，但是Condition的等待可以中断，这是二者唯一的区别。\n我们先来看一下Condition的await函数，await函数的流程大致如下图所示。await函数主要有三个步骤，一是调用addConditionWaiter函数，在condition wait queue队列中添加一个节点，代表当前线程在等待一个消息。然后调用fullyRelease函数，将持有的锁释放掉，调用的是AQS的函数。最后一直调用isOnSyncQueue函数判断节点是否被转移到sync queue队列上，也就是AQS中等待获取锁的队列。如果没有，则进入阻塞状态，如果已经在队列上，则调用acquireQueued函数重新获取锁。\n\nsignal操作：\nsignal函数将condition wait queue队列中队首的线程节点转移等待获取锁的sync queue队列中。这样的话，await函数中调用isOnSyncQueue函数就会返回true，导致await函数进入最后一步重新获取锁的状态。\n我们这里来详细解析一下condition wait queue和sync queue两个队列的设计原理。condition wait queue是等待消息的队列，因为阻塞队列为空而进入阻塞状态的take函数操作就是在等待阻塞队列不为空的消息。而sync queue队列则是等待获取锁的队列，take函数获得了消息，就可以运行了，但是它还必须等待获取锁之后才能真正进行运行状态。\nsignal函数其实就做了一件事情，就是不断尝试调用transferForSignal函数，将condition wait queue队首的一个节点转移到sync queue队列中，直到转移成功。因为一次转移成功，就代表这个消息被成功通知到了等待消息的节点。\nsignal函数的示意图如下所示。\n\n什么是流（Stream）？https://www.runoob.com/java/java8-streams.html  完整实例\nJava 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。\nStream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\nStream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\n这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。\n元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。\nStream（流）是一个来自数据源的元素队列并支持聚合操作\n\n元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。\n数据源 流的来源。 可以是集合，数组，I&#x2F;O channel， 产生器generator 等。\n聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。\n\n和以前的Collection操作不同， Stream操作还有两个基础的特征：\n\nPipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。\n\n生成流：\n\nstream() − 为集合创建串行流。\nparallelStream() − 为集合创建并行流。\n\n常用方法：\nforEach——Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。\n以下代码片段使用 forEach 输出了10个随机数：\nRandom random = new Random();random.ints().limit(10).forEach(System.out::println);\n\n\n\nmap——map 方法用于映射每个元素到对应的结果\n以下代码片段使用 map 输出了元素对应的平方数：\nList&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);// 获取对应的平方数List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());\n\n\n\nfilter——filter 方法用于通过设置的条件过滤出元素。\n以下代码片段使用 filter 方法过滤出空字符串：\nList&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);// 获取空字符串的数量long count = strings.stream().filter(string -&gt; string.isEmpty()).count();\n\n\n\nlimit——limit 方法用于获取指定数量的流。\n 以下代码片段使用 limit 方法打印出 10 条数据：\nRandom random = new Random();random.ints().limit(10).forEach(System.out::println);\n\n\n\nsorted——sorted 方法用于对流进行排序。\n以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：\nRandom random = new Random();random.ints().limit(10).sorted().forEach(System.out::println);\n\n\n\nparallelStream——parallelStream 是流并行处理程序的代替方法。\n以下实例我们使用 parallelStream 来输出空字符串的数量：\nList&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);// 获取空字符串的数量long count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();\n\n我们可以很容易的在顺序运行和并行直接切换。\nCollectors—— Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。\nCollectors 可用于返回列表或字符串：\nList&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选列表: &quot; + filtered);String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));System.out.println(&quot;合并字符串: &quot; + mergedString);\n\n\n\n2.32 Stream（不是IOStream）有哪些方法？根据对流的影响，可以分为：\n\n中间方法：中间操作允许流保持打开状态，并允许直接调用后续方法。\n末端方法：是对流的最终操作，执行后流会被消耗且不可再用。\n\n关于流的方法还有以下两个特征：\n\n有状态的方法：这些方法会给流新的属性——元素的唯一性、元素的最大数量、保证元素按顺序被处理等。这样的方法往往需要更大的性能开销。\n短路方法：短路方法可以尽早结束对流的操作，不必检查所有的元素。\n\nStream常用的中间方法：\n\nfilter(Predicate predicate)：过滤Stream中所有不符合predicate的元素。\nmapToXxx(ToXxxFunction mapper)：使用ToXxxFunction对流中的元素执行一对一的转换，该方法返回的新流中包含了ToXxxFunction转换生成的所有元素。\npeek(Consumer action)：依次对每个元素执行一些操作，该方法返回的流与原有流包含相同的元素。该方法主要用于调试。\ndistinct()：该方法用于排序流中所有重复的元素（判断元素重复的标准是使用equals()比较返回true）。这是一个有状态的方法。\nsorted()：该方法用于保证流中的元素在后续的访问中处于有序状态。这是一个有状态的方法。\nlimit(long maxSize)：该方法用于保证对该流的后续访问中最大允许访问的元素个数。这是一个有状态的、短路方法。\n\nStream常用的末端方法：\n\nforEach(Consumer action)：遍历流中所有元素，对每个元素执行action。\ntoArray()：将流中所有元素转换为一个数组。\nreduce()：该方法有三个重载的版本，都用于通过某种操作来合并流中的元素。\nmin()：返回流中所有元素的最小值。\nmax()：返回流中所有元素的最大值。\ncount()：返回流中所有元素的数量。\nanyMatch(Predicate predicate)：判断流中是否至少包含一个元素符合Predicate条件。\nnoneMatch(Predicate predicate)：判断流中是否所有元素都不符合Predicate条件。\nfindFirst()：返回流中的第一个元素。\nfindAny()：返回流中的任意一个元素。\n\nCollection接口提供了一个stream()默认方法，该方法可返回该集合对应的流，接下来即可通过流式API来操作集合元素。由于Stream可以对集合元素进行整体的聚集操作，因此Stream极大地丰富了集合的功能。\n3.IO3.1 介绍一下Java中的IO流IO（Input Output）用于实现对数据的输入与输出操作，Java把不同的输入&#x2F;输出源（键盘、文件、网络等）抽象表述为流（Stream）。流是从起源到接收的有序数据，有了它程序就可以采用同一方式访问不同的输入&#x2F;输出源。\n\n按照数据流向，可以将流分为输入流和输出流，其中输入流只能读取数据、不能写入数据，而输出流只能写入数据、不能读取数据。\n按照数据类型，可以将流分为字节流和字符流，其中字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符。\n按照处理功能，可以将流分为节点流和处理流，其中节点流可以直接从&#x2F;向一个特定的IO设备（磁盘、网络等）读&#x2F;写数据，也称为低级流，而处理流是对节点流的连接或封装，用于简化数据读&#x2F;写功能或提高效率，也称为高级流。\n\n各种流：\n\n以File开头的文件流用于访问文件；\n以ByteArray&#x2F;CharArray开头的流用于访问内存中的数组；\n以Piped开头的管道流用于访问管道，实现进程之间的通信；\n以String开头的流用于访问内存中的字符串；\n以Buffered开头的缓冲流，用于在读写数据时对数据进行缓存，以减少IO次数；\nInputStreamReader、InputStreamWriter是转换流，用于将字节流转换为字符流；\n以Object开头的流是对象流，用于实现对象的序列化；\n以Print开头的流是打印流，用于简化打印操作；\n以Pushback开头的流是推回输入流，用于将已读入的数据推回到缓冲区，从而实现再次读取；\n以Data开头的流是特殊流，用于读写Java基本类型的数据。\n\n3.2 怎么用流打开一个大文件？打开大文件，应避免直接将文件中的数据全部读取到内存中，可以采用分次读取的方式。\n\n使用缓冲流。缓冲流内部维护了一个缓冲区，通过与缓冲区的交互，减少与设备的交互次数。使用缓冲输入流时，它每次会读取一批数据将缓冲区填满，每次调用读取方法并不是直接从设备取值，而是从缓冲区取值，当缓冲区为空时，它会再一次读取数据，将缓冲区填满。使用缓冲输出流时，每次调用写入方法并不是直接写入到设备，而是写入缓冲区，当缓冲区填满时它会自动刷入设备。\n总之相较于直接每次都从设备里面读取，缓冲流会先充满缓冲区，让程序与缓冲区交互，等到缓冲区空了之后再和设备交互。\n\n使用NIO。NIO采用内存映射文件的方式来处理输入&#x2F;输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样来访问文件了（这种方式模拟了操作系统上的虚拟内存的概念），通过这种方式来进行输入&#x2F;输出比传统的输入&#x2F;输出要快得多。\nNIO将文件映射到内存中，就可以像访问内存一样访问文件，模拟了操作系统中的虚存，有较快的读写速度。\n\n\n3.4 说说NIO的实现原理Java的NIO主要由三个核心部分组成：Channel、Buffer、Selector。\n基本上，所有的IO在NIO中都从一个Channel开始，数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。Channel有好几种类型，其中比较常用的有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等，这些通道涵盖了UDP和TCP网络IO以及文件IO。\nBuffer本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。Java NIO里关键的Buffer实现有CharBuffer、ByteBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。这些Buffer覆盖了你能通过IO发送的基本数据类型，即byte、short、int、long、float、double、char。\nBuffer对象包含三个重要的属性，分别是capacity、position、limit，其中position和limit的含义取决于Buffer处在读模式还是写模式。但不管Buffer处在什么模式，capacity的含义总是一样的。\n\ncapacity：作为一个内存块，Buffer有个固定的最大值，就是capacity。Buffer只能写capacity个数据，一旦Buffer满了，需要将其清空才能继续写数据往里写数据。指示内存块的大小\nposition：当写数据到Buffer中时，position表示当前的位置。初始的position值为0。当一个数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity–1。当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。指示当前读或写的位置\nlimit：在写模式下，Buffer的limit表示最多能往Buffer里写多少数据，此时limit等于capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据，此时limit会被设置成写模式下的position值。\n\n三个属性之间的关系，如下图所示：\n\nSelector允许单线程处理多个 Channel，如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件例如有新连接进来，数据接收等。\n这是在一个单线程中使用一个Selector处理3个Channel的图示：\n\nJava NIO根据操作系统不同， 针对NIO中的Selector有不同的实现：\n\nmacosx：KQueueSelectorProvider\nsolaris：DevPollSelectorProvider\nLinux：EPollSelectorProvider (Linux kernels &gt;&#x3D; 2.6)或PollSelectorProvider\nwindows：WindowsSelectorProvider\n\n所以不需要特别指定，Oracle JDK会自动选择合适的Selector。如果想设置特定的Selector，可以设置属性，例如： -Djava.nio.channels.spi.SelectorProvider&#x3D;sun.nio.ch.EPollSelectorProvider。\nJDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，所以Netty自4.0.16起, Netty为Linux通过JNI的方式提供了native socket transport。Netty重新实现了epoll机制。\n\n采用边缘触发方式；\nnetty epoll transport暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等；\nC代码，更少GC，更少synchronized。\n\n3.5 介绍一下Java的序列化与反序列化序列化机制可以将对象转换成字节序列，这些字节序列可以保存在磁盘上，也可以在网络中传输，并允许程序将这些字节序列再次恢复成原来的对象。其中，对象的序列化（Serialize），是指将一个Java对象写入IO流中，对象的反序列化（Deserialize），则是指从IO流中恢复该Java对象。\n若对象要支持序列化机制，则它的类需要实现Serializable接口，该接口是一个标记接口，它没有提供任何方法，只是标明该类是可以序列化的，Java的很多类已经实现了Serializable接口，如包装类、String、Date等。\n若要实现序列化，则需要使用对象流ObjectInputStream和ObjectOutputStream。其中，在序列化时需要调用ObjectOutputStream对象的writeObject()方法，以输出对象序列。在反序列化时需要调用ObjectInputStream 对象的**readObject()**方法，将对象序列恢复为对象。\n输出流的写对象方法可以输出序列，输入流的读对象方法可以将序列恢复为对象\n3.6 Serializable接口为什么需要定义serialVersionUID变量？serialVersionUID代表序列化的版本，通过这个UID就可以判断被序列化的对象的类和当前类是否一致，可以避免发生错误，否则在一种情况下，如——将对象序列化之后，修改了类的属性，然后再将对象反序列化，这样就会出问题。但是借助UID就可以判断两个类是否一致，在不一致时抛出序列化版本不一致的错误。\n3.7 除了Java自带的序列化之外，你还了解哪些序列化工具？JSON、Protobuf、Thrift、Avro。其中后三个是第三方类库。\n3.8 如果不用JSON工具，该如何实现对实体类的序列化？可以使用Java原生的序列化机制，但是效率比较低一些，适合小项目；\n可以使用其他的一些第三方类库，比如Protobuf、Thrift、Avro等。\n4.多线程4.1 创建线程有哪几种方式？通过Thread类、Runnable接口、Callable接口\n通过继承Thread类来创建并启动线程的步骤如下：\n\n定义Thread类的子类，并重写该类的run()方法，该run()方法将作为线程执行体。\n创建Thread子类的实例，即创建了线程对象。\n调用线程对象的start()方法来启动该线程。\n\n通过实现Runnable接口来创建并启动线程的步骤如下：\n\n定义Runnable接口的实现类，并实现该接口的run()方法，该run()方法将作为线程执行体。\n创建Runnable实现类的实例，并将其作为Thread的target来创建Thread对象，Thread对象为线程对象。\n调用线程对象的start()方法来启动该线程。\n\n通过实现Callable接口来创建并启动线程的步骤如下：\n\n创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且该call()方法有返回值。然后再创建Callable实现类的实例。\n使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。\n使用FutureTask对象作为Thread对象的target创建并启动新线程。\n调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。\n\n采用实现Runnable、Callable接口的方式创建多线程的优缺点：\n\n线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。\n在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。\n劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用**Thread.currentThread()**方法。\n\n采用继承Thread类的方式创建多线程的优缺点：\n\n劣势是，因为线程类已经继承了Thread类，所以不能再继承其他父类。\n优势是，编写简单，如果需要访问当前线程，则无须使用Thread.currentThread()方法，直接使用this即可获得当前线程。\n\n鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。\n4.2 说说Thread类的常用方法Thread类常用构造方法：\n\nThread()\nThread(String name)\nThread(Runnable target)\nThread(Runnable target, String name)\n\n*其中，参数 name为线程名，参数 target为包含线程体的目标对象。*\nThread类常用静态方法：\n\ncurrentThread()：返回当前正在执行的线程；\ninterrupted()：返回当前执行的线程是否已经被中断；\nsleep(long millis)：使当前执行的线程睡眠多少毫秒数；\nyield()：使当前执行的线程自愿暂时放弃对处理器的使用权并允许其他线程执行；\n\nThread类常用实例方法：\n\ngetId()：返回该线程的id；\ngetName()：返回该线程的名字；\ngetPriority()：返回该线程的优先级；\ninterrupt()：使该线程中断；\nisInterrupted()：返回该线程是否被中断；\nisAlive()：返回该线程是否处于活动状态；\nisDaemon()：返回该线程是否是守护线程；\nsetDaemon(boolean on)：将该线程标记为守护线程或用户线程，如果不标记默认是非守护线程；\nsetName(String name)：设置该线程的名字；\nsetPriority(int newPriority)：改变该线程的优先级；\njoin()：等待该线程终止；\njoin(long millis)：等待该线程终止,至多等待多少毫秒数。\n\n4.3 run()和start()有什么区别？run()方法被称为线程执行体，它的方法体代表了线程需要完成的任务，而start()方法用来启动线程。\n调用start()方法启动线程时，系统会把该run()方法当成线程执行体来处理。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，如果直接调用线程对象的run()方法，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。\n4.4 线程是否可以重复启动，会有什么后果？不可以，只能对处于新建状态的线程调用start()方法，否则将引发IllegalThreadStateException异常。\n当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。\n当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。\n4.5 介绍一下线程的生命周期线程的生命周期可以经过五个状态：新建、就绪、运行、阻塞、死亡。并且由于线程无法一直霸占CPU资源，所以会在就绪和运行之间不断切换。\n当程序new了一个线程之后，他就处于新建状态，JVM为其分配内存，初始化成员变量。\n当start方法被执行之后，就处于就绪状态，JVM会为其创建方法调用栈和**程序计数器**，线程此时没有直接运行，而是等待JVM线程调度器的调用后才开始运行。\n如果就绪状态的线程获得了CPU资源，则开始执行run方法的线程执行体，此时处于运行状态。如果是单CPU的计算机，那么CPU的资源会不断在几个线程之间轮换，进程也会在就绪状态和运行状态之间不断切换。如果是多CPU的计算机，那么就可以有多个线程并行运行，但是若线程数多于CPU数量，还是会有多个线程轮流使用CPU资源的情况。\n当发生如下情况时，线程将会进入阻塞状态：\n\n线程调用**sleep()**方法主动放弃所占用的处理器资源。\n线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。\n线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。\n线程在等待某个通知（notify）。\n程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。\n\n针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，**让该线程重新进入就绪状态**：\n\n调用sleep()方法的线程经过了指定时间。\n线程调用的阻塞式IO方法已经返回。\n线程成功地获得了试图取得的同步监视器。\n线程正在等待某个通知时，其他线程发出了一个通知。收到了同质\n处于挂起状态的线程被调用了resume()恢复方法。\n\n线程会以如下三种方式结束，结束后就处于死亡状态：\n\nrun()或call()方法执行完成，线程正常结束。\n线程抛出一个未捕获的Exception或Error。\n直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，通常不推荐使用。\n\n一图流解释线程的生命周期\n\n4.6 如何实现线程同步？\n同步方法\n即有synchronized关键字修饰的方法，由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。需要注意， synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。\n\n同步代码块\n即有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。需值得注意的是，同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。\n\nReentrantLock\nJava 5新增了一个java.util.concurrent包来支持同步，其中ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。需要注意的是，ReentrantLock还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，因此不推荐使用。\n理解ReentrantLock\n\nvolatile\nvolatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。\n\n原子变量\n在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。例如AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中（如以原子方式增加的计数器），但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。\n\n\n可重入：什么是 “可重入”，可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。\n原子操作：原子操作是指不会被线程调度机制打断的操作\n4.7 说一说Java多线程之间的通信方式详解锁\n\nwait()、notify()、notifyAll()\n如果线程之间采用synchronized来保证线程安全，则可以利用wait()、notify()、notifyAll()来实现线程通信。这三个方法都不是Thread类中所声明的方法，而是Object类中声明的方法。原因是每个对象都拥有锁，所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作。并且因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。另外，这三个方法都是本地方法，并且被final修饰，无法被重写。\n\nwait()方法可以让当前线程释放对象锁并进入阻塞状态。notify()方法用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。notifyAll()用于唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。\n\n每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了已就绪（将要竞争锁）的线程，阻塞队列存储了被阻塞的线程。当一个阻塞线程被唤醒后，才会进入就绪队列，进而等待CPU的调度。反之，当一个线程被wait后，就会进入阻塞队列，等待被唤醒。\n\nawait()、signal()、signalAll()\n如果线程之间采用Lock来保证线程安全，则可以利用await()、signal()、signalAll()来实现线程通信。这三个方法都是Condition接口中的方法，该接口是在Java 1.5中出现的，它用来替代传统的wait+notify实现线程间的协作，它的使用依赖于 Lock。相比使用wait+notify，使用Condition的await+signal这种方式能够更加安全和高效地实现线程间协作。\nCondition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 。 必须要注意的是，Condition 的 await()&#x2F;signal()&#x2F;signalAll() 使用都必须在lock保护之内，也就是说，必须在lock.lock()和lock.unlock之间才可以使用。事实上，await()&#x2F;signal()&#x2F;signalAll() 与 wait()&#x2F;notify()&#x2F;notifyAll()有着天然的对应关系。即：Conditon中的await()对应Object的wait()，Condition中的signal()对应Object的notify()，Condition中的signalAll()对应Object的notifyAll()。\n\nBlockingQueue\nJava 5提供了一个BlockingQueue接口，虽然BlockingQueue也是Queue的子接口，但它的主要用途并不是作为容器，而是作为线程通信的工具。BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。\n程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。线程之间需要通信，最经典的场景就是生产者与消费者模型，而BlockingQueue就是针对该模型提供的解决方案。\n\n\n4.8 说一说Java同步机制中的wait和notify当程序使用Synchronized关键来保证线程安全时，可以使用wait()、notify()和notifyAll()方法来进行线程之间的通信。这三个方法是Object类中的方法，且被final修饰，不可重写。\nwait方法会让线程进入阻塞状态，而notify方法会唤醒线程，让其等待参与到锁的竞争中，而在竞争得到锁之后，就可以得到CPU资源，进入运行状态。\n每个锁对象都有两个队列，一个是阻塞队列，存放所有被阻塞的线程，等待被唤醒；一个是就绪队列，存放了已经被唤醒的线程，准备竞争锁。当一个线程被唤醒之后就会进入就绪队列，等待CPU的调度。当一个线程被wait之后，就会进入阻塞状态、阻塞队列。等待被唤醒。\n4.9 说一说sleep()和wait()的区别\nsleep()是Thread类中的静态方法，而wait()是Object类中的成员方法；\nsleep()可以在任何地方使用，而wait()只能在同步方法或同步代码块中使用；\nsleep()不会释放锁，而wait()会释放锁，并需要通过notify()&#x2F;notifyAll()重新获取锁。\n\nsleep是由线程来调用，wait是由对象来调用，执行对象是线程。\n4.10 说一说notify()、notifyAll()的区别\nnotify()\n用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。\n\nnotifyAll()\n用于唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。\n\n\n4.11 如何实现子线程先执行，主线程再执行？启动子线程后，立即调用该线程的join()方法，则主线程必须等待子线程执行完成后再执行。\nThread类提供了让一个线程等待另一个线程完成的方法——join()方法。当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的join线程执行完为止。\njoin()方法通常由使用线程的程序调用，以将大问题划分成许多小问题，每个小问题分配一个线程。当所有的小问题都得到处理后，再调用主线程来进一步操作。\n4.12 阻塞线程的方式有哪些？sleep 、 阻塞式IO方法、试图获取同步监视器、被wait在等待notify、被suspend挂起\n详见 4.5\n4.13 说一说synchronized与Lock的区别\nsynchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁。\nsynchronized可以用在代码块上、方法上；Lock只能写在代码里。\nsynchronized在代码执行完或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显示释放锁。\nsynchronized会导致线程拿不到锁一直等待；Lock可以设置获取锁失败的超时时间。\nsynchronized无法得知是否获取锁成功；Lock则可以通过tryLock得知加锁是否成功。\nsynchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平&#x2F;不公平，并可以细分读写锁以提高效率。\n\n4.14 说一说synchronized的底层实现原理（很复杂）好几把复杂\n4.15 synchronized可以修饰静态方法和静态代码块吗？synchronized可以修饰静态方法，但不能修饰静态代码块。\n当修饰静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁。看不懂在解释什么\nSynchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。\n4.16 谈谈ReentrantLock的实现原理ReentrantLock是基于AQS（AbstractQueuedSynchronizer）实现的。而AQS是一个有两个队列的抽象类，两个队列分别是同步队列、条件队列。其中同步队列是一个双向链表，里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而条件队列是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，AQS所做的就是管理这两个队列里面线程之间的等待状态-唤醒的工作。\n在同步对垒中，还有着两种模式，分别是独占模式和共享模式，这两种模式的区别就在于AQS在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应独占锁和共享锁。\nAQS是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承AQS然后重写获取锁的方式和释放锁的方式还有管理state，而ReentrantLock就是通过重写了AQS的tryAcquire和tryRelease方法实现的lock和unlock。\n\n首先ReentrantLock 实现了 Lock 接口，然后有3个内部类，其中**Sync内部类继承自AQS**，另外的两个内部类继承自Sync，这两个类分别是用来公平锁和非公平锁的。通过Sync重写的方法tryAcquire、tryRelease可以知道，**ReentrantLock实现的是AQS的独占模式，也就是独占锁，这个锁是悲观锁。**\n4.17 如果不使用synchronized和Lock，如何保证线程安全？\nvolatile\nvolatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。\n\n原子变量\n在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。例如AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中（如以原子方式增加的计数器），但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。\n\n本地存储\n可以通过ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。\n\n不可变的\n只要一个不可变的对象被正确地构建出来，那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态，“不可变”带来的安全性是最直接、最纯粹的。Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。String类是一个典型的不可变类，可以参考它设计一个不可变类。\n\n\n4.18 说一说Java中乐观锁和悲观锁的区别悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java中悲观锁是通过synchronized关键字或Lock接口来实现的。\n乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在CAS之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。\n4.19 公平锁与非公平锁是怎么实现的？在Java中实现锁的方式有两种，一种是使用Java自带的关键字synchronized对相应的类或者方法以及代码块进行加锁，另一种是ReentrantLock，前者只能是非公平锁，而后者是默认非公平但可实现公平的一把锁。\nReentrantLock是基于其内部类FairSync(公平锁)和NonFairSync(非公平锁)实现的，并且它的实现依赖于Java同步器框架AbstractQueuedSynchronizer（AQS），AQS使用一个整形的volatile变量state来维护同步状态，这个volatile变量是实现ReentrantLock的关键。我们来看一下ReentrantLock的类图：\n\nReentrantLock 的公平锁和非公平锁都委托了 AbstractQueuedSynchronizer#acquire 去请求获取。\n\ntryAcquire 是一个抽象方法，是公平与非公平的实现原理所在。\naddWaiter 是将当前线程结点加入等待队列之中。公平锁在锁释放后会严格按照等待队列去取后续值，而非公平锁在对于新晋线程有很大优势。\nacquireQueued 在多次循环中尝试获取到锁或者将当前线程阻塞。\nselfInterrupt 如果线程在阻塞期间发生了中断，调用 Thread.currentThread().interrupt() 中断当前线程。\n\n公平锁和非公平锁在说锁的获取上都使用到了 volatile 关键字修饰的state字段， 这是保证多线程环境下锁的获取与否的核心。但是当并发情况下多个线程都读取到 state == 0时，则必须用到CAS技术，一门CPU的原子锁技术，可通过CPU对共享变量加锁的形式，实现数据变更的原子操作。volatile 和 CAS的结合是并发抢占的关键。\n公平锁的实现机理在于每次有线程来抢占锁的时候，都会检查一遍有没有等待队列\n非公平锁在实现的时候多次强调随机抢占，与公平锁的区别在于新晋获取锁的进程会有多次机会去抢占锁，被加入了等待队列后则跟公平锁没有区别\n4.20 了解Java中的锁升级吗？JDK 1.6之前，synchronized 还是一个重量级锁，是一个效率比较低下的锁。但是在JDK 1.6后，JVM为了提高锁的获取与释放效率对synchronized 进行了优化，引入了偏向锁和轻量级锁 ，从此以后锁的状态就有了四种：无锁、偏向锁、轻量级锁、重量级锁。并且四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级，这四种锁的级别由低到高依次是：无锁、偏向锁，轻量级锁，重量级锁。如下图所示：\n\n\n无锁\n无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁的特点是修改操作会在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。\n\n偏向锁\n初次执行到synchronized代码块的时候，锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。\n偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。\n当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。\n偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。\n\n轻量级锁\n轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。\n轻量级锁的获取主要由两种情况：\n\n当关闭偏向锁功能时；\n由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。\n\n一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。\n在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。\n长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。\n\n重量级锁\n重量级锁显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。\n重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源。\n\n\n4.22 分段锁是怎么实现的？在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将同时导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。\n我们一般有三种方式降低锁的竞争程度：\n\n减少锁的持有时间；\n降低锁的请求频率；\n使用带有协调机制的独占锁，这些机制允许更高的并发性。\n\n在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这称为分段锁。其实说的简单一点就是：容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。\n如下图，ConcurrentHashMap使用Segment数据结构，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。所以说，ConcurrentHashMap在并发情况下，不仅保证了线程安全，而且提高了性能。\n\n4.23 说说你对读写锁的了解与传统锁不同的是读写锁的规则是可以共享读，但只能一个写，总结起来为：读读不互斥、读写互斥、写写互斥，而一般的独占锁是：读读互斥、读写互斥、写写互斥，而场景中往往读远远大于写，读写锁就是为了这种优化而创建出来的一种机制。注意是读远远大于写，一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高。因此需要根据实际情况选择使用。\n在Java中ReadWriteLock的主要实现为ReentrantReadWriteLock，其提供了以下特性：\n\n公平性选择：支持公平与非公平（默认）的锁获取方式，吞吐量非公平优先于公平。\n可重入：读线程获取读锁之后可以再次获取读锁，写线程获取写锁之后可以再次获取写锁。\n**可降级**：写线程获取写锁之后，其还可以再次获取读锁，然后释放掉写锁，那么此时该线程是读锁状态，也就是降级操作。(由写锁降级为读锁)\n\n4.24 volatile关键字有什么用？当一个变量被定义成volatile之后，它将具备两项特性：\n\n保证可见性\n当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，这个写操作会导致其他线程中的volatile变量缓存无效。\n\n禁止指令重排\n使用volatile关键字修饰共享变量可以禁止指令重排序，volatile禁止指令重排序有一些规则：\n\n当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行；\n在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。\n\n\n注意，虽然volatile能够保证可见性，但它不能保证原子性。volatile变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。\n4.25 谈谈volatile的实现原理volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：\n\n它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n它会强制将对缓存的修改操作立即写入主存；\n如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n4.26 说说你对JUC的了解JUC是java.util.concurrent的缩写，该包参考自EDU.oswego.cs.dl.util.concurrent，是JSR 166标准规范的一个实现。JSR 166是一个关于Java并发编程的规范提案，在JDK中该规范由java.util.concurrent包实现。即JUC是Java提供的并发包，其中包含了一些并发编程用到的基础组件。\nJUC这个包下的类基本上包含了我们在并发编程时用到的一些工具，大致可以分为以下几类：\n\n原子更新\nJava从JDK1.5开始提供了java.util.concurrent.atomic包，方便程序员在多线程环境下，无锁的进行原子操作。在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。\n\n锁和条件变量\njava.util.concurrent.locks包下包含了同步器的框架 AbstractQueuedSynchronizer，基于AQS构建的Lock以及与Lock配合可以实现等待&#x2F;通知模式的Condition。JUC 下的大多数工具类用到了Lock和Condition来实现并发。\n\n线程池\n涉及到的类比如：Executor、Executors、ThreadPoolExector、 AbstractExecutorService、Future、Callable、ScheduledThreadPoolExecutor等等。\n\n阻塞队列\n涉及到的类比如：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等等。\n\n并发容器\n涉及到的类比如：ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、CopyOnWriteArraySet等等。\n\n同步器\n剩下的是一些在并发编程中时常会用到的工具类，主要用来协助线程同步。比如：CountDownLatch、CyclicBarrier、Exchanger、Semaphore、FutureTask等等。\n\n\n4.27 说说你对AQS的理解抽象队列同步器AbstractQueuedSynchronizer （以下都简称AQS），是用来构建锁或者其他同步组件的骨架类，减少了各功能组件实现的代码量，也解决了在实现同步器时涉及的大量细节问题，例如等待线程采用FIFO队列操作的顺序。在不同的同步器中还可以定义一些灵活的标准来判断某个线程是应该通过还是等待。\nAQS采用模板方法模式，在内部维护了n多的模板的方法的基础上，子类只需要实现特定的几个方法（不是抽象方法！不是抽象方法！不是抽象方法！），就可以实现子类自己的需求。\n基于AQS实现的组件，诸如：\n\nReentrantLock 可重入锁（支持公平和非公平的方式获取锁）；\nSemaphore 计数信号量;\nReentrantReadWriteLock 读写锁。\n\nAQS其实主要做了这么几件事情：\n\n同步状态（state）的维护管理；\n等待队列的维护管理；\n线程的阻塞与唤醒。\n\n4.28 LongAdder解决了什么问题，它是如何实现的？4.29 介绍下ThreadLocal和它的应用场景4.30 请介绍ThreadLocal的实现原理，它是怎么处理hash冲突的？以上三条感觉不是很重要，有需要再看\n28-30\n4.31 介绍一下线程池线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。\n系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。\n与数据库连接池类似的是，线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个空闲的线程来执行它们的run()或call()方法，当run()或call()方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call()方法。\n从Java 5开始，Java内建支持线程池。Java 5新增了一个Executors工厂类来产生线程池，该工厂类包含如下几个静态工厂方法来创建线程池。创建出来的线程池，都是通过ThreadPoolExecutor类来实现的。\n\nnewCachedThreadPool()：创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存在线程池中。\nnewFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池。\nnewSingleThreadExecutor()：创建一个只有单线程的线程池，它相当于调用newFixedThread Pool()方法时传入参数为1。\nnewScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池，它可以在指定延迟后执行线程任务。corePoolSize指池中所保存的线程数，即使线程是空闲的也被保存在线程池内。\nnewSingleThreadScheduledExecutor()：创建只有一个线程的线程池，它可以在指定延迟后执行线程任务。\nExecutorService newWorkStealingPool(int parallelism)：创建持有足够的线程的线程池来支持给定的并行级别，该方法还会使用多个队列来减少竞争。\nExecutorService newWorkStealingPool()：该方法是前一个方法的简化版本。如果当前机器有4个CPU，则目标并行级别被设置为4，也就是相当于为前一个方法传入4作为参数。\n\n4.32 介绍一下线程池的工作流程\n\n判断核心线程池是否已满，没满则创建一个新的工作线程来执行任务。\n判断**任务队列是否已满**，没满则将新提交的任务添加在工作队列。\n判断整个线程池是否已满，没满则创建一个新的工作线程来执行任务，已满则执行饱和（拒绝）策略。\n\n4.33 线程池都有哪些状态？线程池一共有五种状态, 分别是：\n\nRUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务。\n\nSHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。\n\nSTOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。\n\nTIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。\n\nTERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。进入TERMINATED的条件如下：\n\n线程池不是RUNNING状态；\n线程池状态不是TIDYING状态或TERMINATED状态；\n如果线程池状态是SHUTDOWN并且workerQueue为空；\nworkerCount为0；\n设置TIDYING状态成功。\n\n\n\n\n上面这部分讲的其实不是很好\n4.34 谈谈线程池的拒绝策略当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：\n\nAbortPolicy：丢弃任务并抛出RejectedExecutionException异常。\nDiscardPolicy：也是丢弃任务，但是不抛出异常。\nDiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复该过程）。\nCallerRunsPolicy：由调用线程处理该任务。？\n\n4.35 线程池的队列大小你通常怎么设置？\nCPU密集型任务\n尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。\n\nIO密集型任务\n可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。\n\n混合型任务\n可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。\n\n\n4.36 线程池有哪些参数，各个参数的作用是什么？线程池主要有如下6个参数：\n\ncorePoolSize（核心工作线程数）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时。\nmaximumPoolSize（最大线程数）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。\nkeepAliveTime（多余线程存活时间）：当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。\nworkQueue（队列）：用于**传输和保存等待执行任务的阻塞队列**。\nthreadFactory（线程创建工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。\nhandler（拒绝策略）：当线程池和队列都满了，再加入线程会执行此策略。\n\n​\ttimeunit，时间单位，用来设置上面各种时间的单位（分钟、秒、毫秒）\n5.JVM5.1 JVM包含哪几部分？类加载器、运行时数据区（内存分区）、执行引擎、本地库接口。\n\nJVM 是执行 Java 程序的虚拟计算机系统，那我们来看看执行过程：首先需要准备好编译好的 Java 字节码文件（即class文件），计算机要运行程序需要先通过一定方式（类加载器）将 class 文件加载到内存中（运行时数据区），但是字节码文件是JVM定义的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解释器（执行引擎）将字节码翻译成特定的操作系统指令集交给 CPU 去执行，这个过程中会需要调用到一些不同语言为 Java 提供的接口（例如驱动、地图制作等），这就用到了本地 Native 接口（本地库接口）。\n\nClassLoader：负责加载字节码文件即 class 文件，class 文件在文件开头有特定的文件标示，并且 ClassLoader 只负责class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。\nRuntime Data Area：是存放数据的，分为五部分：Stack（虚拟机栈），Heap（堆），Method Area（方法区），PC Register（程序计数器），Native Method Stack（本地方法栈）。几乎所有的关于 Java 内存方面的问题，都是集中在这块。\nExecution Engine：执行引擎，也叫 Interpreter。Class 文件被加载后，会把指令和数据信息放入内存中，Execution Engine 则负责把这些命令解释给操作系统，即将 java 指令集翻译为操作系统指令集。\nNativeInterface：负责调用本地接口的。他的作用是调用不同语言的接口给 JAVA 用，他会在 Native Method Stack 中记录对应的本地方法，然后调用该方法时就通过 Execution Engine 加载对应的本地 lib。原本多用于一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。\n\n5.2 JVM是如何运行的？JVM的启动过程分为如下四个步骤：\n\nJVM的装入环境和配置\njava.exe负责查找  JRE，并且它会按照如下的顺序来选择JRE：\n\n自己目录下的JRE；\n父级目录下的JRE；\n查注册中注册的JRE。\n\n\n装载JVM\n通过第一步找到JVM的路径后，Java.exe通过LoadJavaVM来装入JVM文件。LoadLibrary装载JVM动态连接库，然后把JVM中的到处函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMIntArgs 挂接到InvocationFunction 变量的CreateJavaVM和GetDafaultJavaVMInitArgs 函数指针变量上。JVM的装载工作完成。\n\n初始化JVM，获得本地调用接口\n调用InvocationFunction -&gt; CreateJavaVM，也就是JVM中JNI_CreateJavaVM方法获得JNIEnv结构的实例。\n\n运行Java程序\nJVM运行Java程序的方式有两种：jar包 与 class。\n运行jar 的时候，java.exe调用GetMainClassName函数，该函数先获得JNIEnv实例然后调用JarFileJNIEnv类中getManifest()，从其返回的Manifest对象中取getAttrebutes(“Main-Class”)的值，即jar 包中文件：META-INF&#x2F;MANIFEST.MF指定的Main-Class的主类名作为运行的主类。之后main函数会调用Java.c中LoadClass方法装载该主类（使用JNIEnv实例的FindClass）。\n运行Class的时候，main函数直接调用Java.c中的LoadClass方法装载该类。\n\n\n5.3 Java程序是怎么运行的？Java 源代码文件经过 Java 编译器编译成字节码文件后，通过类加载器加载到内存中，才能被实例化，然后到 Java 虚拟机中解释执行，最后通过操作系统操作 CPU 执行获取结果。\n\n5.4 本地方法栈有什么用？本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。\n《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。\n5.5 没有程序计数器会怎么样？没有程序计数器，Java程序中的流程控制将无法得到正确的控制，多线程也无法正确的轮换。\n程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\n如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。\n5.6 说一说Java的内存分布情况Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域。\n\n\n程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\n如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。\n\nJava虚拟机栈与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧[插图]**（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。\n\n栈深度溢出，StackOverFlow\n内存溢出（不够了），OutOfMemory\n\n\n本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。\n虚拟机栈为java字节码服务，而本地方法栈为本地方法服务。\n《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。\n\nJava堆对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。\n根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。\nJava堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。\n\n方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。\n根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。\n\n运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。\n\n直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。\n显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。\n\n\n5.7 类存放在哪里？方法区。\n5.8 局部变量存放在哪里？虚拟机栈\n与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储**局部变量表**、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。\n5.9 介绍一下Java代码的编译过程从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下所示。\n\n准备过程：初始化插入式注解处理器。\n\n解析与填充符号表过程，包括：\n\n词法、语法分析，将源代码的字符流转变为标记集合，构造出抽象语法树。\n填充符号表，产生符号地址和符号信息。\n\n\n插入式注解处理器的注解处理过程：\n在Javac源码中，插入式注解处理器的初始化过程是在initPorcessAnnotations()方法中完成的，而它的执行过程则是在processAnnotations()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。\n\n分析与字节码生成过程，包括：\n\n标注检查，对语法的静态信息进行检查。\n数据流及控制流分析，对程序动态运行过程进行检查。\n解语法糖，将简化代码编写的语法糖还原为原有的形式。\n字节码生成，将前面各个步骤所生成的信息转化成字节码。\n\n\n\n上述3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号，从总体来看，三者之间的关系与交互顺序如图所示。\n\n5.10 介绍一下类加载的过程一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下图所示。\t\n一、加载（二进制字节流 -&gt; 方法区中的运行时数据）\n“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，在加载阶段，Java虚拟机需要完成以下三件事情：\n\n通过一个类的全限定名来获取定义此类的二进制字节流。\n将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n在内存中（堆）生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。\n\n加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。\n二、验证\n验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。\n\n文件格式验证：\n第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。\n\n元数据验证：\n第二阶段是对字节码描述的信息进行语法分析，以保证其描述的信息符合《Java语言规范》的要求。\n\n字节码验证：\n第三阶段是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。\n\n符号引用验证：\n符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。\n\n\n三、准备\n准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的。而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。\n四、解析\n解析阶段是Java虚拟机将**常量池内的符号引用替换为直接引用**的过程，符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？\n符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。\n直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。\n五、初始化\n类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。\n进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。\n5.11 介绍一下对象的实例化过程对象实例化过程，就是**执行类构造函数对应在字节码文件中的&lt;init&gt;()方法(实例构造器)**，&lt;init&gt;()方法由非静态变量、非静态代码块以及对应的构造器组成。\n\n&lt;init&gt;()方法可以重载多个，类有几个构造器就有几个&lt;init&gt;()方法；\n&lt;init&gt;()方法中的代码执行顺序为：父类变量初始化、父类代码块、父类构造器、子类变量初始化、子类代码块、子类构造器。\n\n静态变量、静态代码块、普通变量、普通代码块、构造器的执行顺序如下图：\n\n5.12 元空间在栈内还是栈外？在栈外，元空间占用的是本地内存。\n在Java 8 中称为元空间（Meta Space），在Java 7 及以前称为方法区。\n许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代“，或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。\n5.13 谈谈JVM的类加载器，以及双亲委派模型一、类加载器\nJava虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。  允许用户自定义类加载器。\n类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：类加载器可以比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。\n二、双亲委派模型\n自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。对于这个时期的Java应用，绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载。\n这些类加载器之间的协作关系“通常”会如下图所示，图中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。\n\n\n\n\n如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给上层的加载器，如果上层类加载器还存在其上层类加载器，则进一步向上委托，依次递归，直到请求最终到达顶层的启动类加载器，从顶层类加载器开始，如果类加载器根据类的全限定名查询到已经加载过这个类，就成功返回加载过的此类信息，倘若加载器未加载过此类，则原路返回给下层加载器继续重复此过程，直到最先加载此类的加载器所有上层加载器都未加载过此类后，此类加载器才会尝试自己去加载，这便是双亲委派模式。\n5.15 介绍一下Java的垃圾回收（GC）机制Java垃圾回收主要针对堆内存\n一、哪些内存需要回收在Java内存运行时区域的各个部分中，堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理，我们平时所说的内存分配与回收也仅仅特指这一部分内存。\n二、怎么定义垃圾引用计数算法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。\n但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。\n举个简单的例子：对象objA和objB都有字段instance，赋值令objA.instance&#x3D;objB及objB.instance&#x3D;objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。\n可达性分析算法：当前主流的商用程序语言的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。\n如下图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。\n\n\n在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：\n\n在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。\n在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。\n在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。\n在本地方法栈中JNI（即通常所说的Native方法）引用的对象。\nJava虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。\n所有被同步锁（synchronized关键字）持有的对象。\n反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。\n\n回收方法区：方法区的垃圾收集主要回收两部分内容：**废弃的常量和不再使用的类型**。回收废弃常量与回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。\n判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：\n\n该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。\n**加载该类的类加载器已经被回收**，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。\n该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n三、怎么回收垃圾分代收集理论：当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（GenerationalCollection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：\n\n弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。\n强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。\n\n这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时**只关注如何保留少量存活**而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。\n标记-清除算法：最早出现也是最基础的垃圾收集算法是“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先**标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来**，标记存活的对象，统一回收所有未被标记的对象。\n它的主要缺点有两个：第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会**产生大量不连续的内存碎片*，空间碎片太多可能会导致当以后在程序运行过程中*需要分配较大对象时无法找到足够的连续内存而不得不**提前触发另一次垃圾收集动作。标记-清除算法的执行过程如下图所示。\n\n\n\n\n标记-复制算法：为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将**可用内存缩小为了原来的一半**，空间浪费未免太多了一点。标记-复制算法的执行过程如下图所示。\n\n\n（赋值到另一半区的对象是按顺序存储的）\n在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。\n标记-整理算法：标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。\n针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如下图所示。\n\n\n（感觉标记整理可以用于老年代的GC）\n5.16 请介绍一下分代回收机制当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（GenerationalCollection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：\n\n弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。\n强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。\n\n这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。\n分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。假如要现在进行一次只局限于新生代区域内的收集，但**新生代中的对象是完全有可能被老年代所引用**的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：\n\n跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。\n\n依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（称为“记忆集”，RememberedSet），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。\n5.17 JVM中一次完整的GC流程是怎样的？新创建的对象一般会被分配在新生代中，常用的新生代的垃圾回收器是 ParNew 垃圾回收器，它按照 8:1:1 将新生代分成 Eden 区，以及两个 Survivor 区。某一时刻，我们创建的对象将 Eden 区全部挤满，这个对象就是挤满新生代的最后一个对象。此时，Minor GC 就触发了。\n在正式 Minor GC 前，JVM 会先检查新生代中对象，是比老年代中剩余空间大还是小。为什么要做这样的检查呢？原因很简单，假如 Minor GC 之后 Survivor 区放不下剩余对象，这些对象就要进入到老年代，所以要提前检查老年代是不是够用。这样就有两种情况：\n\n老年代剩余空间大于新生代中的对象大小，那就直接Minor GC，GC完survivor不够放，老年代也绝对够放；\n\n老年代剩余空间小于新生代中的对象大小，这个时候就要查看是否启用了“**老年代空间分配担保规则**”，具体来说就是看 -XX:-HandlePromotionFailure 参数是否设置了。\n老年代空间分配担保规则是这样的，**如果老年代中剩余空间大小，大于历次 Minor GC 之后剩余对象的大小，那就允许进行 Minor GC**。因为从概率上来说，以前的放的下，这次的也应该放的下。那就有两种情况：\n老年代中剩余空间大小，大于历次Minor GC之后剩余对象的大小，进行 Minor GC；\n老年代中剩余空间大小，小于历次Minor GC之后剩余对象的大小，进行Full GC，把老年代空出来再检查。\n\n\n开启老年代空间分配担保规则只能说是大概率上来说，Minor GC 剩余后的对象够放到老年代，所以当然也会有万一，Minor GC 后会有这样三种情况：\n\nMinor GC 之后的对象足够放到 Survivor 区，皆大欢喜，GC 结束；\nMinor GC 之后的对象不够放到 Survivor 区，接着进入到老年代，老年代能放下，那也可以，GC 结束；\nMinor GC 之后的对象不够放到 Survivor 区，老年代也放不下，那就只能 Full GC。\n\n前面都是成功 GC 的例子，还有 3 中情况，会导致 GC 失败，报 OOM：\n\n紧接上一节 Full GC 之后，老年代任然放不下剩余对象，就只能 OOM；\n未开启老年代分配担保机制，且一次 Full GC 后，老年代任然放不下剩余对象，也只能 OOM；\n开启老年代分配担保机制，但是担保不通过，一次 Full GC 后，老年代任然放不下剩余对象，也是能 OOM。\n\nGC完整流程，参考下图：（**先判断老年代情况，再判断survive区，再判断一次老年代**）\n\n5.18 Full GC会导致什么？Full GC会“Stop The World”，即在GC期间全程暂停用户的应用程序。\n5.19 JVM什么时候触发GC，如何减少FullGC的次数？当 Eden 区的空间耗尽时 Java 虚拟机便会触发一次 Minor GC 来收集新生代的垃圾，存活下来的对象，则会被送到 Survivor 区，简单说就是当新生代的Eden区满的时候触发 Minor GC。\nserial GC 中，老年代内存剩余已经小于之前年轻代晋升老年代的平均大小，则进行 Full GC。而在 CMS 等并发收集器中则是每隔一段时间检查一下老年代内存的使用量，超过一定比例时进行 Full GC 回收。\n可以采用以下措施来减少Full GC的次数：\n\n增加方法区的空间；\n增加老年代的空间；\n减少新生代的空间；\n禁止使用System.gc()方法；\n使用标记-整理算法，尽量保持较大的连续内存空间；\n排查代码中无用的大对象。\n\n5.20 如何确定对象是可回收的？对象被判定为是“垃圾”就可以被回收。具体见5.15的二\n5.21 对象如何晋升到老年代？虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。\n5.22 为什么老年代不能使用标记复制？因为老年代保留的对象都是难以消亡的，而标记复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低，所以在老年代一般不能直接选用这种算法。\n5.23 新生代为什么要分为Eden和Survivor，它们的比例是多少？现在的商用Java虚拟机大多都优先采用了“标记-复制算法”去回收新生代。\n实际上，新生代中的对象有98%熬不过第一轮收集。\n平时对象的分配都是分配在Eden区，当Eden区快满时触发垃圾回收，将存活的对象转移到其中一块Survivor区中，然后对Eden区进行清除。等到Eden区再次填满时，Eden区域的存活对象和使用过的Survivor区域的存活对象转移到空的Survivor区域中，然后清除Eden区和之前的Survivor区。就这样始终保存一块Survivor是空的等待接受存活对象，循环使用三块内存。这样可用内存就变成了90%，而不是之前的50%这也就是为什么新生代要划分为三块区域，这样做既能减少内存碎片，也能提高内存的使用效率。\nHotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。\n5.24 为什么要设置两个Survivor区域？设置两个 Survivor 区最大的好处就是解决内存碎片化。\n我们先假设一下，Survivor 只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有 2 个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。\n这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。\n5.25 说一说你对GC算法的了解。GC算法其实就是回收垃圾的三个算法。详见5.15的三\n5.26 为什么新生代和老年代要采用不同的回收算法？如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间。如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。\n5.27 请介绍G1垃圾收集器链接\n5.28 请介绍CMS垃圾收集器地址同上\n5.29 内存泄漏和内存溢出有什么区别？内存泄漏（memory leak）：内存泄漏指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。\n内存溢出（out of memory）：简单地说内存溢出就是指程序运行过程中**申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。\n5.30 什么是内存泄漏，怎么解决？内存泄漏的根本原因是**长生命周期的对象持有短生命周期对象的引用**，尽管短生命周期的对象已经不再需要，但由于长生命周期对象持有它的引用而导致不能被回收。以发生的方式来分类，内存泄漏可以分为4类：\n\n常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。\n偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。\n一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。\n隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。\n\n避免内存泄漏的几点建议：\n\n尽早释放无用对象的引用。\n避免在循环中创建对象。\n使用字符串处理时避免使用String，应使用StringBuffer。\n尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。\n\n5.31 什么是内存溢出，怎么解决？内存溢出（out of memory）：简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。\n引起内存溢出的原因有很多种，常见的有以下几种：\n\n内存中加载的数据量过于庞大，如一次从数据库取出过多数据；\n集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；\n代码中存在死循环或循环产生过多重复的对象实体；\n使用的第三方软件中的BUG；\n启动参数内存值设定的过小。\n\n内存溢出的解决方案：\n\n第一步，修改JVM启动参数，直接增加内存。\n第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。\n第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。\n第四步，**使用内存查看工具动态查看内存使用情况**。\n\n5.32 哪些区域会OOM，怎么触发OOM？除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。\n\nJava堆溢出\nJava堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。\n\n虚拟机栈和本地方法栈溢出\nHotSpot虚拟机中并不区分虚拟机栈和本地方法栈，如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。\n\n方法区和运行时常量池溢出\n方法区溢出也是一种常见的内存溢出异常，在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。这类场景常见的包括：程序使用了CGLib字节码增强和动态语言、大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。\n在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，即常量池是方法区的一部分，所以上述问题在常量池中也同样会出现。而HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代，所以上述问题在JDK 8中会得到避免。\n\n本地直接内存溢出\n直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致。如果直接通过反射获取Unsafe实例进行内存分配，并超出了上述的限制时，将会引发OOM异常。\n\n\n","categories":["八股文"],"tags":["java"]},{"title":"关于本站-README","url":"/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99-readme/","content":"写在最前\n声明：本章文章都是作笔记用，便于本人查看，若出于学习目的翻看文章可能效果不佳！\n\n本站通过hexo搭建，通过github的Pages部署于线上。\n\n本站用作数媒三班201913160628的2022年5月人机交互实验课成果展示 。\n\n\n\n网站日志2022.5.19完成了绝大多数网站的配置，主体搭建完毕，所有效果正常实现。主要如下：\n\n网站logo、个人头像、网站首屏\n文章图片显示（部分网链图片可能无法正常显示，后续会转为本地图片方式发布）\n鼠标悬浮后文章scale效果 \n通过wordcount插件开启文章字数统计  \nMac风格代码块复制功能   \n浏览数据记录及显示（不蒜子）\n通过 generator-searchdb 实现站内搜索  \n配置pjax实现页面跳转的彩色进度条\n补充社交按钮：github、mail\n\n2022.5.20\n陆续上传更新之前本地保存的笔记为文章。\n将网站README置顶。\n\n"},{"title":"剑指offer刷题记录","url":"/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"笔记：对于一个算法，如果需要考虑特殊情况，那么一定不是最佳的代码\n关于二分查找，使用 low + (high - low)&#x2F;2 与 使用 (low + high)&#x2F;2 的区别 只 在于，前者可以避免数值溢出。\n二分查找：左中比较，跳出条件是 l &lt;&#x3D; r ； 中右比较，跳出条件是 l &lt; r 。\n一些算法：水塘抽样算法随机取值，依次遍历，每一次都在当前次数的范围内取随机数，如果这个随机数等于0，暂时记为ans。\n全部遍历完之后再返回最后一次得到的ans。（可以保证每个数被取的概率都一样）\n522.最优除法\n方法一：动态规划class Solution &#123;    public String optimalDivision(int[] nums) &#123;        int n = nums.length;        Node[][] dp = new Node[n][n];        for (int i = 0; i &lt; n; i++) &#123;            for (int j = i; j &lt; n; j++) &#123;                dp[i][j] = new Node();            &#125;        &#125;        for (int i = 0; i &lt; n; i++) &#123;            dp[i][i].minVal = nums[i];            dp[i][i].maxVal = nums[i];            dp[i][i].minStr = String.valueOf(nums[i]);            dp[i][i].maxStr = String.valueOf(nums[i]);        &#125;        for (int i = 1; i &lt; n; i++) &#123;            for (int j = 0; j + i &lt; n; j++) &#123;                for (int k = j; k &lt; j + i; k++) &#123;                    if (dp[j][j + i].maxVal &lt; dp[j][k].maxVal / dp[k + 1][j + i].minVal) &#123;                        dp[j][j + i].maxVal = dp[j][k].maxVal / dp[k + 1][j + i].minVal;                        if (k + 1 == j + i) &#123;                            dp[j][j + i].maxStr = dp[j][k].maxStr + &quot;/&quot; + dp[k + 1][j + i].minStr;                        &#125; else &#123;                            dp[j][j + i].maxStr = dp[j][k].maxStr + &quot;/(&quot; + dp[k + 1][j + i].minStr + &quot;)&quot;;                        &#125;                    &#125;                    if (dp[j][j + i].minVal &gt; dp[j][k].minVal / dp[k + 1][j + i].maxVal) &#123;                        dp[j][j + i].minVal = dp[j][k].minVal / dp[k + 1][j + i].maxVal;                        if (k + 1 == j + i) &#123;                            dp[j][j + i].minStr = dp[j][k].minStr + &quot;/&quot; + dp[k + 1][j + i].maxStr;                         &#125; else &#123;                            dp[j][j + i].minStr = dp[j][k].minStr + &quot;/(&quot; + dp[k + 1][j + i].maxStr + &quot;)&quot;;                         &#125;                    &#125;                &#125;            &#125;        &#125;        return dp[0][n - 1].maxStr;    &#125;&#125;class Node &#123;    double maxVal, minVal;    String minStr, maxStr;    public Node() &#123;        this.minVal = 10000.0;        this.maxVal = 0.0;    &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/optimal-division/solution/zui-you-chu-fa-by-leetcode-solution-lf4c/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n方法二：数学用第一个数，除以剩下所有数字的相除。\n1&#x2F;（2&#x2F;（3&#x2F;（4&#x2F;（5&#x2F;6））））以此类推，只需要在变String的时候加上括号即可。\nclass Solution &#123;    public String optimalDivision(int[] nums) &#123;        int n = nums.length;                if (n == 1) &#123;            return String.valueOf(nums[0]);        &#125;        if (n == 2) &#123;            return String.valueOf(nums[0]) + &quot;/&quot; + String.valueOf(nums[1]);        &#125;        StringBuffer res = new StringBuffer();        res.append(nums[0]);        res.append(&quot;/(&quot;);        res.append(nums[1]);        for (int i = 2; i &lt; n; i++) &#123;            res.append(&quot;/&quot;);            res.append(nums[i]);        &#125;        res.append(&quot;)&quot;);        return res.toString();    &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/optimal-division/solution/zui-you-chu-fa-by-leetcode-solution-lf4c/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n剑指二014 M\n只有当两个字符串每个字符的个数均相等时，一个字符串才是另一个字符串的变位词。\n方法一：滑动窗口记s1的字符串长度为n，在s2中遍历所有长度为n的子串，当两个串包含的字母个数都一致时满足\nclass Solution &#123;    public boolean checkInclusion(String s1, String s2) &#123;        int n = s1.length(), m = s2.length();        if (n &gt; m) &#123;            return false;        &#125;        int[] cnt1 = new int[26];        int[] cnt2 = new int[26];        for (int i = 0; i &lt; n; ++i) &#123;            ++cnt1[s1.charAt(i) - &#x27;a&#x27;];            ++cnt2[s2.charAt(i) - &#x27;a&#x27;];        &#125;        if (Arrays.equals(cnt1, cnt2)) &#123;            return true;        &#125;        for (int i = n; i &lt; m; ++i) &#123;            ++cnt2[s2.charAt(i) - &#x27;a&#x27;];            --cnt2[s2.charAt(i - n) - &#x27;a&#x27;];            if (Arrays.equals(cnt1, cnt2)) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/MPnaiL/solution/zi-fu-chuan-zhong-de-bian-wei-ci-by-leet-wbma/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n优化：\n由于每次比较只有一个字符位置的改动，而每一次比较都是两个数组之间的比较，所以用中间值记录\nclass Solution &#123;    public boolean checkInclusion(String s1, String s2) &#123;        int n = s1.length(), m = s2.length();        if (n &gt; m) &#123;            return false;        &#125;        int[] cnt = new int[26];        for (int i = 0; i &lt; n; ++i) &#123;            --cnt[s1.charAt(i) - &#x27;a&#x27;];            ++cnt[s2.charAt(i) - &#x27;a&#x27;];        &#125;        int diff = 0;        for (int c : cnt) &#123;            if (c != 0) &#123;                ++diff;            &#125;        &#125;        if (diff == 0) &#123;            return true;        &#125;        for (int i = n; i &lt; m; ++i) &#123;            int x = s2.charAt(i) - &#x27;a&#x27;, y = s2.charAt(i - n) - &#x27;a&#x27;;            if (x == y) &#123;                continue;            &#125;            if (cnt[x] == 0) &#123;                ++diff;            &#125;            ++cnt[x];            if (cnt[x] == 0) &#123;                --diff;            &#125;            if (cnt[y] == 0) &#123;                ++diff;            &#125;            --cnt[y];            if (cnt[y] == 0) &#123;                --diff;            &#125;            if (diff == 0) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;\n\n方法二：双指针class Solution &#123;    public boolean checkInclusion(String s1, String s2) &#123;        int n = s1.length(), m = s2.length();        if (n &gt; m) &#123;            return false;        &#125;        int[] cnt = new int[26];        for (int i = 0; i &lt; n; ++i) &#123;            --cnt[s1.charAt(i) - &#x27;a&#x27;];        &#125;        int left = 0;        for (int right = 0; right &lt; m; ++right) &#123;            int x = s2.charAt(right) - &#x27;a&#x27;;            ++cnt[x];            while (cnt[x] &gt; 0) &#123;                --cnt[s2.charAt(left) - &#x27;a&#x27;];                ++left;            &#125;            if (right - left + 1 == n) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;\n\n总结：当有需要换位的操作时，考虑使用字典、双指针，使用滑动窗口需要考虑滑动时产生的变化，只着眼于变化，而不比较整个窗口\n剑指09 两个栈实现队列一个栈用来加入元素，第二个栈用来删除元素。\n加入元素时，直接加入第一个栈。\n删除元素时，把第一个栈的元素按顺序pop到第二个栈里面，再pop第二个栈的栈顶元素。则此时是后进后出，先进先出，满足队列的要求。\n剑指30 包含min函数的栈一个正常的栈执行pop、push、top等操作。再用另一个辅助栈来存放每次的新进来的最小值。\n或是辅助站直接在每一次push操作时，记录当下对应的最小值。\nclass MinStack &#123;    Stack&lt;Integer&gt; A, B;    public MinStack() &#123;        A = new Stack&lt;&gt;();        B = new Stack&lt;&gt;();    &#125;    public void push(int x) &#123;        A.add(x);        if(B.empty() || B.peek() &gt;= x)            B.add(x);\t//每一次push都判断是否是新的最小值，若是则加入辅助栈    &#125;    public void pop() &#123;    \t//若是A栈pop的元素恰好是当前最小值，那么辅助栈的最小值也要出栈。        if(A.pop().equals(B.peek()))\t            B.pop();    &#125;    public int top() &#123;        return A.peek();    &#125;    public int min() &#123;        return B.peek();    &#125;&#125;\n\n法二：维护一个和数据栈一样大小的辅助栈\nclass MinStack &#123;    private Stack&lt;Integer&gt; dataStack; // 数据栈    private Stack&lt;Integer&gt; minStack; // 辅助栈，记录每次有元素进栈后或者出栈后，元素的最小值    /** initialize your data structure here. */    public MinStack() &#123;        // 初始化辅助栈和数据栈        dataStack = new Stack&lt;&gt;();        minStack = new Stack&lt;&gt;();    &#125;    public void push(int x) &#123;        // 如果记录当前数据栈中最小值的辅助栈为空，或者最小值小于 x，则将 x 设置为最小值，即进辅助栈        if(minStack.isEmpty() || minStack.peek() &gt; x)&#123;            minStack.push(x);        &#125;else&#123;// 如果数据栈中当前最小值 &lt; x, 则继续将最小值设置为上次的最小值            minStack.push(minStack.peek());        &#125;        dataStack.push(x);// 数据栈，进栈    &#125;    public void pop() &#123;        minStack.pop();// 辅助栈，栈出栈        dataStack.pop();// 数据栈，出栈    &#125;    public int top() &#123;        return dataStack.peek();    &#125;    public int min() &#123;        return minStack.peek();    &#125;&#125;\n\n\n\n剑指24 反转链表栈方法（最简单直接）：\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if(head==null)&#123;            return null;        &#125;        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        while(head.next!=null)&#123;            stack.push(head.val);            head = head.next;        &#125;        stack.push(head.val);        ListNode ansHead = new ListNode();        ListNode temp = ansHead;        while(stack.size()&gt;1)&#123;            temp.val = stack.pop();            temp.next = new ListNode();            temp = temp.next;        &#125;        temp.val = stack.pop();        temp.next = null;        return ansHead;    &#125;&#125;\n\n\n\n迭代法：\n一定至少要有两个中间变量\nclass Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode cur = head;        ListNode pre = null;        while(cur!=null)&#123;            ListNode next = cur.next;            cur.next = pre;            pre = cur;            cur = next;        &#125;        return pre;    &#125;&#125;\n\n\n\n剑指53-② 0~n-1中缺失的数字一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n遍历法：\n根据题目特点，直接从左到右遍历数组，找到第一个下标与元素不相等的位置即可。\n二分查找法：\n根据元素是否等于下标作为依据判断左右指针的左移右移，当最后停止循环，说明左指针大于右指针，此时左指针刚好就指向了所求的元素。\npublic int missingNumber(int[] nums) &#123;    int left = 0, right = nums.length-1;    while(left&lt;=right)&#123;        int mid = (left + right )/2;//(left+right)/2        if(mid!=nums[mid])&#123;  //缺少的数字在当前mid的左边,判断只能用!=，不能用&gt;。            right = mid-1;        &#125;        else&#123;            left = mid+1;        &#125;    &#125;    return left;&#125;\n\n\n\n剑指53-① 在排序数组中查找数字统计一个数字在排序数组中出现的次数。\n根据二分查找，找到目标数字出现的第一次（左指针）和最后一次（右指针）。\nclass Solution &#123;    public int search(int[] nums, int target) &#123;        int leftIdx = binarySearch(nums, target, true);        int rightIdx = binarySearch(nums, target, false) - 1;        if (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;            return rightIdx - leftIdx + 1;        &#125;         return 0;    &#125;    public int binarySearch(int[] nums, int target, boolean lower) &#123;        int left = 0, right = nums.length - 1, ans = nums.length;        while (left &lt;= right) &#123;            int mid = (left + right) / 2;            if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;                right = mid - 1;                ans = mid;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;        return ans;    &#125;&#125;作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-wl6kr/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n\n自己写的二分查找方法：\nclass Solution &#123;    public int search(int[] nums, int target) &#123;        int leftIdx = binarySearch(nums, target, true);        int rightIdx = binarySearch(nums, target, false) - 1;        if (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;            return rightIdx - leftIdx + 1;        &#125;         return 0;    &#125;    public int binarySearch(int[] nums, int target, boolean lower) &#123;        int left = 0, right = nums.length - 1, ans = nums.length;        while (left &lt;= right) &#123;            int mid = (left + right) / 2;            if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;                right = mid - 1;                ans = mid;            &#125; else &#123;                left = mid + 1;            &#125;        &#125;        return ans;    &#125;&#125;\n\n\n\n剑指50 第一个只出现一次的字符在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。\n队列+哈希表：\n遍历字符串，通过队列记录字符出现的先后顺序，同时用map来标记字符是否出现过多次。\n如果只用哈希表，只能记录字母出现的次数，无法得知出现的先后顺序\n单纯地通过字符数组记录并不能确定第一个出现的字母，而是在字符数组中的第一个\nQueue&lt;Character&gt; queue = new LinkedList&lt;&gt;();Map&lt;Character,Boolean&gt; map = new HashMap&lt;&gt;();char ans = &#x27; &#x27;;for(int i = 0;i&lt;s.length();i++)&#123;    char temp = s.charAt(i);    if(map.containsKey(temp))&#123;        //已经出现过的字母标记为False        map.put(temp,false);    &#125;    else&#123;        map.put(temp,true);        queue.offer(temp);    &#125;&#125;while(queue.size()&gt;0)&#123;    char judge = queue.poll();    if(map.get(judge))&#123;        ans = judge;        break;    &#125;&#125;return ans;\n\n\n\n用哈希表记录索引：\n第一次遍历，记录每个字符出现的第一次所在的索引，如果出现多次，更新为-1。第二次遍历哈希表，找到大于-1的最小值。（重点要知道如何遍历哈希表，entrySet）\nclass Solution &#123;    public char firstUniqChar(String s) &#123;        Map&lt;Character, Integer&gt; position = new HashMap&lt;Character, Integer&gt;();        int n = s.length();        for (int i = 0; i &lt; n; ++i) &#123;            char ch = s.charAt(i);            if (position.containsKey(ch)) &#123;                position.put(ch, -1);            &#125; else &#123;                position.put(ch, i);            &#125;        &#125;        int first = n;        for (Map.Entry&lt;Character, Integer&gt; entry : position.entrySet()) &#123;            int pos = entry.getValue();            if (pos != -1 &amp;&amp; pos &lt; first) &#123;                first = pos;            &#125;        &#125;        return first == n ? &#x27; &#x27; : s.charAt(first);    &#125;&#125;\n\n\n\n剑指11 旋转数组中最小元素：给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  \n二分查找（左中比较）：\nclass Solution &#123;    public int minArray(int[] numbers) &#123;        int l = 0;        int r = numbers.length-1;        int mid = (l+r)/2;        //本就是有序数组        if(numbers[r] &gt; numbers[l]) return numbers[l];        while(l &lt;= r)&#123;            //如果二分后的数组是有序数组，则返回最左元素，即为最小            if(numbers[r] &gt; numbers[l]) return numbers[l];            //若最左小于mid元素，则最左到mid是严格递增的，那么最小元素必定在mid之后            if(numbers[l] &lt; numbers[mid])&#123;                l = mid+1;                mid = (l+r)/2;            &#125;            //若最左大于mid元素，则最小元素必定在最左到mid之间(不包括最左，因为最左已经大于mid)            else if(numbers[l] &gt; numbers[mid])&#123;                r = mid;                l++;                mid = (l+r)/2;            &#125;            //若二者相等，则最小元素必定在l+1到r之间，因为l和mid相等，故可以去除            else&#123;                l++;                mid = (l+r)/2;            &#125;        &#125;        return numbers[mid];    &#125;&#125;\n\n\n\n二分查找（中右比较）：\nclass Solution &#123;    public int minArray(int[] numbers) &#123;        int low = 0;        int high = numbers.length - 1;        while (low &lt; high) &#123;            int pivot = low + (high - low) / 2;            if (numbers[pivot] &lt; numbers[high]) &#123;                high = pivot;            &#125; else if (numbers[pivot] &gt; numbers[high]) &#123;                low = pivot + 1;            &#125; else &#123;                high -= 1;            &#125;        &#125;        return numbers[low];    &#125;&#125;\n\n​\t 本题中右比较要优于中左比较\n剑指04 二维数组中的查找给定一个每一行都从左到右升序，并且每一列也从上到下升序的二维数组要求从中查找一个数。\n**特殊算法**：\n只要从右上角开始，往左、往下逐个比较，一定能找到目标\nclass Solution &#123;    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;        //需要加上对空二维数组的判断        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;             return false;        &#125;        //从右上角开始查找，所有位移都是向左或者向下，最后一定能找到target        int row = 0;        int col = matrix[0].length-1;        boolean ans = false;        while(col&gt;=0&amp;&amp;row&lt;matrix.length)&#123;//如果在查找中超界则说明不含target            if(matrix[row][col]&gt;target)&#123;                col--;            &#125;            else if(matrix[row][col]&lt;target)&#123;                row++;            &#125;            else&#123;                ans = true;                break;  //或者直接在这里return，最后如果没有提前返回，则直接返回false            &#125;        &#125;        return ans;    &#125;&#125;\n\n\n\n暴力遍历：\n直接通过遍历每一行来查找答案。但是面试题如果写暴力算法就寄了。\n剑指46 数字翻译成字符串给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n 方法一:动态规划\n解题关键：\n那么我们可以归纳出翻译的规则，字符串的第 i 位置：\n可以单独作为一位来翻译如果第 i - 1 位和第 i 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译\n题解代码：\nclass Solution &#123;    public int translateNum(int num) &#123;        String src = String.valueOf(num);        int p = 0, q = 0, r = 1;        for (int i = 0; i &lt; src.length(); ++i) &#123;            p = q;             q = r;             r = 0;            r += q;            if (i == 0) &#123;                continue;            &#125;            String pre = src.substring(i - 1, i + 1);            if (pre.compareTo(&quot;25&quot;) &lt;= 0 &amp;&amp; pre.compareTo(&quot;10&quot;) &gt;= 0) &#123;                r += p;            &#125;        &#125;        return r;    &#125;&#125;\n\n\n\n剑指25 合并两个升序链表如果用动态数组存储两个链表中元素的大小顺序太消耗时间空间\n方法一：伪头结点\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;    //所有的节点更新都是针对的cur.next    ListNode head = new ListNode(-1);    ListNode cur = head;    while(l1!=null &amp;&amp; l2!=null)&#123;        if(l1.val&lt;=l2.val)&#123;            cur.next = l1;            l1 = l1.next;        &#125;        else&#123;            cur.next = l2;            l2 = l2.next;        &#125;        cur = cur.next;    &#125;    cur.next = l1==null ? l2 : l1;    return head.next;&#125;\n\n\n\n方法二：递归\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;    if(l1==null)&#123;        return l2;    &#125;    if(l2==null)&#123;        return l1;    &#125;    if(l1.val&lt;=l2.val)&#123;        l1.next = mergeTwoLists(l1.next,l2);        return l1;    &#125;    else&#123;        l2.next = mergeTwoLists(l1,l2.next);        return l2;    &#125;&#125;\n\n\n\n剑指52 两个链表的第一个重复节点两个相同速度的物体，在长度不同的轨道，想要让他们相遇，就不断的交换他们的轨道\n方法一：双指针\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    if(headA==null||headB==null)&#123;        return null;    &#125;    Set&lt;ListNode&gt; map = new HashSet&lt;&gt;();    while(headA!=null)&#123;        map.add(headA);        headA = headA.next;    &#125;    while(headB!=null)&#123;        if(map.contains(headB))&#123;            return headB;        &#125;        headB = headB.next;    &#125;    return null;&#125;\n\n\n\n剑指21 调整数组顺序使得奇数在前半，偶数在后半双指针：\n左右指针分别查找奇数偶数，当左右指针都有目标之后进行交换。\nclass Solution &#123;    public int[] exchange(int[] nums) &#123;        int l = 0, r = nums.length - 1, temp;        while(l&lt;r) &#123;    //在双指针相等时跳出            while(l &lt; r &amp;&amp; nums[l]%2==1)&#123;//需要避免全奇数数组和全偶数数组导致的下标越界                l++;            &#125;            while(l &lt; r &amp;&amp; nums[r]%2==0)&#123;                r--;            &#125;            temp = nums[l];            nums[l] = nums[r];            nums[r] = temp;        &#125;        return nums;    &#125;&#125;\n\n\n\n剑指58 翻转单词顺序方法一：使用库函数\ns.split(“\\s+”) ,这样子就可以分割多个空格的情况。\npublic String reverseWords(String s) &#123;    // s.split(&quot;\\\\s+&quot;) ,这样子就可以分割多个空格的情况。    String[] strs = s.trim().split(&quot; &quot;); // 删除首尾空格，分割字符串    StringBuilder res = new StringBuilder();    for(int i = strs.length - 1; i &gt;= 0; i--) &#123; // 倒序遍历单词列表        if(strs[i].equals(&quot;&quot;)) continue; // 遇到空单词则跳过        res.append(strs[i] + &quot; &quot;); // 将单词拼接至 StringBuilder    &#125;    return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回&#125;\n\n\n\n方法二：倒序遍历，避开空格\npublic String reverseWords(String s) &#123;    s = s.trim(); // 删除首尾空格    int j = s.length() - 1, i = j;    StringBuilder res = new StringBuilder();    while(i &gt;= 0) &#123;        while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#x27; &#x27;) i--; // 搜索首个空格        res.append(s.substring(i + 1, j + 1) + &quot; &quot;); // 添加单词        while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#x27; &#x27;) i--; // 跳过单词间空格        j = i; // j 指向下个单词的尾字符    &#125;    return res.toString().trim(); // 转化为字符串并返回&#125;\n\n\n\n剑指48 最长不含重复字符的子串给定一串字符串，找到其中不含重复字符的最长子串的长度\n哈希记录：\n如果cur - pre &gt; 前一个字符对应的长度，说明cur 到 pre 之间已经有了重复字符，只能是dp[i] &#x3D; dp[i-1]\n否则的话，就应该如实记录当前这个字符到上一个相同字符的距离。\nclass Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        int len = s.length();        Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();        int[] dp = new int[len];        int max = 1;        if(&quot;&quot;.equals(s))&#123;            return 0;        &#125;        dp[0] = 1;        map.put(s.charAt(0),0);        for(int i = 1;i&lt;len;i++)&#123;            char c = s.charAt(i);            int pre = map.getOrDefault(c,-1);            if(i-pre&gt;dp[i-1])&#123;                dp[i] = dp[i-1] + 1;            &#125;            else&#123;                dp[i] = i - pre;            &#125;            map.put(c,i);            max = Math.max(max,dp[i]);        &#125;        return max;    &#125;&#125;\n\n剑指57 和为s的两个数字给定一个数组，找出其中和为s的两个数字，若存在多对，则返回任意一对即可。\n双指针：\n左右指针开始查找，当和大于目标值，右指针左移；反之，左指针右移。\nclass Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        int l = 0, r = nums.length-1;        while(l&lt;r)&#123;            int temp = nums[l] + nums[r];            if(temp==target)&#123;                return new int[]&#123;nums[l],nums[r]&#125;;            &#125;            else&#123;                if(temp&lt;target)&#123;                    l++;                &#125;                else&#123;                    r--;                &#125;            &#125;        &#125;        return new int[2];    &#125;&#125;\n\n\n\n剑指45 把数组排成最小的数输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个\n快排法：（官解）\nclass Solution &#123;    public String minNumber(int[] nums) &#123;        String[] strs = new String[nums.length];        for(int i = 0; i &lt; nums.length; i++)            strs[i] = String.valueOf(nums[i]);        quickSort(strs, 0, strs.length - 1);        StringBuilder res = new StringBuilder();        for(String s : strs)            res.append(s);        return res.toString();    &#125;    void quickSort(String[] strs, int l, int r) &#123;        if(l &gt;= r) return;        int i = l, j = r;        String tmp = strs[i];        //如果这个while循环能够被执行，那么第一个值，即基准值并没有变，会在第一趟快排结束再改变基准值的位置        while(i &lt; j) &#123;            //右值跟基准值相比，如果放在前面会更大，说明其现在位置是正确的，比较前一个            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= 0 &amp;&amp; i &lt; j)                 j--;            //左值跟基准值相比，如果放在前面会更小，说明其现在位置是正确的，比较后一个            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= 0 &amp;&amp; i &lt; j)                i++;            tmp = strs[i];            strs[i] = strs[j];            strs[j] = tmp;        &#125;        strs[i] = strs[l];        strs[l] = tmp;        quickSort(strs, l, i - 1);        quickSort(strs, i + 1, r);    &#125;&#125;\n\n\n\n剑指61 扑克牌中的顺子误区：JQK和A2 并不能算作一个顺子。\n算法：五张牌中没有重复的，并且，最大的牌-最小的牌&lt;5 ( 最多相差4 )\nclass Solution &#123;    public boolean isStraight(int[] nums) &#123;        Set&lt;Integer&gt; repeat = new HashSet&lt;&gt;();        int max = 0, min = 14;        for(int num : nums) &#123;            if(num == 0) continue; // 跳过大小王            max = Math.max(max, num); // 最大牌            min = Math.min(min, num); // 最小牌            if(repeat.contains(num)) return false; // 若有重复，提前返回 false            repeat.add(num); // 添加此牌至 Set        &#125;        return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子    &#125;&#125;\n\n剑指34 二叉树中和为某一值的路径深度优先搜索，找到符合条件的叶子结点之后，把其对应的路径作为一个答案。\n时间复杂度为**N的平方****\nclass Solution &#123;    List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;();    Deque&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123;        dfs(root, target);        return ret;    &#125;\t    //递归过程自带回溯    public void dfs(TreeNode root, int target) &#123;        if (root == null) &#123;            return;        &#125;        path.offerLast(root.val);        target -= root.val;        if (root.left == null &amp;&amp; root.right == null &amp;&amp; target == 0) &#123;            ret.add(new LinkedList&lt;Integer&gt;(path));        &#125;        dfs(root.left, target);        dfs(root.right, target);        path.pollLast();    &#125;&#125;\n\n\n\n剑指68 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n方法一：两次遍历\n分别找到两个节点的路径，再比较路径得到最近的公共祖先\nclass Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        List&lt;TreeNode&gt; path_p = getPath(root, p);        List&lt;TreeNode&gt; path_q = getPath(root, q);        TreeNode ancestor = null;        for (int i = 0; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); ++i) &#123;            if (path_p.get(i) == path_q.get(i)) &#123;                ancestor = path_p.get(i);            &#125; else &#123;                break;            &#125;        &#125;        return ancestor;    &#125;    public List&lt;TreeNode&gt; getPath(TreeNode root, TreeNode target) &#123;        List&lt;TreeNode&gt; path = new ArrayList&lt;TreeNode&gt;();        TreeNode node = root;        while (node != target) &#123;            path.add(node);            if (target.val &lt; node.val) &#123;                node = node.left;            &#125; else &#123;                node = node.right;            &#125;        &#125;        path.add(node);        return path;    &#125;&#125;\n\n\n\n方法二：一次遍历\n如果当前节点的值大于其中一个，小于另一个，那么说明当前节点就是「分岔点」。此时，p 和 q 要么在当前节点的不同的子树中，要么其中一个就是当前节点。\nclass Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        TreeNode ancestor = root;        while (true) &#123;            if (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;                ancestor = ancestor.left;            &#125; else if (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;                ancestor = ancestor.right;            &#125; else &#123;                break;            &#125;        &#125;        return ancestor;    &#125;&#125;\n\n\n\n剑指68 二叉树的LCA给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n递归 DFS\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        //K神的递归思路        //如果数空，返回空        if(root==null || p==null || q==null)&#123;            return null;        &#125;        //在递归的时候找到两个目标节点其中之一，就将其返回        if(root==p || root==q)&#123;            return root;        &#125;        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        //两边子树都没有找到LCA，说明无解        if(left==null &amp;&amp; right==null)&#123;            return null;        &#125;        //在左子树找到，而右子树没有        if(left==null&amp;&amp;right!=null)&#123;            return right;        &#125;        //在右子树找到，而左子树没有        if(left!=null&amp;&amp;right==null)&#123;            return left;        &#125;        //如果是左右子树都有答案，说明当前就是LCA        return root;    &#125;\n\n\n\n剑指07 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n分治算法：\n还需要了解中序遍历、先序遍历对于确定节点深度、位置的作用\n\nclass Solution &#123;    int[] preorder;    HashMap&lt;Integer, Integer&gt; dic = new HashMap&lt;&gt;();    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        this.preorder = preorder;        for(int i = 0; i &lt; inorder.length; i++)            dic.put(inorder[i], i);        return recur(0, 0, inorder.length - 1);    &#125;    TreeNode recur(int root, int left, int right) &#123;        if(left &gt; right) return null;                          // 递归终止        TreeNode node = new TreeNode(preorder[root]);          // 建立根节点        int i = dic.get(preorder[root]);                       // 划分根节点、左子树、右子树        node.left = recur(root + 1, left, i - 1);              // 开启左子树递归        node.right = recur(root + i - left + 1, i + 1, right); // 开启右子树递归        return node;                                           // 回溯返回根节点    &#125;&#125;\n\n\n\n剑指12 矩阵中的路径给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\nDFS、回溯、剪枝：\nclass Solution &#123;    public boolean exist(char[][] board, String word) &#123;        char[] words = word.toCharArray();        //遍历整个矩阵        for(int i = 0;i&lt;board.length;i++)&#123;            for(int j = 0;j&lt;board[0].length;j++)&#123;                //通过递归求解是否存在满足要求的情况                if(dfs(board, words, i, j, 0)) return true;            &#125;        &#125;        return false;    &#125;    public boolean dfs(char[][] board, char[] words, int i, int j, int k)&#123;        //如果下标越界，或者出现不符的情况，就放弃这个位置，从下一个位置开始求解        if(i&lt;0 || i&gt;=board.length || j&lt;0 || j&gt;= board[0].length || board[i][j] != words[k]) return false;        //如果已经遍历到最后一个位置，并且通过了上面的相等判断，那么说明找到了解，一层层向上返回正确的结果。        if(k==words.length - 1) return true;        //在递归过程中，通过对矩阵的修改和回溯，来防止遍历到已经遍历过的位置导致死循环        char temp = board[i][j];         board[i][j] = &#x27; &#x27;;        //递归求解每个方向上的可能，只要有一个方向上能成功，就返回正确。        boolean res = dfs(board, words, i + 1, j , k+1) ||        dfs(board, words, i - 1, j , k+1) ||        dfs(board, words, i, j - 1, k+1) ||        dfs(board, words, i, j + 1, k+1);        //回溯之前做过的修改。        board[i][j] = temp;        return res;    &#125;&#125;\n\n\n\n剑指39 数组中出现次数超过数组长度一半的数数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n排序法：将数组排序，数组的中位数就是要找的数。\n摩尔投票法：\n每次投票数等于0，则将当前数字作为”众数“。\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        int x = 0, votes = 0, count = 0;        for(int num : nums)&#123;            if(votes == 0) x = num;            votes += num == x ? 1 : -1;        &#125;        // 验证 x 是否为众数        for(int num : nums)            if(num == x) count++;        return count &gt; nums.length / 2 ? x : 0; // 当无众数时返回 0    &#125;&#125;\n\n\n\n剑指66 构建乘积数组给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法\n两次遍历，动态规划\n两次遍历分别构建前缀乘积和后缀乘积。\npublic int[] constructArr(int[] a) &#123;    int[] ans = new int[a.length];    for (int i = 0, p = 1; i &lt; a.length; i++) &#123;        ans[i] = p;        p *= a[i];    &#125;    for (int i = a.length - 1, p = 1; i &gt;= 0; i--) &#123;        ans[i] *= p;        p *= a[i];    &#125;    return ans;&#125;\n\n\n\n剑指57 和为target的连续正整数序列输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n滑动窗口或者利用数学写出一元二次方程计算左右边界得到结果\n滑动窗口：\nclass Solution &#123;    public int[][] findContinuousSequence(int target) &#123;        int i = 1, j = 2, s = 3;        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();        while(i &lt; j) &#123;            if(s == target) &#123;                int[] ans = new int[j - i + 1];                for(int k = i; k &lt;= j; k++)                    ans[k - i] = k;                res.add(ans);            &#125;            if(s &gt;= target) &#123;                s -= i;                i++;            &#125; else &#123;                j++;                s += j;            &#125;        &#125;        return res.toArray(new int[0][]);    &#125;&#125;\n\n\n\n961题. 在长度 2N 的数组中找出重复 N 次的元素给你一个整数数组 nums ，该数组具有以下属性：\n\nnums.length &#x3D;&#x3D; 2 * n.\nnums 包含 n + 1 个 不同的 元素\nnums 中恰有一个元素重复 n 次\n\n找出并返回重复了 n 次的那个元素。\n哈希表解法没啥好说，随机下标判断法：\n我们可以每次随机选择两个不同的下标，判断它们对应的元素是否相等即可。如果相等，那么返回任意一个作为答案。期望 O(1)O(1)。选择两个相同元素的概率为$$n&#x2F;2n * (n-1)&#x2F;2n  &#x3D; 1&#x2F;4$$ 因此期望 44 次结束循环。\nclass Solution &#123;    public int repeatedNTimes(int[] nums) &#123;        int n = nums.length;        Random random = new Random();        while (true) &#123;            int x = random.nextInt(n), y = random.nextInt(n);            if (x != y &amp;&amp; nums[x] == nums[y]) &#123;                return nums[x];            &#125;        &#125;    &#125;&#125;\n\n\n\n","categories":["算法"],"tags":["leetcode"]},{"title":"计算机视觉考前复习","url":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E8%80%83%E5%89%8D%E5%A4%8D%E4%B9%A0/","content":"第一章 绪论视感觉：从分子的层次和观点来理解人类对光的反映的基本性质。\n视知觉：论述人们从客观世界接收到视觉刺激后如何反应以及反映所采用的方式。\n研究方法：仿生学、工程方法。\n目标：\n\n建立计算机视觉系统完成各种视觉任务。\n以对计算机视觉的研究来探索人脑视觉工作机理。\n\n图像：辐射强度模式的空间分布。\n类别：\n\n模拟图像：从连续的客观场景直接观察到、一个用二维数组来表示的图像\n数字图像：把连续的模拟图像在坐标空间XY和性质空间F都离散化了的图像。\n\n像素之间的关系：\n\n邻接：对于两个像素p、q，如果p在q的邻域中，则说两个像素邻接。\n连接：p和q邻接，且灰度值满足某个相似准则。\n连通：互相不直接连接，但是都在某个像素的邻域内，并且都满足某个像素准则。\n通路：两个像素之间有一系列连接的像素使得p和q连通，则这些像素构成p和q之间的通路。\n\n像素间的距离：\n欧氏距离、街区距离、棋盘距离。（计算题）\n第二章 图像采集采集装置：传感器、数字化器件\nCCD摄像机：具有非常快的快门速度\nCMOS摄像机：低功耗、小尺寸、总体成本低。\nCID摄像机：随机访问，不会产生图像浮散。\n基本性能指标：\n线性响应、灵敏度、信噪比（越高越好）、阴影（不均匀度）、快门速度、读取速率\n重合模型：摄像机坐标系统和世界坐标系统重合。\n通过投影变换将世界坐标系的东西投影到摄像机坐标系上。\n4-点映射。\n归一化摄像机：**焦距为1的特定摄像机**，也指一种简化的重合模型。\n当焦距减半，成像尺寸也会缩减到一半\n当传感器密度减半，成像尺寸也减半。\n分离模型\n图像平面（原点）与世界坐标系统的位置偏差用矢量D表示，分量有Dx、Dy、Dz\n摄像机的扫视角：x和X轴的夹角\n摄像机的倾斜角：z和Z轴的夹角。\n若将XY平面视作地球的赤道面，Z轴指向北极，那么扫视角对应经度，倾斜角对应纬度、\n亮度成像模型\n图像采集的过程可以看做一个将客观景物的光辐射强度转化为图像灰度的过程。\n照度：$$E &#x3D; k \\frac{cos i}{d^2}&#x3D;  \\frac{kh}{d^3}$$\n空间分辨率：即数字化的空间采样点数（与采样点数有关，采样越密，分的越清）\n幅度分辨率：即采样点值的量化级数（量化灰度级数，级数越多，分辨率越高）\n结构光法：\n\n直接获得深度信息。\n\n利用照明中的几何信息来提取景物自身的几何信息。\n\n成像高度包含了3D的深度信息。\n\n也包含了物体的沿y方向的厚度信息。\n\n\n什么是摄像机的标定？\n根据一组基准点计算出相机的内外部参数的过程。\n\n外部参数：即摄像机姿态参数。**自转角、进动角、章动角**、Tx    Ty   Tz\n内部参数：即摄像机自身参数。焦距、镜头失真系数k、不确定性图像尺度因子u、图像平面原点的计算机图像坐标。\nk：镜头径向畸变引起的误差系数\nu：图像获取硬件和摄像机扫描硬件之间的误差。\n\n如果u已知，只需要一组共面基准点；如果未知，需要一组不共面的基准点。\n目的是什么？\n让摄像机的坐标系统和世界坐标系统对齐。\n客观场景-&gt;数字图像的四步：☆☆☆\n\n世界坐标到摄像机3D坐标的变换。（分离模型变为重合模型）\n从摄像机坐标到无失真成像平面理想坐标（投影变换矩阵）\n从无失真成像平面理想坐标到受镜头畸变而偏移的实际成像平面坐标。\n从成像平面坐标到图像坐标的变换。（连续坐标变为离散坐标）\n\n标定参数：\n\n标定旋转矩阵R和平移矢量T\n标定焦距λ\n标定镜头径向失真系数k\n标定不确定性图像尺度因子μ\n\n第三章几何失真校正：空间变换、灰度插值。\n图像增强：直方图修正——均衡化、规定化。P51\n消除噪声的方法：参与运算的像素越多的方法越好。\n第四章 基元检测一阶微分算子给出梯度，也称作梯度算子（计算题）\n分别计算x和y方向的两个偏导分量\n梯度就是两个方向上的偏导。\nprewitt sobel  robert\n二阶导数算子：拉普拉斯算子、对噪声敏感、模板中正邻负\n马尔算子：在拉普拉斯算子基础上，先平滑，再检测。过零点作边缘点。\n坎尼算子：满足三个准则↓\n\n信噪比准则\n定位精度准则\n单边缘响应准则\n\nsusan算子：\n核同值区（USAN）原理。\n\n直边缘：usan一半。\n交点处：usan约1&#x2F;4\n\n利用usan面积的变化可检测边缘或者角点。\n特点：\n\n不需要积分运算\n响应效果随着边缘的平滑或模糊而增强\n提供不依赖于模板尺寸的边缘精度（控制参数简单）\n\n哈夫变换;\n点线对偶性：图像空间共线的点对应参数空间相交的线。\n竖直的线使用极坐标方程，点-正弦曲线对偶性。\n第五章 目标分割轮廓搜索：图搜索、动态规划。\n动态规划：使用启发性知识，**步骤见P96**\n并不能保证发现区局最小代价通路。\n阈值分割：\n大于阈值取1，小于阈值取0，最终得到二值图像。\n关键在于选取合适的阈值：\n全局阈值：仅根据图像本身f(x,y)来选取。\n局部阈值：根据f(x,y)和像素周围局部区域性质q(x,y)\n动态阈值：根据f(x,y)和q(x,y)，以及像素坐标位置(x,y)选取、\n前两种阈值可称为固定阈值。\n全局阈值的选取：\n\n极小值点阈值——找到曲线中的谷。\n最大凸残差——凸包与实际差值最大的位置。\n\n特征空间聚类：\n结合了阈值化分割和标记。\nk-means聚类：将一个特征空间分成k个聚类。\n\n任意选k个初始类均值。\n在每一次迭代，将每个特征点付给——类的均值与其最接近的类。\n所有点都分类之后，更新所有类的均值。\n如果类的均值不再随着迭代次数变化，则说明算法收敛。\n\n第六章 目标表达和描述链码：4-方向链码、8-方向链码。\n不同起点有着不同的链码。\n归一化链码：先得到一个任意起点的链码，再将这个序列循环，直至得到其值最小的序列。\n平移不会改变链码，但是旋转会改变。\n链码旋转归一化：链码的差分码。（具有旋转不变性）\n计算差分码：x - y，总要确保 y 大于 x  ，如果 y 小于 x， 就将其加上链码的方向数再算。\n缝隙码：连接两个相邻轮廓像素的中心。\n凸包：由边界凸起形成线段并将原形状完全包括的最小多边形。\n凸残差：凸包减去原形状。\n分段点：凸包边界和原形状一般都有重叠部分，重叠部分和凸包边界的分段点就是。\n边界标记：\n\n距离为角度的函数（**重心**）\nfai-s曲线\n斜率密度函数\n距离为弧长的函数（弧长与角度有关）\n\n四叉树：\n目标节点（白色）、背景节点（黑色）、混合节点（黑色）。\n每个混合节点都还可以再分四个节点。\n一个n级的四叉树，节点总数N最多有$$\\frac{3}{4}4^n$$\n外接盒：包含目标区域的最小长方形。\n围盒：最小包围长方形。（MER）\n凸包：包含目标区域的最小凸形。\n骨架：\n如果对于P，在边界B上有两个及以上的点到P的距离最小，则认为P是骨架点。（与边界点距离最小）\n骨架与距离有关，也就与距离度量有关。\n计算骨架：\n\n标记并除去满足以下条件的点：\n2 &lt;&#x3D; N(p) &lt;&#x3D; 6\nS(p) &#x3D; 1\np2 * p4 * p6 &#x3D; 0\np4 * p6 * p8 &#x3D; 0\n\n\n标记并除去满足以下条件的点：\n2 &lt;&#x3D; N(p) &lt;&#x3D; 6\nS(p) &#x3D; 1\np2 * p4 * p8 &#x3D; 0\np2 * p6 * p8 &#x3D; 0\n\n\n\n\n条件1为了保护线段端点或者深入区域的点\n条件2保护了宽度为单个像素的线段（边界）\n条件3、4保护了右、下角，左、上角。\n\n边界长度：包围区域的轮廓的周长\n4-方向连通边界：要求点的8邻域内有不属于R的点。\n8-方向连通边界：要求点的4邻域内有不属于R的点。\n边界长度：\n边界上相隔最远的两个点之间的距离。（主轴、长轴）\n短轴：与长轴垂直且是边界间最远两点的线段。\n边界形状数：基于链码，是值最小的（链码的）差分码。\n也可以是链码的差分码的归一化值。\n阶数：形状数的长度。随着阶数的增加，对应的可能的形状数也会很快增加。低阶形状数对应的形状有限。\n计算:（计算题）\n\n求出围盒\n划分围盒为多个小正方形，将与边界有50%以上面积重合的小正方形选为边界的模拟。\n根据小正方形组成的边界的模拟来得出链码，然后得到差分码，然后得到形状数。\n\n轮廓形状矩阵:P127\n可看做是一个刻画目标轮廓的矢量，记录了轮廓上各点的相对位置。\n\n获取轮廓\n\n对轮廓采样得到离散点\n\n划分扇区，划分圆环。\n\n对每个点，将其放在圆的中心，记录其他点在扇区、圆环中的分布情况。\n（矩阵行：环数，矩阵列：扇形区数）\n\n对每个点的统计得到的就是形状矩阵。\n\n\n区域不变矩：（计算题）\n区域拒是用所有属于区域内的点计算出来的。\np+q阶矩 &#x3D; 所有求和【x^p * y^q * f(x,y)】\n区域矩唯一的被f(x,y)所确定。\n中心距：\n拓扑描述符：（计算题）\n与尺寸无关，不收畸变变形的影响。\n欧拉数：E &#x3D; C - H。 C：联通组员个数。  H：孔洞数。\n欧拉数描述的是区域的连通性。\n欧拉公式：V - B + F &#x3D; E &#x3D; C - H。 欧拉数可以取负数。\n第七章 纹理分析局部二值模式：\n用LBP算子遍历图中像素，得到像素对应的标号，用直方图统计所有的标号，得到的直方图就可以作为区域的**纹理描述符**。\n注意：LBP算子从正右方向开始，逆时针顺序。而骨架化算法从正上方向开始，逆时针顺序。\n均匀模式：整个循环中最多包含两个从0到1或者从1到0的过渡，就说这个二值模式是均匀的。\n第八章 形状分析形状紧凑型描述符：\n\n外观比：R &#x3D; L &#x2F; W\n形状因子：F &#x3D; B^2 &#x2F; 4πA     （B为周长，A为面积）   F&gt;&#x3D;1\n球状性： S &#x3D; Ri &#x2F; Rc\n圆形性\n偏心率\n3-D形状相似性\n\n形状复杂性描述符\n简单描述符：\n\n细度比例：形状因子的倒数\n面积周长比\n矩形度\n与边界的平均距离\n轮廓温度（热力学）\n\n饱和度：\n目标在其围盒中的充满程度。\n属于目标的像素个数与整个围盒所包含的像素个数之比。\n多边形计算：\n\n基于收缩的最小周长多边形法\n\n基于聚合的最小均方误差线段逼近法\n\n将点在误差内聚合到某一点，将所有聚合了的点相连得到。\n\n\n基于分散的最小均方误差线段逼近法\n\n先连接最远的两个像素，然后进一步在误差内找到最远的能分散的点\n\n\n\n轮廓曲率：\n与几何特征的关系：\n\n连续0曲率：直线\n连续非0曲率：圆弧段\n局部最大曲率绝对值：角点\n局部最大曲率正值：凸角点\n局部最大曲率负值：凹角点\n\n离散曲率：\nrk(p) &#x3D; | 1 - cos θ  |\n第九章 立体视觉立体视觉模块：\n\n摄像机标定\n图像获取\n特征提取\n立体匹配\n3-D信息恢复\n后处理\n\n双目横向模式：\n两个单目系统在水平方向上并列放置。两个镜头中心的连线称为系统的基线B。\n双目系统观察同一个景物所得到的两幅图像中该景物的视像位置不同，就产生了视差。\n视差： d &#x3D; x1 - x2  - Ｂ。\n"},{"title":"经济学复习文档","url":"/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3/","content":"第一章 导论稀缺性——资源的有限性——相对于资源的需求而言，资源总是不足的。\n机会成本——**为了得到某物而必须放弃的收益**。机会成本取决于你所面临的其它选择。\n\n\n经济学最好的定义：社会如何管理其稀缺资源\n看一场电影的成本是：**去看电影所需要的所有现金支出 + 时间价值**。\n亚当斯密看不见的手：尽管市场是利己的，但是自由市场仍然能达到合意结果的能力。\n失业率与物价往往是负相关的。\n经济学十大原理关于个人做出决策的基本结论：\n\n人们需求的权衡利弊\n机会成本\n边际分析法\n激励因素\n\n关于市场相互影响的基本结论：\n\n市场经济\n市场调节机制\n政府干预\n\n关于整体经济如何运行的结论：\n\n国家整体经济\n货币政策\n通货膨胀与失业之间的交替关系\n\n第二章 市场运行\n需求和需求曲线\n需求定理\n需求与需求量的差别\n需求定理及其例外\n需求弹性\n谷贱伤农？\n供给及供给曲线\n供求均衡\n支持性价格\n\n需求需求——表示在某一定时间内，在各种可能的价格水平下，个人愿意并且有能力购买的某种商品的数量。\n（多种价格对应多种需求量的情况）\n需求量——在商品某一价格下，对其需要的数量。\n**影响需求的因素**：\n\n产品自身价格\n偏好\n收入\n相关产品的价格\n预期\n人口\n其他：法律政策等。\n\n**吉芬商品:**商品价格下降，消费者购买少；而价格上涨时，需求量反而上升。（买来投资）\n替代品：可以替代另外的商品的商品\n互补品：消费者为了实现某种功效而需要一起消费的商品（订书机、订书钉）\n正常品：随着消费者收入增加需求增加的商品（好吃的）\n劣等品：随着消费者收入增加需求减少的商品。\n需求曲线：表示一种物品的价格和需求量之间关系的曲线。（一般是负相关）【横轴需求，纵轴价格】\n需求定理：其他条件不变，商品的价格上升，对其的需求减少；价格下降，对其的需求增加。\n需求曲线的左移右移：\n\n左移——同价格的需求减少了\n右移——同价格的需求增加了\n\n需求量的变化——商品本身价格引起的需求变化。（需求曲线点的移动，不改变曲线）\n需求的变化——除价格之外的因素引起的需求变化（或同一价格水平下需求量的改变）。（曲线左右移）\n需求的变化必定引起需求量的变化，但是需求量的变化不一定引起需求的变化。\n供给供给：在一定时期内，在一定价格条件下，企业愿意并能够生产（销售）某种商品的数量\n影响供给的因素：\n\n产品自身价格\n技术状况\n生产要素的价格\n其他商品价格\n预期\n厂商的数目\n政府税收\n\n供给曲线：表示物品价格与供给量的关系。【纵轴价格，横轴供给量】\n供给规律：认为在其他条件不变时，一种物品价格上升，该物品供给量增加的观点。\n供给量的变动：商品价格变动引起商品供给数量的变动。供给量的增加是因为价格的上升。(需求上升引起的**点的移动)**\n供给的变化：同一价格下，商品的供给量发生了变化。\n\n左移，供给减少，需求减少。\n右移，供给增加，需求增加。\n\n市场均衡与供求规律市场均衡即供求相等时的市场关系。需求曲线与总计曲线的交点对应着均衡价格、均衡数量。\n任何偏离均衡点的一点都是市场失衡。市场有自发的力量推动市场均衡的恢复。\n限制性价格政策——限制价格（最高价）。——房价\n支持性价格政策——支持价格（最低价）。——粮食价格\n谷贱伤农：\n\n需求弹性是指在一定时期内商品需求量的相对变动对于该商品价格的相对变动的反应程度\n\n需求价格弹性 &#x3D; 需求量变动百分比 &#x2F; 价格变动百分比 \n\n衡量物品需求量对其**价格变动反应程度**\n衡量买者需求的价格敏感程度\n\n\n需求曲线越**平坦**，该商品越富有价格弹性，需求弹性越小\n\n\n\n\n越日常、刚需的东西，需求弹性越小（鸡蛋0.1、大米0.5、住房0.7、威士忌4.4）\n\n生活必需品、衣食住行适合薄利多销。\n\n价格弹性&gt;1，需求弹性小，可以薄利多销。\n\n需求弹性、价格弹性基本**负相关**。\n\n\n供给弹性度量某一商品供给量变化率对自身价格变化率反应程度。\n供给价格弹性 &#x3D; 供给量变动百分比 &#x2F; 价格变动百分比\n总结：\n\n需求曲线越平坦，价格弹性越高、需求弹性越小。（生活必需品）\n\n一个商品如果很少有替代品，价格弹性小，需求弹性大。\n\n支持性政策会导致产品过剩，\n\n\n第三章 消费者\n无差异曲线及其特点\n预算线（判断、名词解释）\n效用和边际效用\n边际效用的递减规律\n总效用和边际效用的关系\n\n想要什么？效用：消费者从商品和服务的消费中得到的满足程度称为效用\n\n不是客观用途（不是商品的使用价值）\n是个人的心理感受\n同一商品的效用的大小因人、因时、因地 而异。\n\n关于效用的两类观点：\n基数效用论：效用可以用数值计算，可以加总求和，提出了边际效用递减规律。\n序数效用论：效用作为一种心理现象无法计量，只能表示程度的高低、顺序。\n**边际效用递减规律**：\n是指在一定时间内，在其他商品的消费数量保持不变的条件下，随着消费者对某种商品消费量的增加，消费者从该商品连续增加的每一消费单位中所得到的效用增量即边际效用是递减的。\n\n一直冲，冲得越多爽的越少。\n当消费者已拥有了所有的某种想要的商品，那么此时该商品的边际效用为0。\n\n产生原因：生理或心理的原因、商品不同用途的重要性不同\n无差异曲线：在满足消费者效用水平不变的情况下，消费者消费两种商品的消费束代表的点的轨迹。\n（线上任一点，代表两种商品的不同组合，暗示任一点带个消费者的效用都相同）\n\n代表了消费者的偏好。\n\n消费束——是物品的一个特定组合。\n\n离原点越远，代表效用水平越高。\n\n任意两条无差异曲线不能相交。\n\n在多数情况下，无差异曲线是凸向原点的。\n\n相近替代品的无差异曲线不是很弯曲。\n\n相近互补品的无差异曲线非常弯曲。\n\n无差异曲线上一点的**斜率是消费者的边际替代率**。\n\n\n\n边际替代率（MRS）：在维持效用水平不变的前提下，消费者增加某一商品消费数量时所需要放弃的另一种商品的消费数量。（消费者愿意用一种物品换另一种物品的比率。）\n\n计算：MRS &#x3D; 无差异曲线的斜率。 MRS &#x3D; △y  &#x2F; △x。\n\n\n能买什么？预算约束线：预算线（Budget line）：在既定价格水平下，消费者用给定的收入可能购买的各种商品组合点的轨迹。有时称预算约束（budget constraint）或者消费可能线、价格线。\nP1Q1 + P2Q2  &#x3D; I       【P价格，Q数量，I 总收入】\n找到分别全买A、B商品的两个点，相连就是要求的预算约束线。\n\n收入增加使得约束线向右上方移动，减少使得约束线向左下角移动。\n\n最优选择在消费决策中，作为理性人，你的选择也应该是追求消费的均衡\n消费者必然追求消费效用的最大化，但作为现实中的个人，消费者又必须受到消费条件的制约。\n恩格尔系数：食品支出占个人消费指出总额的比重。【越低越有钱】\n收入效应：\n\n收入变动对消费的影响。随收入增加而消费量增加的商品为正常物品，收入效应为正。\n随收入增加而消费量减少的物品是低档物品（劣等品），收入效应为负。\n\n替代效应：当两种商品之间有替代关系时，在收入不变时，其中一种商品的价格发生变动，消费者对原来的消费组合调整。\n价格效应 &#x3D; 收入效应 + 替代效应\n第四章生产者\n长期与短期的区别（判断）\n总产量和边际产量的关系\n规模报酬递分？\n总成本和边际成本怎么计算？\n经济利润、显性成本和隐性成本\n\n企业：厂商或生产者，是指能够做出统一的生产决策的单个经济单位。\n必须具备的三个特征：\n\n独立自主经营\n自负盈亏\n产权明晰\n\n通常有三种组织形式：个人企业、合伙制企业和公司制企业。\n\n个人企业：单个人独自经营的厂商组织\n合伙制企业：两个人以上合资经营的厂商组织\n公司制企业：按照公司法建立与经营的具有法人资格的厂商组织。\n\n企业追求——利润最大化利润 &#x3D; 总收入 - 总成本\n生产要素：资源、资本、劳动、企业家的才能。\n生产函数：表示在一定时期内，在技术水平不变的情况下，生产中所使用的各种生产要素的数量与所能生产的最大产量之间的关系。\n为了简化分析，通常假定生产中只使用劳动和资本这两种生产要素。Q &#x3D; f ( K , L )  &#x3D;  aL + bK {线性生产函数} \n【Q为产出、L为劳动力、K为资本。】\n边际产量——在其他投入量不变的情况下，增加一单位投入所引起的产量增加。（MPL &#x3D; △Q &#x2F; △L）\n\n随着L增加，MPL逐渐减小。\n随着L增加，生产函数走势越来越平坦。\n\n企业收益分析短期生产——投入的生产要素根据变或不变的属性，进行分类。\n\n可变投入：劳动、电力、燃料等消耗性要素。\n不变（固定）投入：土地、厂房、机器设备。\n\n长期生产——**所有的生产要素都是可变的**。\n注意：\n\n固定投入和可变投入的区别仅限于短期生产。\n厂商只有在长期生产才面临不同生产函数的可能\n短期长期的划分并非依据时间\n对于不同产品的生产，短期生产和长期生产的时间不同。\n\n短期生产中的生产规律\n总产量：生产者投入一定的生产要素之后，得到的产品的总和。\n边际产量：再正价某种生产要素带来的总产量的增加量。\n短期生产中，边际产量先增加后减少——边际收益递减。\n**边际报酬递减规律**：短期生产中，在技术水平不变的条件下，不断增加某种生产要素的投入，当投入的数量达到一定的数量后，再增加该要素带来的边际产量是递减的。\n长期生产中的生产规律：\n规模收益（规模报酬）——在技术水平与要素价格不变的情况下，所有生产要素都按同一比例增加，引起的产量的变动状态。\n\n规模收益不变——产量增加的比例 &#x3D; 各要素投入量增加的比例\n规模收益递增——产量增加的比例 》 各要素投入量增加的比例\n规模收益递减——产量增加的比例《 各要素投入量增加的比例\n\n规模经济：\n\n规模经济——长期平均总成本随着产量的增加而减少。【越产越多，越花越少】\n规模不经济——长期平均总成本随着产量的增加而增加。【产的多，花的也多】\n\n\n\n随着规模增大，由规模经济进入不规模经济。规模收益先递增后不变，最后递减。\n企业成本分析成本：是企业支付给生产要素的报酬，也即生产一定数量产品所耗费的指出。\n显性成本：又称可见成本，有些生产要素在购买时需要支付报酬，一般用货币来支付，即货币成本\n隐性成本：有些生产要素报酬不需要立即支付，或合同规定必须支付，却实实在在发挥着生产作用\n机会成本（显性成本+隐性成本）：生产要素用于目前这种用途时所放弃的其他用途的最高收入。\n会计成本：会计学上的成本——**计算显性成本，忽略了隐形成本**。\n会计利润：不考虑隐性成本，总收益 - 总显性成本\n经济利润：总收益 - 机会成本\n沉没成本：已经付出的永远无法收回的成本（如时间）\n\n沉没成本不应该影响下一次决策。\n\n经济学家衡量成本包括机会成本，但会计只关注显性成本而忽略隐性成本。\n可变成本（VC）：短期内随产量变化而变化的那部分生产要素报酬。【工人的工资】\n固定成本（FC）：短期内不随产量变化而变化的那部分生产要素报酬。【土地的价格、机器的价钱】\n总成本：是可变成本和固定成本之和。**TC &#x3D; VC +  FC**。\n平均成本：平均生产一单位产品所需的成本——AC。\n边际成本：增加一单位产量时所需增加的成本。——MC。\n\nMC &#x3D; dTC &#x2F; dQ &#x3D; **△TC  &#x2F;  △Q**。\n\n小结：\n\n\n\n第五章 市场结构市场结构：完全竞争、垄断竞争、寡头垄断、垄断\n划分尺度：生产者数量的多少（上述递减）、生产者所生产的商品的差异性\n完全竞争市场：不存在丝毫垄断因素，竞争可以充分展开，市场机制在资源配置方面的作用不受到任何阻碍和干扰\n特点：\n\n生产者生产的商品是完全相同的\n买方和卖方都是价格接受者\n企业可以自由地进入和退出市场\n市场信息是完全的\n\n利润化最大条件：\nMR &#x3D; MC，边际利润等于边际成本。\n利润 &#x3D; 总收益 - 总成本\n总收益 &#x3D; P * Q\t\t\t总成本 &#x3D; ATC * Q\n所以利润 &#x3D; （ P - ATC）*  Q\n在生产成本高于市场价格，即会产生亏损的情况下，商家还是要生产和售卖，通过一直做生意来逐渐减小亏损。\nAVC平均可变成本——人工费用\t\t\tAFC平均固定成本——其他材料、房租等成本\n如果AVC很高的话，生意是做不下去的。\n残酷的完全竞争：\n利润被无情地压缩是完全竞争行业的一个显著特点\n**只有当价格与ATC（平均总成本）相等时，进入和退出才会结束**。\n垄断市场：完全垄断：又称垄断或者独断，是指整个行业中只有唯一的一个厂商的市场类型\n产生原因：\n\n垄断资源：当某行业中至关重要的资源或其他投入要素被某厂商所控制，其他厂商无法获取值这资源，也就不发进入这一行业。\n政府管制：垄断的产生是因为政府给予一个人或一个企业排他性地出售某种物品或劳务的权利\n自然垄断：当一个企业能以低于两个或更多企业的成本为整个市场供给一种物品或劳务时，就是自然垄断。\n专利和版权（比如冰墩墩）\n\n一级价格歧视：对每个消费者，相同的商品的售价都不一样\n二级价格歧视：按照消费者的消费数量来确定价格。\n三级价格歧视：将市场划分为多个不同的子市场，并将同一种商品在不同的子市场上按不同价格销售。\n寡头垄断在某一产业中只存在少数几个卖方的市场组织形式。\n基本特征：\n厂商数量极少、商品可能同质，也可能有差别、市场存在较高的进入壁垒、厂商之间相互依存。\n垄断竞争：许多厂商出售相近但非同质的、而是具有差别的商品的市场\n基本特点：\n\n存在较多厂商、彼此之间竞争激烈\n各厂商生产有差别的同种产品、产品之间是非常接近的替代品\n厂商进入、退出市场都比较容易\n厂商行为相互独立\n\n小结：\n垄断可以促进新技术的出现、完全竞争可以让资源得到最大化的利用。\n第六章 经济增长\nGDP和经济增长\nGDP及理解\n名义GDP和实际GDP\nGDP怎么算\n经济增长的影响因素\n\n如何衡量经济状况\n什么是GDP？\nGDP怎么核算？\n名义GDP与实际GDP\n\nGDP：国内生产总值（Gross Domestic Product):在某一既定时期内一个经济社会运用生产要素所生产的全部最终产品（物品和劳务）的市场价值。\n包含了以下几方面的内容：\n\nGDP是价值概念\nGDP测度的是最终产品的价值\nGDP测度的是**现期生产**的产品\nGDP局限于一国地理范围之内\nGDP是一定时期内生产的最终产品的市场价值\n\n【家庭劳动、自给自足不算入GDP】\n最终产品：同期内不再加工，可供最终使用与消费的产品\n中间产品：用于再出售而供生产别种产品用的产品\n同一种产品可以是最终产品也可以是中间产品\n只有最终产品才算入GDP\n商品（最终产品）计入生产当年的GDP\nGNP（Gross National Product）：是一个国民概念，一定时期内某国国民拥有的生产要素所生产的最终产品和劳务市场价值。\nGDP只是计算国家领土范围之内的，GNP计算的是国籍层面上的。\nGDP可以帮助领导人判断国家的经济情况，需要做出怎样的经济控制措施。也能比较国与国之间的经济实力。\nGDP如何核算？\n生产法：从生产者角度来计算GDP，生产总价值 - 生产中投入的中间产品的价值。\n\n​\t\t\tGDP &#x3D; 各行业增加值之和 &#x3D; 各行业总产出 - 各行业中间消耗\n\n支出法：\n\n核算在一定时期内整个社会购买最终产品的总支出，即最终产品的售价来计量GDP。\n\n包括**消费、投资、政府购买、净出口**\n\n居民消费：耐用消费品、非耐用消费、劳务（不包括买房子造房子）\n\n投资：增加或更换资本资产的支出，固定资产投资+居民住宅投资+存货投资\n【债券、股票不计入投资】\n\n政府购买：各级政府购买物品和劳务的支出，包括公务员的薪水和用于公务的支出。\n政府支出 &#x3D; 政府购买+政府转移支付+公债利息。（后面两个不计入GDP）\n\n净出口：国外购买国内生产的物品与国内购买外国生产的产品之间的差额。\n\n\n\n\n\n收入法：（最复杂）\n用要素收入，即企业生产成本来核算GDP\n包括：\n\n工资、利息、租金等生产要素的报酬\n\n非公司企业主收入，如小店铺主的收入\n\n公司税前利润，包括公司所得税、社会保险税、股东红利、公司未分配利润等。\n\n企业转移支付和企业间接税\n\n资本折旧。\n\n\nGDP &#x3D; 工资+利息+租金+利润+间接税+企业转移支付+折旧。\n\n\n\n名义GDP与实际GDP名义GDP：一个经济体在一年内用当年价格计算的最终产品的市场价值。\n实际GDP：一个经济体在一年内生产的以某年作为基期价格计算的全部最终产品的市场价值。\nGDP平减指数：名义GDP和实际GDP的比率。反映通胀的物价指数。（名义 &#x2F; 实际）\n我国名义GDP和实际GDP每年都在增加，但是由于物价水平不断上涨，两者差距越来越大）\nCPI：  消费者物价指数\n是度量一组代表性消费商品及服务项目的价格水平随时间而变动的相对数，是用来反映居民家庭购买消费商品及服务的价格水平的变动情况。\nCPI与GDP的差别\n\nGDP衡量所有所有产品和服务，CPI只衡量消费者购买的。\nGDP只包括国内生产的产品，但是CPI受进口品的影响。\nCPI给不同产品分配固定的权重，而GDP分配变动的权重。\n\n经济增长消费\n消费通常指最终消费，主要包括了居民消费和政府消费。\n直接推动经济增长，创造生产动力，进一步刺激投资需求。\n\n投资\n经济学上的投资不同与一般意义上的投资，并不包括对股票证券的投资。\n\n投资可以增加社会总供给，扩大社会生产能力。\n\n\n出口出口带动国内产业的发展，提供大量就业岗位，提高居民收入水平，扩大消费需求。\n如何看待GDP？GDP的局限性：\n\n没有考虑非市场性活动\n没有考虑环境破坏活动\n没有考虑收入分配\n不是衡量福利的完美标准\n\n如何保持长期经济增长？\n物质资本的增加\n人力资本的增加\n技术和研发\n政治稳定和产权保护\n\n小结：\n\n还有局限性和对长期经济增长的保证。\n补充：\n转移支付——指政府或企业无偿地支付给个人以增加其收入和购买力的费用。\n第七章 失业与通货膨胀\n失业的定义及判断\n失业率的计算\n充分就业、自然失业率\n失业的类型\n失业的影响\n通胀的定义\n通胀的影响\n通胀的成因\n菲利普斯曲线\n\n失业在当前工资水平下愿意工作的人无法找到工作的一种形式。\n**失业者的三个条件**：\n\n符合劳动年龄（16-65）\n有工作能力\n愿意工作但没有工作\n\n总人口——成年人口、未成年人口\n成年人口——劳动力人口、非劳动力人口\n不列入劳动者的：\n\n军队人员\n在校学生\n家务劳动者\n退休或者因病退职人员以及丧失劳动能力、服刑犯人等不能工作的人员\n不愿意工作的人\n在家庭农场或家庭企业每周工作少于15个小时的人员\n\n失业的计算劳动力人口  &#x3D; 就业人口+失业人口\n失业率：失业者占劳动力的百分比\n参工率：劳动力占成年人口的半分比\n失业的类型按劳动力市场结构分为：**摩擦性失业、结构性失业、周期性失业**\n摩擦性失业：\n经济中由于劳动力的正常流动而引起的失业。\n原因：既有自愿失业的因素（不满待遇），也有非自愿失业的因素（认为没有合适的岗位），但社会上存在适合它们的工作岗位，只是暂时未进入就业状态。\n特点：经济中失业人数与职位空缺数额相当。摩擦性失业是由于劳动者流动不充分以及劳动力市场信息不灵等原因引起的。\n摩擦性失业通常起源于劳动力的供给方\n结构性失业：是劳动者的技能与空闲的工作岗位不匹配造成的失业。\n原因：由于社会中经济结构的变化进而引起劳动力需求结构的变化，而劳动力供给的调整往往却滞后于劳动力需求结构的变动，因此导致结构性的失业。\n特点：失业和职位空缺大致相等，但劳动力的供求长期不一致，往往属于非自愿失业。通常持续时间较长。\n摩擦性失业与结构性失业都属于自然失业\n某个行业不景气导致的失业是结构性失业\n周期性失业：\n是指由于**总需求水平不足，导致企业生产减少，开工不足，由此带来的劳动力总需求不足而引起的短期失业，又称需求不足型失业**。\n原因：与经济周期相联系。经济繁荣时期总需求水平高，则失业率低；相反经济萧条时期总需求不足，则失业率高。\n特点：周期性失业基本上属于非自愿性失业。\n周期性失业通常起源于劳动力需求不足。\n摩擦性失业和结构性失业在劳动力市场处于均衡时也存在，而周期性失业时劳动力市场必定处于非均衡状态。\n康波周期：\n\n衰退阶段\n复苏阶段\n过热阶段\n滞涨阶段\n\n所有的劳动力都有工作才是充分就业吗？\n充分就业：除了摩擦性失业和结构性失业外，所有愿意工作的人都在从事工作的状态。\n自然失业率：充分就业时的失业率 &#x3D; 摩擦性失业率 + 结构性失业率\n自然失业率是劳动力市场和商品市场处于均衡状态时的失业率，也是能够长期持续存在的最低失业率。\n失业的影响\n影响GDP\n影响社会（公众心理）安定\n短期，小影响多数人\n长期，大影响少数人\n\n\n\n造成的经济损失：失业会对社会经济造成重大影响而带来巨大损失，其中，最明显地表现为实际GDP的减少。\n奥肯定律：失业意味着生产要素的非充分利用，失业率的上升会伴随着实际GDP的减少，失业率每上升1%，实际GDP大约减少潜在GDP的2%。\n失业的社会成本：失业不仅会减少当事人的收入，还会给他们造成很大的心理伤害，从社会方面看，事业的影响虽然无法用货币单位表示，但这种影响可能是非常巨大的。\n失业对分配的影响：失业成本的承担很不平衡，如果将失业划分为短期失业和长期失业的话，短期失业与长期失业对收入分配所造成的影响完全不同。\n\n短期失业（主要指摩擦性失业）：由于事业的持续时间很短，且人员流动频繁，失业成本将由众多人承担，因而每个人承担的损失就很小。\n长期失业，则主要由劳动力市场结构因素或工资刚性形成，失业成本主要由少数人承担，每个人承担的损失较大。另一方面，失业者可能停止纳税，还有可能得到失业保险的好处或其他政府转移，则事业的损失由就业者（纳税人）承担。\n\n通货膨胀概念：是指在**纸币流通的制度下，在一定时期内，由于货币发行量超过流通中实际货币需求量而引起的物品和劳务价格的普遍持续性**上涨。\n使用金银流通的社会一般不会发生通胀，只会通缩，因为金银的量太少了，跟不上经济发展的需求。\n衡量：\n衡量通货膨胀的指标由物价指数（价格指数）来表示，称为通货膨胀率。\n西方主要使用消费者价格指数CPI、生产者价格指数PPI、GDP来衡量。\n分类：\n按价格上涨速度或是通货膨胀率的高低：\n\n爬行的通货膨胀：1% ~ 3%    有利于经济\n温和的通货膨胀：3% ~ 6%\n严重的通货膨胀：6% ~ 9%\n奔腾&#x2F;急剧的通货膨胀：10% ~ 100%\n恶性&#x2F;超速的通货膨胀：三位数以上，价格水平失控（津巴布韦）\n\n按对价格影响的差别：\n\n平衡的通货膨胀：商品和劳务的价格同步上升\n不平衡的通货膨胀：商品和劳务的价格上升比例不同\n\n按照人们对通货膨胀的预料程度：\n\n预料得到的通货膨胀（惯性通货膨胀）\n未预料到的通货膨胀\n\n通货膨胀的表现形式不只有物价上涨，限购也是一种（限制人们消费）\n经济效应产量效应：短期内，未预料的、温和的通货膨胀会促进经济增长。长期来看，通货膨胀与产量之间没有必然的联系\n收入再分配效应：其使一部分人实际收入增长，另一部分人实际收入减少。（扣除了通胀影响之后）\n通胀利于债务人（欠钱的人）、雇主、政府；不利于债权人（债主）、工人、公众。\n名义上的利率、收入，扣除掉通胀率的影响就是实际的利率、收入。\n财富再分配效应：非预期的通胀还会引起财富的再分配效应。对拥有货币财产与非货币财产者的财产净值的影响。\n在通胀期，非货币资产能保值，而货币资产不能保值。\n通胀的成因：\n\n需求拉上的通胀：需求增长引起的通胀\n成本推动的通胀：成本的提高引起的通胀。\n需求拉上余成本推动混合的通胀\n结构性通胀：产业和部门之间的“看齐”行为，导致一般物价水平上涨引起的通胀（深圳）\n\n只要需求增加，就会发生通胀吗 ？   不是\n是不是只有充分就业时才会出现通胀？\t不是\n通胀的防范和治理\n防止一次性通胀演变为持续性通胀\n抑制持续性通胀\n治理通胀的具体政策（对策）\n需求政策：采取紧缩需求的政策就能取得一定的效果。\n收入政策：限制提高工资和获取利润，以抑制成本推动型通胀\n收入指数化政策：各种收入部分或全部地与物价指数相联系。\n供给政策：增加生产和供给。\n减税\n削弱政府开支增加幅度\n限制货币增长率\n改善劳动市场结构的人力资本政策\n\n\n\n\n\n菲利普斯曲线最初的曲线:当失业率较低时，货币工资增长率较高；当失业率较高时，货币工资增长率较低，甚至负数。\n改进后：**刻画了失业率和通货膨胀率之间的负相关系**。\n菲利普斯曲线的发展三阶段：\n\n通胀和失业率之间存在一种稳定的负相关系\n提高通货膨胀，可以降低失业率\n降低通货膨胀，失业率会升高\n\n\n解释短期菲利普斯曲线与长期菲利普斯曲线之间的根本区别\n短期菲利普斯，附加了预期\n适应性预期：人们根据过去的经验来形成并调整对未来的预期。\n缺陷：忽略了工人对通货膨胀的预期。\n长期菲利普斯，是一条垂直于自然失业率水平的垂线。\n\n\n失业率和通胀之间不存在规律的替代关系。\n\n菲利普斯曲线的提出\n当失业率较低是，货币工资增长率较高，反之，当失业率较高是，货币工资增长率较低，甚至为负数。\n改良\n失业率与通胀之间的负相关系，表明失业率与通胀之间存在着替换的关系\n通胀率 &#x3D; 工资增长率 - 劳动生产率增长率\n附加预期的菲利普斯曲线——短期菲利普斯曲线（向右下倾斜）\n适应性预期：人们会根据过去的经验来形成并调整对未来的预期。\n曲线的缺陷：忽略了工人对通胀的预期，得到了短期菲利普斯曲线\n曲线的政策含义：在短期中引起通胀率上升的扩张性财政政策与货币政策是可以起到减少失业的作用的。\n调整总需求的宏观经济政策在短期是有效的。\n长期菲利普斯曲线——表明通货膨胀和失业率之间不存在相互替代关系。\n小结：\n\n题目其他条件不变，消费者预期某商品的价格将要下降，则对该商品的现期需求会——减少。\n其他条件不变，消费者的收入增加将导致——需求增加\n题型20*1单选\n10*1判断\n名词解释5*3\n简答3-5 &#x3D; 25\n计算2*5\n分析和论述2*10\n先写专业词的概念，分析题要有图，解释图的变化趋势\n"}]